<!DOCTYPE Book PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
        <!ENTITY lt "<">
        <!ENTITY gt ">">
        <!ENTITY amp "&">
]>

<book>
<title>
  The Sierra On-Line Adventure Game Interpreter Specification
</title>
<titleabbrev>
  AGI Specs
</titleabbrev>

<bookinfo>
<authorgroup>
  <author>
    <firstname>Peter</firstname>
    <surname>Kelly</surname>
    <affiliation>
      <jobtitle>Author of MEKA and AGI Studio</jobtitle>
    </affiliation>
  </author>

  <author>
    <firstname>Lance</firstname>
    <surname>Ewing</surname>
    <affiliation>
      <jobtitle>Author of MEKA and The Ruby Cast</jobtitle>
    </affiliation>
  </author>

  <author>
    <firstname>Claudio</firstname>
    <othername>S.</othername>
    <surname>Matsuoka</surname>
    <affiliation>
      <jobtitle>Member of the Sarien development team</jobtitle>
    </affiliation>
  </author>

  <author>
    <firstname>Nick</firstname>
    <surname>Sonneveld</surname>
    <affiliation>
      <jobtitle>Author of the New Adventure Game Interpreter</jobtitle>
    </affiliation>
  </author>
</authorgroup>


<abstract><para>
  This document is a collection of all the information currently known
  about the structure and operation of the Adventure Game Interpreter,
  used in 1984--1989 for a variety of adventure games published by
  Sierra On-Line such as Space Quest I and II, and Leisure Suit Larry in
  the Land of the Lounge Lizards.
</para></abstract>

<releaseinfo>
  $Id$
</releaseinfo>

<legalnotice><para>
  Copyright (C) 1997-2001 by the authors
</para><para>
  Permission is hereby granted, free of charge, to any person obtaining
  a copy of this documentation to deal in the Documentation without
  restriction, including without limitation the rights to use, copy,
  modify, merge, publish, distribute, sublicense, and/or sell copies of
  the Documentation, and to permit persons to whom the Documentation is
  furnished to do so, subject to the following conditions:
</para><para>
  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Documentation.
</para><para>
  THE DOCUMENTATION IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE DOCUMENTATION OR THE USE OR
  OTHER DEALINGS IN THE DOCUMENTATION.
</para><para>
  The Adventure Game Interpreter was originally developed by Sierra
  On-Line, Inc. "Sierra On-Line Inc. (TM)" is a registered trademark
  of Sierra On-Line, Inc. Names of the AGI games produced by Sierra
  On-Line, Inc., including, but not limited to, "Leisure Suit Larry
  in the Land of the Lounge Lizards", "Space Quest: The Sarien
  Encounter" and "Space Quest 2: Vohaul's Revenge" are trademarks of
  Sierra On-Line, Inc.
</para></legalnotice>

</bookinfo>

<chapter id="intro">
<title>Introduction</title>
<para>
  AGI (Adventure Game Interpreter) was the first major interpreter used
  by Sierra. With the release of King's Quest 1 in the early 80's, it
  introduced the gaming world to the concept of a 3D graphical adventure
  game, where the player could move a character around the screen,
  behind, in front of and over objects. Other commands could be typed
  in, just like a text adventure. This concept, in various forms, has
  been used many many times since, by Sierra and other companies. It
  has proved very successful and has been used until the late 90's in
  games such as Leisure Suit Larry 7.
</para>

<sect1 id="credits">
<title>Credits</title>
<para>
  The following people (and probably more) have contributed to this document:
  Peter Kelly &lt;ptrkelly@ozemail.com.au&gt;,
  Lance Ewing &lt;lance.e@ihug.co.nz&gt;,
  Alex Simkin &lt;simkin@argussoft.ru&gt;,
  Vassili Bykov &lt;nest@rtsnet.ru&gt;,
  Anders M. Olsson &lt;anders.m.olsson@abc.se&gt;,
  Jeremy Hayes &lt;mikeph@concentric.net&gt;,
  Joakim Möller &lt;jmoller@algonet.se&gt;,
  Martin Tillenius &lt;mrtn@rocketmail.com&gt;,
  Stuart George &lt;entropy@ihug.com.au&gt;,
  Dark Minister &lt;dark_minister@hotmail.com&gt;,
  Kevin A. Lee,
  Jens Christian Restemeier &lt;jchrr@hrz.uni-bielefeld.de&gt;,
  Paul Lunga &lt;paul123@freenet.tlh.fl.us&gt;,
  Ian Schmidt &lt;irsman@iag.net&gt;,
  XoXus &lt;xoxus@usa.net&gt;,
  Claudio Matsuoka &lt;claudio@helllabs.org&gt;,
  Nick Sonneveld &lt;&gt;.
</para>
</sect1>
</chapter>

<chapter id="overview">
<title>General AGI overview</title>
<para>
  AGI stands for <emphasis/Adventure Game Interpreter/ and it is the old
  version of Sierra On-Line's 3D adventure interpreter. It was used
  in Donald Duck's Playground, King's Quest 1 to 4, Space Quest 1 and 2,
  Police Quest, Leisure Suit Larry in the Land of the Lounge Lizards,
  The Black Cauldron, Mixed-Up Mother Goose, Gold Rush! and Manhunter
  1 and 2. There were also a number of demos that were written in AGI:
  the XMAS animated christmas card, the King's Quest 4 demo, and several
  Sierra demo packs 1--4.
</para><para>
  Interpreters that run AGI bytecode have been implemented in different
  platforms, such as IBM-PC, Tandy, Amiga, Atari ST, Macintosh, Apple
  II and Apple IIgs.
</para>

<sect1>
<title>Versions of the AGI interpreter</title>
<para>
  There were three main version of the AGI interpreter. The first
  version was the one used with KQ1 and KQ2 when they were originally
  released. The second version is the one we are most familiar with
  and was used for the majority of the above games. The third and final
  version of the AGI interpreter came out for only a short while before
  the SCI interpreter hit the scene. Sierra obviously noticed the
  increased size of the games and therefore added data compression
  to this version (there are a few differences in the way the data is
  stored other than the compression as well, but the data itself still
  contains the same information).
</para>
</sect1>

<sect1>
<title>AGI game files</title>
<para>
  An AGI game package contains platform-independent AGI game resource
  files and the platform-specific interpreter binaries. The
  platform-independent games can be summarized as follows:
</para>

<variablelist>
  <varlistentry>
    <term><filename/{log,view,pic,snd}dir/
    <listitem><para>
      These directory files give the location of each of logic, picture,
      view, and sound resources within the ``vol'' files. In version 3 of
      the interpreter, these files are combined into a single file with a
      header which gives the offset of each part. The name of this single
      directory file is <filename/*dir/ (or just <filename/Dirs/ in some
      versions) where the <filename/*/ is the game ID code (e.g.
      <filename/kq4dir/, <filename/mh2dir/, <filename/grdir/,
      <filename/bcdir/, <filename/mh1dir/).
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term><filename/vol.*/</term>
    <listitem><para>
      These files contain the main game data. Whereas the AGI
      interpreter may not change between games, the vol files will always be
      different. They look very much like a virtual device which contain
      many individual files indexed by the directory files.
      In version 3 games, the ``vol'' files are named after the game with a
      <filename/vol/ suffix (e.g. <filename/kq4vol.0/, <filename/grvol.10/,
      <filename/mh2vol.5/).
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term><filename/words.tok/</term>
    <listitem><para>
      This file contains a list of all the words that the user may type
      in during the game. The words are partly compressed and encrypted
      as well, so you won't be able to see the words if you display the
      file as you normally would.
    </para></listitem>
  </varlistentry>

  <varlistentry>
    <term><filename/object/</term>
    <listitem><para>
      This file contains a list of all the inventory members
      that the user can find in the game. This file is also encrypted but
      in a different way using the phrase "Avis Durgan". Each object also
      has associated with it a number that gives the starting room for that
      object.
    </para></listitem>
  </varlistentry>
</variablelist>

</sect1>

<sect1>
<title>AGI resource files</title>
<para>
  AGI uses four types of resources: Logic, Picture, View and Sound.
</para><para>
  Logic resources contain the scripts with AGI commands which the
  interpreter runs. All rooms have a Logic script that governs what
  happens within that room. At the end of a Logic resource there is a
  text section containing all the messages that are specific to the
  functioning of that particular logic script (these are encrypted with
  the ``Avis Durgan'' string in the case of version 2 games).
</para><para>
  Picture resources contain the picture codes which are used to draw
  the full screen pictures that you see for each room. The codes are
  vector based and draw a screen in the manner that the artist
  originally did. There are two screens store in each picture resource:
  the <emphasis/visual screen/ and the <emphasis/priority screen/.
  The priority screen contains priority information and control lines.
  In version 3 games, this file is not compressed with adaptive LZW as
  the View, Logic, and Sound resources are.
</para><para>
  View resources contain all the still props (like objects), actors
  (like ogres and Labion Terror Beasts), and animated props (like flags
  blowing in the breeze). All inventory item pictures are a specialized
  type of view which has a text description tagged to the end of the
  file. Views are made up of many <emphasis/loops/ (animation cycles)
  that are in turn made up of many <emphasis/cels/ (a single frame of
  animation).
</para><para>
  Sound resources contain all the musical scores and sound effects
  which on the IBM-PC are one voice over the PC speaker but on some
  machines, like the PCjr and Amiga will be in three voices. The Apple
  IIgs version of the interpreter recognize PCM sampled sound effects
  and 16 channel wavetable-based MIDI music.
</para>
</sect1>

<sect1>
<title>What is Ego?</title>
<para>
  Ego is the name given to the player character (e.g. Rosella, Roger,
  Graham). The AGI games have commands which actually use the name ego
  in the command itself (e.g. <function/follow.ego/).
</para>
</sect1>

<sect1>
<title>The script language</title>
<para>
  The AGI script language 
</para>

<example>
<title>Example LOGIC code (from the AGI version of KQ4)</title>
<para>
  <programlisting>
animate.obj (smoke);
ignore.horizon (smoke);
set.view (smoke, v.fish.cabin);
set.loop (smoke, 1);
ignore.blocks (smoke);
position (smoke, 95, 16);
work = 3;
step.time (smoke, work);
cycle.time (smoke, work);
draw (smoke);
  </programlisting>
</para>
</example>

</sect1>

<sect1>
<title>Debug modes</title>
<para>
  Testers often need some way to achieve certain things quickly so that
  they can test a certain part of the game. Most AGI games still have
  the debug code that these testers used when the games were being
  developed. Of the thirteen AGI games mentioned above, there are only
  three which I havn't discovered the debug mode in. Most of the games
  activate their debug modes by pushing the
  <keycombo><keycap>ALT</keycap><keycap>D</keycap></keycombo>
  key combination. The other games used a magic phrase to enter the
  debug mode.
</para>

<informaltable>
  <tgroup cols="2">
    <thead>
      <row><entry/Game/ <entry/Command/ </row>
    </thead>
    <tbody>
      <row><entry/Gold Rush/     <entry><command/BIRD MAN/</entry></row>
      <row><entry/King's Quest 3 <entry><command/RATS ASS/ (in some versions
        <keycombo><keycap/ALT/<keycap/D/</keycombo>)</entry></row>
      <row><entry/Police Quest   <entry><command/STINK BUG/ </entry></row>
      <row><entry/>Space Quest 2 <entry><command/BACKSTAGE/ or
        <command/DBG/ (<command/TESTER/ brings up ego position) </entry></row>
    </tbody>
  </tgroup>
</informaltable>

<para>
  The following are standard debug mode commands:
</para><para>
  <simplelist>
    <member><command/TP/: Teleport to another room.
    <member><command/SHOW PRIORITY/: Show the current room's priority
      screen and control lines.
    <member><command/GET OBJECT/: Get any inventory member.
    <member><command/GIMME GIMME/: Get all inventory members.
    <member><command/SHOW FLAG/: Show one of the 256 flags.
    <member><command/SET FLAG/: Set one of the 256 flags.
    <member><command/RESET FLAG/: Clear one of the 256 flags.
    <member><command/SHOW VAR/: Show one of the 256 variables.
    <member><command/SET VAR/: Change the value of one of the 256 variables.
    <member><command/POSITION/: Change egos position.
    <member><command/SHOW POSITION/: Show egos current screen coordinates.
    <member><command/OBJECT NUMBER/: Gives a list of all the objects and their
      object numbers.
    <member><command/OBJECT ROOM/: Says which room an object is found in.
    <member><command/ROOM/: Says what room number ego is currently in.
    <member><command/SET PRIORITY/: Set the priority of ego.
    <member><command/RELEASE PRIORITY/: Release the last priority that
      ego was set to.
  </simplelist>
</para><para>
  You may be lucky to find a game which allows command tracing. Almost
  all games have this facility taken out. It is possible to get it to
  work on some games if you add certain things to the data. What this
  mode does is to respond to the <keycap/Scroll-Lock/ key by displaying
  a window box which you can step through the test commands that are being
  executed. In this case most keys step forward one test command, and
  the <keycap/+/ key steps to the start of the next logic script.
</para><para>
   Example:
<programlisting>
     =============================
     0: greatern (17, 0)
                 (0, 0)         :F

</programlisting>
</para><para>
  The line of <keycap/=/ characters shows the start of an AGI cycle.
  The number at the start of a line gives the script number that is
  currently being executed. In the case above, the <literal/(0, 0)/ is
  the numeric value of the two parameters above it, i.e. the 17 in the
  above line refers to variable 17, and the 0 below it is the current
  value of variable 17. The <literal/F/ or <literal/T/ characters at
  the end of a line tell us whether the expression evaluated to be
  false or true.
</para><para>
  Notice that when you reach the start of <filename/logic.0/ again,
  all the controlled sprites on the screen are updated. Using this
  tracing mode is a good way to get a feel for what happens which each
  cycle of interpretation.
</para>
</sect1>

<sect1 id="bands">
<title>The priority screen</title>

<sect2>
<title>Priority data</title>
<para>
  To create a three dimensional sensation in the rooms, every object is
  constructed with a priority in relation to other objects. The higher
  the priority value, the more priority it has to be drawn.
</para><para>
  The screen has about eleven even sized invisible bands across the
  screen called priority bands. When ego walks up and down the screen,
  he or she will move from one priority band into the next priority band.
  This is used to give the affect of ego moving behind trees and rocks etc.
</para><para>
  Although the priority bands are invisible in the finished product, the
  artist must use them like a horizontal grid as he draws the room.
  Considerable effort and time is spent placing houses, bushes, and
  trees so the player remains unaware of the rooms mathematical rigidity.
  It wouldn't so for things to look like they were lined up on
  a checker board.
</para><para>
  In AGI games, the priority bands lie roughly in the following y ranges:
</para>

<informaltable>
  <tgroup cols="2">
    <thead>
      <row><entry/Priority band/ <entry/Y range/ </row>
    </thead>
    <tbody>
      <row><entry/ 4/ <entry/    -    / </row>
      <row><entry/ 5/ <entry/ 48 - 59 / </row>
      <row><entry/ 6/ <entry/ 60 - 71 / </row>
      <row><entry/ 7/ <entry/ 72 - 83 / </row>
      <row><entry/ 8/ <entry/ 84 - 95 / </row>
      <row><entry/ 9/ <entry/ 96 - 107/ </row>
      <row><entry/10/ <entry/108 - 119/ </row>
      <row><entry/11/ <entry/120 - 131/ </row>
      <row><entry/12/ <entry/132 - 143/ </row>
      <row><entry/13/ <entry/144 - 155/ </row>
      <row><entry/14/ <entry/156 - 167/ </row>
      <row><entry/15/ <entry/   168   / </row>
    </tbody>
  </tgroup>
</informaltable>

<para>
   The reason that there is no priority 0 to 3 shown above is because
   they don't exist. Priority four has the least priority. It is given to
   the background components. Nothing is ever given a priority of four
   except for the background parts of the picture itself. Values 0 to 3
   (represented by colours black, blue, green, and cyan) are infact used
   for <emphasis/control lines/ drawn in the priority screen.
</para>
</sect2>

<sect2><title>Control lines</title>
<para>
   As the room nears completion, the artist adds control lines that
   determine where ego can walk. These are the black, blue, green, and
   cyan lines drawn on the priority screen. They control what happens to
   ego when he or she walks past these lines. They might trigger a falling
   script for the edge of a cliff or a drowning script for the edge of a
   lake. There are four types of control lines:
</para>

<itemizedlist>
  <listitem><para>
    the black control line is a unconditional obstacle;
  </para></listitem>

  <listitem><para>
    the blue is a conditional obstacle;
  </para></listitem>

  <listitem><para>
    the green is an alarm (trigger) line;
  </para></listitem>

  <listitem><para>
    the cyan is typically used for water (or something that a object can
    be confined to being on).
  </para></listitem>
</itemizedlist>

<para>
  In most games, black and blue appear to be used for obstacle use which
  means that ego can't walk past that line. This is the main use for
  control lines. Other uses include triggers which active an event. For
  example, control lines are used at the edge of water, or the edge of a
  cliff to tell the interpreter at what point it should execute its
  ``drowning'' or ``falling'' sequence of events.
</para>
<para>
  The cyan control line will often be a whole filled area. An object
  such as a crocodile can be given the <function/object.on.water/ command
  and then told to wander. The interpreter will only allow the crocodile
  to wander over the area that has a control colour of cyan.
</para>

<sect2>
<title>Control lines and priority information</title>
<para>
  In the AGI interpreter, the priority data and control lines are drawn
  on the same screen. This can lead to problems when the interpreter
  wants to know the priority of a pixel that has a control line drawn
  over it. The way that the interpreter deals with this is to search
  downwards until it finds a pixel that isn't a control line and it
  assumes that the pixel it is looking at is the same priority as the
  one it found by searching downwards (increasing Y). Usually this will
  be the pixel immediately below but for some pixels this can be as far
  away as twenty pixels or more!! In some games this can cause a
  noticeable visual error if you are aware of it. For example, you could
  walk behind a strip of grass that thinks it is part of the tree below
  it (KQ1, room 20, blue control line beside left hand tree). There are
  also a number of other one pixel visual errors that are virtually
  unnoticeable if you don't know they are there.
</para><para>
<programlisting>
                             _
                            |_| <- priority required for this pixel.
      Search downwards  |   |_| \
      for next pixel    |   |_|  \___ These pixels have all got a control
      with a priority  \|/  |_|  /    line covering their priority info.
                        V   |_| /
                            |_| <- use this pixels priority.
</programlisting>
</para><para>
   It may be possible to draw the control lines on a separate screen
   altogether which would conserve the priority information.
</para>

</sect1>
</chapter>


<chapter id="agi"><title>AGI internals</title>

<sect1 id="intworks"><title>How the interpreter works</title>
<para>
(From the AGDS documentation, translated by Vassili Bykov)
</para><para>
   The AGI interpreter contains:
   <itemizedlist>
    <listitem>
     <para>256 8 bit variables, numbered from 0 to 255;</para>
    </listitem>
    <listitem>
     <para>256 flags, numbered from 0 to 255;</para>
    </listitem>
    <listitem>
     <para>a number of objects controlled by the interpreter, one of which
     (the object 0) may be controlled by the player using the keyboard;</para>
    </listitem>
    <listitem>
     <para>a number of inventory members;</para>
    </listitem>
    <listitem>
     <para>12 40-character string variables).</para>
    </listitem>
   </itemizedlist>
</para><para>
   Some variables (0 - 26) and flags (0 - 15) are reserved by the
   interpreter, all others are available to be used by the programmer.
</para><para>
   The interpreter provides a common variable and flag space for all the
   scripts simultaneously loaded in the memory. The number of objects
   and things is determined by the OBJECT resource.
</para><para>
   The interpreter's actions are described using the commands of its
   language. For example, there are commands to manage objects, load
   and unload resources, etc. These commands will be described in
   detail in <xref linkend="cmdref">.
</para><para>
   Note: Any variable, flag, object, string, word, message, etc. has a
   unique ID number, and numbering of different data types is independent
   (for example, there can be a variable number 5, a string number 5,
   and a flag number 5).
</para>

<sect2><title>Resources - the fundamental AGI data type</title>
<para>
   When we develop a game, we invent the plot, create objects of the
   game, animate them, develop scenery and a dictionary of words for the
   dialogue with the player. To describe all of these, resources are
   used. To create some of the resources, we use utilities included with
   AGDS, in this case the input of the utilities are resources.
   <emphasis>(Sounds weird, but that's literally what it says. --VB)</emphasis>
</para><para>
   Here is a list of all the existing resources. Resources are used to
   represent:
   <itemizedlist>
    <listitem><para>
      colour background drawings (PICTURE resource);
    </para></listitem>
    <listitem><para>
      colour animated images (VIEW resource);
    </para></listitem>
    <listitem><para>
      sound effects (music, noise) (SOUND resource);
    </para></listitem>
    <listitem><para>
      inventory members and other objects (OBJECT resource);
    </para></listitem>
    <listitem><para>
      system dictionary for communicating with the user (WORD resource);
    </para></listitem>
    <listitem><para>
      programs in internal AGI programming language (LOGIC resource).
    </para></listitem>
   </itemizedlist>
</para>
</sect2>

<sect2><title>General principles of the interpreter operation</title>
<para>
   Let us now consider the interpreter algorithm and the purpose of
   reserved variables and flags.
</para><para>
   When interpreter starts, LOGIC resource number 0 is loaded in memory.
   It stays there during the whole play time and determines all the
   interpreter's actions related to the overall control of the game. The
   interpreter works in a loop, i.e. all its actions are described in
   <xref linkend="workcycle"> and the block diagram below.
</para><para>
   In each cycle the interpreter performs the following basic actions:
   <orderedlist>
    <listitem><para>
      time delay;
    </para></listitem>

    <listitem><para>
      clear the keyboard buffer;
    </para></listitem>

    <listitem><para>
      poll the keyboard and the joystick;
    </para></listitem>

    <listitem><para>
      analyse some of the reserved variables and flags (see block diagram);
    </para></listitem>

    <listitem><para>
      for all controllable objects for which <function/animate_obj/,
      <function/start_update/ and <function/draw/ commands were issued,
      directions of motion are recalculated;
    </para></listitem>

    <listitem><para>
      logic resource 0 is executed, as well as any logics it
      calls -- which, in turn, can call other logics. Depending on the
      state of variables and flags analyzed at step 4 the number of
      commands interpreted at stage 4 commands varies from one iteration
      of the cycle to another depending, for example, on a number of
      logic resources to be called in the current situation;
    </para></listitem>

    <listitem><para>
      test if the <function/new_room/ command has been issued;
    </para></listitem>
   </orderedlist>

   then the cycle is repeated.
</para><para>
   All logics (programs and subroutines) simultaneously loaded in memory
   operate on a common set of variables, flags, and strings, each
   identified by a unique for each data type ID number.
</para><para>
   The fact that the interpreter runs in a loop influences the general
   programming principles and style when programming for AGDS. This makes
   programming a little unusual and takes a certain time to get used to.
   For example, many cyclic activities requiring explicit loops in
   ``conventional'' programming languages are executed in the interpreter
   programs by default, provided the program has a proper structure.
</para><para>
   General hints on how to reduce the time to adapt to the interpreter's
   language are given below, using an educational program Thunderstorm
   as an example. However, this does not reduce the usefulness of
   analyzing the game programs of Sierra On-Line, Inc.
</para>
</sect2>

<sect2 id="workcycle"><title>Interpreter work cycle</title>
<para>
<programlisting>
                     +---------------------------+
                     |      1. delay time        |
                     +---------------------------+
                                   |
                                   V
                     +----------------------------+
                     |2. clear the keyboard buffer|
                     +----------------------------+
                                   |
                                   V
                     +---------------------------+
                     |      Flag (2) - > 0       |
                     |      Flag (4) - > 0       |
                     +---------------------------+
                                   |
                                   V
                 +-------------------------------------+
                 | 3. poll keyboard and joystick       |
                 +-------------------------------------+
                                   |
                                   V
                 +-------------------------------------+
                 | If the current mode is              |
                 | - program_control, the direction of |
                 |   Ego motion <-- var(6).            |
                 | - player.control, var (6) --> dir.  |
                 |   of Ego motion.                    |
                 +-------------------------------------+
                                   |
                                   V
    +---------------------------------------------------------------+
    | For all objects for which command animate.obj, start_update   |
    | and draw were carried out, the recalculation of the direction |
    | of movement is performed.                                     |
    +---------------------------------------------------------------+
                                   |
                                   V
    +---------------------------------------------------------------+
    | If the score has changed (var (3)) or the sound has been      |
    | turned on or off (Flag (9)), the status line is updated.      |
    +---------------------------------------------------------------+
                                   |
                                   +---------+
                                             V
                               +--------------------------+
             +---------------->| 4 Logic 0 is executed    |
             |                 +--------------------------+
             |                               |
             |                               V
             |          +--------------------------------------+
             |          | - Dir. of motion of Ego  <-- var (6) |
             |          | - If score (var (3)) or Flag (9)     |
             |          | have changed their values - update   |
             |          | the status and score (on Var (3));   |
             |          | - Var (5) - > 0;                     |
             |          | - Var (4) - > 0;                     |
             |          | - Flag (5) - > 0!!!!                 |
             |          | - Flag (6) - > 0;                    |
             |          | - Flag (12) - > 0.                   |
             |          +--------------------------------------+
 +----------------------------+               |
 | Execute:                   |               V
 | ~~~~~~~~~~~~~~~~~~~~~~~~   |  +------------------------+
 | - stop.update;             |  | Update all controlled  |
 | - unanimate.all;           |  | objects on the screen. |
 | - destroy all logic        |  +------------------------+
 |   resources except         |                   |
 |   for logic 0;             |                   V
 | - player.control;          |            +--------------+
 | - unblock;                 |            | new.room n   |
 | - set_horizon 36;          |            | or           |
 | - var (1) = var (0);       |            | new.room.v n |
 | - var (0) = n | Var(n);    |            | was issued?  |
 | - var (4) = 0;             |            |              |
 | - var (5) = 0;             |            +-------+------+
 | - var (9) = 0;             |<-----------+  Yes  |  No  |
 | - var (16) = number of     |            +-------+--+---+
 | view assoc. w/Ego;         |                       |
 | - Ego coords from var (2); |                       |
 | - var (2) = 0;             |                       |
 | - flag (2) - > 0;          |                       V
 | - flag (5) - > 1!!!!       |               +--------------+
 | - score < - var (3);       |               | Go to step 1 |
 +----------------------------+               +--------------+
</programlisting>
</para>
</sect2>
</sect1>

<sect1 id="vartypes"><title>Variable types</title>
<para>

   There is a number of data types used as AGI command parameters,
   listed below:
</para>

<sect2><title>Variable</title>
<para>
   This is an unsigned eight-bit variable type equivalent of a byte, or
   unsigned char. Its values range from 0 to 255. There are 256 variables
   and in the LOGIC code (listed in <xref linkend="varlist">);
   they are numbered from 0 to 255 and are indentified by their number.
   (The original LOGIC source code that Sierra's programmers wrote would
   have had textual identifiers for these variables, but when the LOGIC
   source was compiled into the LOGIC codes, the original variable names
   were lost. To the interpreter, the variables are known by their index
   into the variable table.)
</para><para>
   Variables are the most commonly used type. They feature in arithmetic
   commands such as addition and multiplication, and a lot of AGI commands
   have a version that has variable paramaters as an alternative to the
   normal constant parameter versions.
</para>

<sect2><title>Flag</title>
<para>
   Flags are the boolean type of the AGI system. Their value can be
   either 1 or 0 (true or false). There are 256 flags that are numbered 0
   to 255. (In the original LOGIC source code, they would have had textual
   identifiers, but in the compiled LOGIC code they are known only by
   their index into the interpreters flag table.)
</para><para>
   Flags are used to indicate when certain things have taken place.
</para>

<sect2><title>String</title>
<para>
   According to another source, there are only 12 strings available. I
   don't know if this is true, but it agrees with the minimum amout of
   space set aside for strings that I have seen in examining memory usage
   during a game. However, the majority of AGI games have enough room for
   exactly 24 strings: AGI interpreter versions 2.089, 2.411, 3.002.107
   and 3.002.149 have room for 12 strings, the remaining versions have
   room for 24 strings.
</para><para>
   Whether the versions that have enough space for 24 strings do infact
   support 24 strings is not known. Strings are 40 characters long which
   includes the zero terminator. String number zero is usually the input
   prompt (e.g. <prompt/">"/ or <prompt/"]"/).
</para>

<sect2><title>Word</title>
<para>
   Words are the words that the user types in. An input sentence is
   composed of a number of words. The important words (e.g. for the
   sentence ``look at the tree'', ``look'' and ``tree'' are important) are
   assigned to the words variables corresponding to their place in the
   sentence once unimportant words and punctuation has been taken out.
   For example, in the earlier example <literal/word(1)/ would be ``look'' and
   <literal/word(2)/ would be ``tree''. Words can be converted to strings.
</para>

<sect2><title>Inventory Item</title>
<para>
   There are a number of AGI commands that refer to inventory members (e.g.
   <function/get/, <function/drop/). One of the arguments to these commands will
   represent an inventory member number. In the original script source text,
   the programmer would have written things like <function/get(dagger)/ but the
   interpreter knows them only as an index into the OBJECT table.
</para>

<sect2><title>Object</title>
<para>
   There can be a bit of confusion between this type and the inventory
   member because of the name of the <filename/object/ file. The
   <filename/object/ file has almost nothing to do with what the
   interpreter generally calls objects. There are a large number of
   AGI commands that deal with objects. For example,
</para><para>
<programlisting>
move.obj
animate.obj
set.view
set.cel
set.loop
draw
</programlisting>
</para><para>
   In fact the interpreter calls its usage of the VIEW resource
   ``objects''. An object is one usage of a VIEW resource. It is
   essentially an entry in the object table (or VIEW table/VIEW list).
   Many objects can use the same VIEW resource for its appearance which
   can be seen in KQ1 and BC with the crocodile filled moats.
</para><para>
   So when an AGI command has an object as a parameter to it, the value
   of the parameter is an index number into a table of objects that the
   interpreter is currently controlling.
</para>

<sect2><title>Message</title>
<para>
   At the end of every LOGIC file is a message section. There need not be
   any messages in it, but it will still exist. Messages in <filename/logic.0/
   are global messages whereas all other messages can only be accessed from
   their own LOGIC code. AGI commands that have messages as parameters
   refer to a message number in their own LOGIC file. I say that those in
   <filename/logic.0/ are global because messages and strings can contain format
   codes one of which is used to display messages from <filename/logic.0/.
</para><para>
   Example:

<programlisting>
print ("Message 34 in logic.0 is %g34.");
</programlisting>

</para><para>
   Therefore messages in <filename/logic.0/ can be displayed by any
   script in this way.
</para>
</sect1>

<sect1 id="varlist"><title>Variables used by the interpreter</title>
<para>
   On interpreter startup all variables are set to 0.

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row> <entry>Variable</entry> <entry>Description</entry> </row>
     </thead>

     <tbody>
      <row>
       <entry>0</entry>
       <entry>
         Current room number (parameter of <function/new_room/),
         initially 0
       </entry>
      </row>

      <row>
       <entry>1</entry>
       <entry>Previous room number</entry>
      </row>

      <row>
       <entry>2</entry>
       <entry>Code of the border touched by Ego:
        <literal>
         0 - Touched nothing
         1 - Top edge of the screen or the horizon
         2 - Right edge of the screen
         3 - Bottom edge of the screen
         4 - Left edge of the screen
        </literal>
       </entry>
      </row>

      <row>
       <entry>3</entry>
       <entry>Current score.</entry>
      </row>

      <row>
       <entry>4</entry>
       <entry>
         Number of object, other than Ego, that touched the border
       </entry>
      </row>

      <row>
       <entry>5</entry>
       <entry>The code of border touched by the object in Var (4)</entry>
      </row>

      <row>
       <entry>6</entry>
       <entry>
         Direction of Ego's motion
         <literal>
                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - the object
                    / | \                is motionless
                  /   |   \
                6     |     4
                      5
         </literal>
       </entry>
      </row>

      <row>
       <entry>7</entry>
       <entry>Maximum score</entry>
      </row>

      <row>
       <entry>8</entry>
       <entry>
         Number of free 256-byte pages of the interpreter's memory
       </entry>
      </row>

      <row>
       <entry>9</entry>
       <entry>
         If == 0, it is the number of the word in the user message that was
         not found in the dictionary<footnote><para>I would assume they mean
         "if != 0", but that's what they say. (VB)</para></footnote>
       </entry>
      </row>

      <row>
       <entry>10</entry>
       <entry>
         Time delay between interpreter cycles in 1/20 second intervals.
       </entry>
      </row>

      <row>
       <entry>11</entry>
       <entry>Seconds (interpreter's internal clock)</entry>
      </row>

      <row>
       <entry>12</entry>
       <entry>Minutes (interpreter's internal clock)</entry>
      </row>

      <row>
       <entry>13</entry>
       <entry>Hours (interpreter's internal clock)</entry>
      </row>

      <row>
       <entry>14</entry>
       <entry>Days (interpreter's internal clock)</entry>
      </row>

      <row>
       <entry>15</entry>
       <entry>Joystick sensitivity (if Flag (8) == 1)</entry>
      </row>

      <row>
       <entry>16</entry>
       <entry>ID number of the view-resource associated with Ego.</entry>
      </row>

      <row>
       <entry>17</entry>
       <entry>
         Interpreter error code (if == 0)<footnote><para>Again I would expect
         this to say ``if != 0''. (VB)</para></footnote>
       </entry>
      </row>

      <row>
       <entry>18</entry>
       <entry>Additional information that goes with the error code</entry>
      </row>

      <row>
       <entry>19</entry>
       <entry>Key pressed on the keyboard</entry>
      </row>

      <row>
       <entry>20</entry>
       <entry>Computer type. For IBM-PC it is always 0.</entry>
      </row>

      <row>
       <entry>21</entry>
       <entry>
         If Flag (15) == 0 (command reset 15 was issued) and Var (21) is
         not equal to 0, the window is automatically closed after 1/2 * Var
         (21) seconds.
       </entry>
      </row>

      <row>
       <entry>22</entry>
       <entry>Sound generator type: 1 - PC, 3 - Tandy</entry>
      </row>

      <row>
       <entry>23</entry>
       <entry>0:F - sound volume (for Tandy).</entry>
      </row>

      <row>
       <entry>24</entry>
       <entry>
         This variable stores the maximum number that can be entered
         in the input line. By default, this variable is set to 41 (29h).
         (information by Dark Minister)
       </entry>
      </row>

      <row>
       <entry>25</entry>
       <entry>
         ID number of the member selected using status command or
         0xFF if ESC was pressed.
       </entry>
      </row>

      <row>
       <entry>26</entry>
       <entry>Monitor type: 0 - CGA, 2 - HCG, 3 - EGA</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
</para>
</sect1>

<sect1 id="flaglist"><title>Flags used by the interpreter</title>
<para>
   On the interpreter startup all flags are set to 0.
</para><para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row> <entry>Flag</entry> <entry>Description</entry> </row>
     </thead>
     <tbody>
      <row>
       <entry>0</entry>
       <entry>
         Ego base line is completely on pixels with priority = 3 (water
         surface)
       </entry>
      </row>

      <row>
       <entry>1</entry>
       <entry>
         Ego is invisible of the screen (completely obscured by another
         object)
       </entry>
      </row>

      <row>
       <entry>2</entry>
       <entry>the player has issued a command line</entry>
      </row>

      <row>
       <entry>3</entry>
       <entry>
         Ego base line has touched a pixel with priority 2 (signal)
       </entry>
      </row>

      <row>
       <entry>4</entry>
       <entry><function/said/ command has accepted the user input</entry>
      </row>

      <row>
       <entry>5</entry>
       <entry>The new room is executed for the first time</entry>
      </row>

      <row>
       <entry>6</entry>
       <entry><function/restart_game/ command has been executed</entry>
      </row>

      <row>
       <entry>7</entry>
       <entry>If set, writing to the script buffer is blocked</entry>
      </row>

      <row>
       <entry>8</entry>
       <entry>If set, Var(15) determines the joystick sensitivity.</entry>
      </row>

      <row>
       <entry>9</entry>
       <entry>Sound on/off</entry>
      </row>

      <row>
       <entry>10</entry>
       <entry>If set, turns on the built-in debugger</entry>
      </row>

      <row>
       <entry>11</entry>
       <entry>Logic 0 is executed for the first time</entry>
      </row>

      <row>
       <entry>12</entry>
       <entry><function/restore_game/ command has been executed.</entry>
      </row>

      <row>
       <entry>13</entry>
       <entry>
         If set, allows the <function/status/ command to select members
       </entry>
      </row>

      <row>
       <entry>14</entry>
       <entry>If set, allows the menu to work</entry>
      </row>

      <row>
       <entry>15</entry>
       <entry>
         Determines the output mode of <function/print/ and <function/print_at/
         commands; if set, the message window is left on the screen, otherwise
         the message window is closed when <keycap/ENTER/ or <keycap/ESC/
         are pressed. If Var(21) is not set, the window is closed
         automatically after 1/2 * Var(21) seconds
       </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
</para>
</sect1>

<sect1 id="memory"><title>Memory organization</title>
<para>

   The following information gives a rough guide as to how Sierra's AGI
   interpreter uses its memory. You can view this in operation in MS-DOS
   by using a memory resident program like Game Wizard.
</para><para>
   <informaltable>
    <tgroup cols="2">
     <thead> 
      <row>
       <entry>Size (bytes)</entry>
       <entry>Description</entry>
      </row>
     </thead> 
     <tbody>
      <row>
       <entry>2</entry>
       <entry>Length of first data area</entry>
      </row>
      <row>
       <entry>2</entry>
       <entry>Game signature</entry>
      </row>
      <row>
       <entry>256</entry>
       <entry>Variables</entry>
      </row>
      <row>
       <entry>32</entry>
       <entry>Flags (256 bits)</entry>
      </row>
      <row>
       <entry></entry>
       <entry>Timers, blocks, and other special AGI variables</entry>
      </row>
      <row>
       <entry>12*40 or 24*40</entry>
       <entry>Strings</entry>
      </row>
      <row>
       <entry></entry>
       <entry>unknown</entry>
      </row>
      <row>
       <entry></entry>
       <entry>"Press ENTER to quit", etc</entry>
      </row>
      <row>
       <entry></entry>
       <entry>Script command jump table</entry>
      </row>
      <row>
       <entry></entry>
       <entry>"Avis Durgan" encryption string</entry>
      </row>
      <row>
       <entry></entry>
       <entry>Rest of <filename/agidata.ovl/
      </row>
      <row>
       <entry></entry>
       <entry>unknown</entry>
      </row>
      <row>
       <entry></entry>
       <entry><filename/words.tok/ file</entry>
      </row>
      <row>
       <entry></entry>
       <entry>object file</entry>
      </row>
      <row>
       <entry></entry>
       <entry>view object table</entry>
      </row>
      <row>
       <entry></entry>
       <entry><filename/logic.0/</entry>
      </row>
      <row>
       <entry></entry>
       <entry>Other loaded resources</entry>
     </tbody>
    </tgroup>
   </informaltable>

</para>
</sect1>

<sect1 id="gameid"><title>Game IDs and loaders</title>
<para>

   Since the data formats for the different AGI interpreter versions are
   mostly identical or easily convertible to each other, we should expect
   to be able to run one games data with anothers interpreter. This
   sounds like a reasonable assumption but when you try it, the
   interpreter rejects the new data. The reason behind this is
   <emphasis>game IDs</emphasis>.
</para><para>
   Every interpreter has got a game ID coded into it and it expects to be
   given data for that game. Somewhere in the initialization code for
   each game is a <function/set.game.id/. When this command is encountered, the
   interpreter checks the given game ID and compares it with its own. If
   they are not the same, it quits immediately. Presumably the reason for
   this was to stop people running games with the wrong interpter
   version, which can cause problems (unless you know what you're doing).
</para>

<sect2><title>How do we get around it?</title>
<para>
   <emphasis>Method 1: The hard way.</emphasis>
</para><para>
   Well, basically we have to find the game ID signature in the AGI
   interpreter file and change it to the ID of the game whose data we
   wish to be executed.
</para><para>
   Here are a few examples of some game ID's and the data following them:

   <simplelist>
    <member>Police Quest: <literal/'P' 'Q' 0x00 'e' 'I' 'D' 'X'/
    <member>Mother Goose: <literal/'M' 'G' 0x00 'e' 'I' 'D' 'X'/
    <member>Manhunter 2: <literal/'M' 'H' '2' 0x00 'I' 'D' 'X'/
    <member>XMAS Demo: <literal/'X' 'M' 'A' 'S' 0x00 'D' 'X'/
    <member>Leisure Suit Larry: <literal/'L' 'L' 'L' 'L' 'L' 0x00 'X'/
   </simplelist>
</para><para>
   The game ID itself is the null terminated string that ends at the 00h.
   The text that follows it is of no significance, it is simply to fill
   in the gap although it is useful when searching for the game ID
   because, as you can see, this text is always <literal/"eIDX"/> (presubably
   from ``gameIDX'' before being overwritten by the actual ID) or a suffix
   of it (i.e. <literal/"IDX"/, <literal/"DX"/, or <literal/"X"/).
   For most games, the game ID is two or three characters which means
   that you will be able to rely on the <literal/"IDX"/ string being
   there for these games.
</para><para>
   <emphasis>Method 2: The easy way</emphasis>
</para><para>
   Using the above method will allow you to run a different game with an
   interpreter, but you will still only be able to run the game that has
   the specified game ID. There is another way around this, which
   involves patching the logic source. This can be accomplished using
   a program to edit the logics such as AGI Studio (for the Windows platform).
   What you can usually do is look at the top part of logic 0 and find
   out what the initialization logic is (usually around 90--100 -- you
   might have to look at a few logics before you find it).  Then simply
   go to that logic, find the <function/set.game.id/ command, remove it,
   and recompile the logic. Since the command is not used, the
   interpreter will not try and compare it with it's own ID, and it won't
   quit.
</para><para>
   The only drawback to using this method is that the saved games no
   longer have the game ID in their name (so, for example, a savegame
   would be called <filename/sg.1/ instead of <filename/kq2sg.1/),
   but this is not a major hassle.
</para>

<sect2><title>Why can't I find the game ID?</title>
<para>
   This is because a lot of the AGI files themselves are encrypted.
   See <xref linkend="crypt"> for further information.
</para>

<sect2><title>Possibilities</title>
<para>
   What this means is that with a few useful AGI utility programs, it is
   possible to run any set of game data with a compatible AGI
   interpreter. For example, games that use AGI versions 2.915, 2.917,
   and 2.936 should be able to be converted into AGIv3 format and run
   with an AGIv3 interpreter.
</para><para>
   ``Compatible'' as it is used above refers not only to the data
   differences but also to some AGI command descrepencies. There are
   about four AGI commands that have changed the number of arguments
   passed to them as the interpreter developed. This sort of thing is the
   only real obstacle to running data on another interpreter.
</para>
</sect1>

<sect1 id="crypt"><title>Encrypted AGI data</title>

<para>
   Many AGI files are encrypted. This
   was probably to give some protection to their product which was quite
   unique at the time. You can tell the difference between an encrypted
   AGI file and a non-encrypted AGI file by the first two characters. If
   they are ``MZ'' (the MS-DOS executable file header), then it not encrypted.
</para><para>
   The AGI file is decrypted by the loader program. This is usually
   called <filename/sierra.com/ in MS-DOS but can also be named after the game
   (eg. <filename/kq1.com/). In AGI version 1, the loader was called
   <filename/load/.
   If an AGI game doesn't have a loader, then it shouldn't be encrypted.
   If an AGI game does have a loader, it does not necessarily mean that
   the AGI file is encrypted.
</para><para>
   The decryption key was not originally embedded in the loader file. If
   you find a game where the key is embedded in the loader, it is because
   that game has had copy protection removed. There are several utilities
   to do that. Anders M. Olsson's <emphasis>SUP</emphasis> is one of them.
   The CD re-releases have been unprotected by Sierra in exactly the same
   fashion.
</para><para>
   The loader would read the decryption key from track 6 of the disk,
   load the executable file, decrypt and run it. Track 6 had a special
   format that was supposedly impossible to exactly reproduce by a
   standard PC floppy disk controller.
</para><para>
   An interesting note is that when a copy-protected Sierra game asked
   for the original disk one, you could insert disk one from
   <emphasis>any</emphasis> protected Sierra game. The contents of
   track 6 were always the same.
</para><para>
   But even though track 6 was the same, all games didn't use exactly the
   same encryption key. The two bytes in the loader, immediately
   following the string <literal/"keyOfs"/, gave an offset on track 6
   from where the key would be loaded.
</para><para>
   So, if the decryption string consists of 128 `k' characters, it can
   actually mean one of two things: Either the AGI file is not encrypted,
   or the game is still copy-protected.
</para>

<sect2><title>How does the encryption work?</title>
<para>
   The loader contains a 128 byte string called the decryption key.
   Here's the process of decryption:
   <orderedlist>
    <listitem><para>
      The carry bit is zeroed.
    </para></listitem>
    <listitem><para>
      The first 128 bytes of the AGI file are XORed with the decryption key.
    </para></listitem>
    <listitem><para>
      The whole key string is rotated one bit to the right, including
      the carry-bit. (Bit 7 of the first byte is loaded from the carry.
    </para></listitem>
    <listitem><para>
      Bit 0 of the last byte is placed in the carry, where it will
      remain until the next rotation.
    </para></listitem>
    <listitem><para>
      The bit that was bit 0 of the last byte (now in carry) is ORed
      into bit 7 of the first byte.
    </para></listitem>
    <listitem><para>
      The next 128 bytes of the AGI file are XORed with the new key. If
      the end of the AGI file has not been reached, then go back to 3.
    </para></listitem>
   </orderedlist>
</para>

<sect2><title>Where in the loader is the decryption key?</title>
<para>
   The start of a loader will look something like this:
</para><para>
<programlisting>
LOADER v3.0 (c) Copyright Sierra On-Line, Inc. 1987 keyOfs
</programlisting>
</para><para>
   There are two bytes in between the <literal/"keyOfs"/ string and the start of
   the description string. If the decryption key consists of 128 `k'
   characters, then the AGI file is not encrypted (or the game is still
   copy-protected). If it consists of a whole lot of random looking
   characters, then it is encrypted.
</para><para>
   As an aside, the decryption string is followed immediately by the
   stack and is usually marked with a whole string of `s' characters.
   Thus we have `k' for key and `s' for stack. The stack is usually 256
   bytes long.
</para>

<sect2><title>Decrypting the AGI file</title>
<para>
   Decrypting the AGI file is simply a matter of writing a program to
   read the loader to get the decryption string, and then applying the
   process mentioned above to the AGI file. Once this has been done, the
   game ID can be located.
</para>
</sect1>

<sect1 id="parsing"><title>Player input parsing</title>
<para>
From the AGDS documentation, translated by Vassili Bykov.
</para><para>
   Note: This section is an excerpt from the description of the
   <function/said/ command from <xref linkend="cmdref">.
</para><para>
   Here is how the input is matched. After the player types a message and
   presses <keycap/ENTER/, the input line is processed by the interpreter in
   the following way:
   <orderedlist>
    <listitem><para>
      The interpreter removes all punctuation marks.
    </para></listitem>
    <listitem><para>
      All characters are converted to lowercase.
    </para></listitem>
    <listitem><para>
      All sequences of more than one space are replaced with a single
      space.
    </para></listitem>
    <listitem><para>
       Starting with the first word of the input, the interpreter looks
       up the vocabulary, trying to find the longest character sequence
       matching the input line.
    </para></listitem>
   </orderedlist>
</para><para>
   If the search is unsuccessful, <parameter/v9/ is assigned the number
   of the word in the message that failed to match and the processing
   ends. If all the words have been assigned some codes:
</para><para>
   <simplelist>
    <member>The Interpreter removes from the sequence of codes all zeros (that
       means all vocabulary words with zero codes are ignored).
    <member><literal/f2/ (the user has entered an input line) is set to 1
    <member><literal/f4/ (<function/said/ command accepted the user input) is set to 0.
   </simplelist>
</para><para>
   If the sequence of code produced by the interpreter is
</para><para>
   <quote>
   V(1), V(2),...V(m)
   </quote>
</para><para>
   The test is performed as follows:
</para><para>
   <quote>
   If <literal/f2/ == 0 or <literal/f4/ == 1, return FALSE.
   </quote>
</para><para>
   Compare parameters W(i) and codes V(i) as follows:
   <simplelist>
    <member>if W(i) = 1, it matches any V(i);
    <member>if W(i) = 9999, it matches the whole remaining input i.e. the
       codes V(i), V(i+1),...V(m).
   </simplelist>
</para><para>
   Otherwise W(i) should be equal to V(i).
</para><para>
   If all elements match, <literal/f4/ (<function/said/ accepted the
   user input) is set to 1 and the command returns TRUE. Otherwise,
   FALSE is returned.
</para>
</sect1>

<sect1 id="verctrl"><title>AGI interpreter versions</title>
<para>
</para>

<sect2><title>Sorted by Game</title>
<para>
<programlisting>
Game	Ver.	Int	Int. Ver.	Date
------- ------- ------- --------------- ---------
AGID	?.?	AGI	2.915		??/??/??
BC	2.00	AGI	2.439		06/14/87
BC	2.10	AGI	3.002.098	11/10/88
GR	2.01	AGI	3.002.149	12/22/88
KQ1	1.0U	AGI	2.272		Unknown
KQ1	2.0F	AGI	2.425		??/??/87
KQ1	2.0F	AGI	2.917		Unknown
KQ2	2.1	AGI	2.411		Unknown
KQ2	2.2	AGI	2.426		Unknown
KQ2	2.2	AGI	2.917		??/??/87
KQ3	1.01	AGI	2.272		11/08/86
KQ3	2.00	AGI	2.435		05/25/87
KQ3	2.14	AGI	2.936		03/15/88
KQ4	2.0	AGI	3.002.086	07/27/88
KQ4D	?.??	AGI	3.002.102	??/??/??
LSL1	1.00	AGI	2.440		06/01/87
LSL1	1.0	AGI	2.917		06/01/87
MG	?.??	AGI	2.915		Unknown
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
PQ1	2.0G	AGI	2.917		12/03/87
SQ1	1.0X	AGI	2.089		Unknown
SQ1	2.2	AGI	2.426		??/??/??
SQ1	2.2	AGI	2.917		??/??/??
SQ1	2.2	AGI	2.917		??/??/87
SQ2	2.0C	AGI	2.915		??/??/87
SQ2	2.0C	AGI	2.917		Unknown
SQ2	2.0D	AGI	2.936		Unknown
SQ2	2.0F	AGI	2.936		Unknown
XM86	?.??	AGI	2.272		Unknown
</programlisting>
</para>

<sect2><title>Sorted by Int. Ver.</title>
<para>
<programlisting>
Game	Ver.	Int	Int. Ver.	Date
------- ------- ------- --------------- ---------
SQ1	1.0X	AGI	2.089		Unknown
KQ1	1.0U	AGI	2.272		Unknown
KQ3	1.01	AGI	2.272		11/08/86
XM86	?.??	AGI	2.272		Unknown
KQ2	2.1	AGI	2.411		Unknown
KQ1	2.0F	AGI	2.425		??/??/87
KQ2	2.2	AGI	2.426		Unknown
SQ1	2.2	AGI	2.426		??/??/??
KQ3	2.00	AGI	2.435		05/25/87
BC	2.00	AGI	2.439		06/14/87
LSL1	1.00	AGI	2.440		06/01/87
AGID	?.?	AGI	2.915		??/??/??
MG	?.??	AGI	2.915		Unknown
SQ2	2.0C	AGI	2.915		??/??/87
KQ1	2.0F	AGI	2.917		Unknown
KQ2	2.2	AGI	2.917		??/??/87
LSL1	1.0	AGI	2.917		06/01/87
PQ1	2.0G	AGI	2.917		12/03/87
SQ1	2.2	AGI	2.917		??/??/??
SQ1	2.2	AGI	2.917		??/??/87
SQ2	2.0C	AGI	2.917		Unknown
KQ3	2.14	AGI	2.936		03/15/88
SQ2	2.0D	AGI	2.936		Unknown
SQ2	2.0F	AGI	2.936		Unknown
KQ4	2.0	AGI	3.002.086	07/27/88
BC	2.10	AGI	3.002.098	11/10/88
KQ4D	?.??	AGI	3.002.102	??/??/??
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
GR	2.01	AGI	3.002.149	12/22/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
</programlisting>
</para>

</sect1>

<sect1 id="verdif"><title>Version differences</title>
<para>

   There are a number of different versions of the AGI interpeter but
   generally the data formats are the same or can easy be converted
   between each other. The following table is a list of AGI interpreter
   versions that I know of:
</para><para>
<programlisting>
     AGI       Interp.  Agidata   Num of   Object file  LZW
   version       size     size    commands   encrypted
   ---------- -------- -------- ---------- ------------ ----
   2.089	34305	  6656	   155		No	No
   2.272	34816	  6656	   161		No	No
   2.411	38400  	  7680	   169		Yes	No
   2.435	38400	  7680	   169		Yes	No
   2.439	38400	  7680	   169		Yes	No
   2.440	38400	  7680	   169		Yes	No
   2.915	39424	  8192	   173		Yes	No
   2.917	39424	  8192	   173		Yes	No
   2.936	39424	  8192	   175		Yes	No
   3.002.086	40866	  8064	   177		Yes	Yes
   3.002.098	40898	  8080	   181		Yes	Yes
   3.002.102	40898	  8080	   181		Yes	Yes
   3.002.107	40962	  8080	   181		Yes	Yes
   3.002.149	40520	  7488	   181		Yes	Yes
</programlisting>
</para><para>
   This table illustrates a number of things:
   <itemizedlist>
    <listitem><para>
      Firstly, as the interpreter version increased, the number of AGI
      commands supported increased with it. The last eleven we do not
      know the names of.
    </para></listitem>

    <listitem><para>
      There are two main AGI versions: AGI v2 and AGI v3.
    </para></listitem>

    <listitem><para>
      The early AGI v2 games did not encrypt the <filename/object/ file
      with the ``Avis Durgan'' string.
    </para></listitem>

    <listitem><para>
      AGI v3 games use adaptive LZW to compress their LOGIC, VIEW, and
      SOUND files.
    </para></listitem>
   </itemizedlist>
</para>

<sect2><title>Command argument number descrepancies</title>
<para>
   There are four commands that have changed the number of arguments that
   are passed to them. All this information is based on observations made
   of the above interpreter versions.
   <itemizedlist>
    <listitem><para>
      The <function/quit/ command had no arguments for version
      2.089 whereas all the others above have one argument.
    </para></listitem>

    <listitem><para>
      The <function/print.at/ and <function/print.at.v/ commands had only three
      arguments for versions 2.089--2.400 and four for the other versions.
    </para></listitem>

    <listitem><para>
      Unknown command number 176 had one argument for version
      3.002.086 but later versions had no arguments for this command.
    </para></listitem>
   </itemizedlist>
</para>

<sect2><title>Number of strings</title>
<para>
   There may be some differences in the number of strings supported by
   some interpreters as well. All interpreters have at least 12 strings.
   Most interpreters have space for 24 strings but I don't know if the
   extra space is used for strings or not.
</para>
</sect1>

</chapter>


<chapter id="logic"><title>The LOGIC language</title>
<sect1 id="syntax"><title>LOGIC syntax</title>
<para>

   This is the ``official'' LOGIC syntax that has been decided on. It is
   not the same syntax as Sierra used. All LOGIC decoders and compilers
   should comply with this syntax, so that programmers can be sure that
   code they produce can be used properly with any program.
</para>

<sect2><title>Action Commands</title>
<para>

   Normal action commands are specified by the command name followed by
   brackets which contain the arguments, separated by commas. A semicolon
   is placed after the brackets. The brackets are required even if there
   are no arguments. The arguments given must have the correct prefix for
   that type of argument as explained later in this document (this is to
   make sure the programmer does not use a var, for example, when they
   think they are using a flag).

</para><para>
<programlisting>
assign.v(v50,0);
program.control();
</programlisting>
</para><para>
   Multiple commands may be placed on the one line:

</para><para>
<programlisting>
reset(f6); reset(f7);
</programlisting>
</para><para>
   Substitutions for the following action commands are available:

</para><para>
<programlisting>
increment(v30);       v30++;
decrement(v30);       v30--;
assignn(v30,4);       v30 = 4;
assignv(v30,v32);     v30 = v32;
addn(v30,4);          v30 = v30 + 4; or v30 += 4;
addv(v30,v32);        v30 = v30 + v32; or v30 += v32;
subn(v30,4);          v30 = v30 - 4; or v30 -= 4;
subv(v30,v32);        v30 = v30 - v32; or v30 -= v32;
mul.n(v30,4);         v30 = v30 * 4; or v30 *= 4;
mul.v(v30,v32);       v30 = v30 * v32; or v30 *= v32;
div.n(v30,4);         v30 = v30 / 4; or v30 /= 4;
div.v(v30,v32);       v30 = v30 / v32; or v30 /= v32;
lindirectn(v30,4);    *v30 = 4;
lindirectv(v30,v32);  *v30 = v32;
rindirect(v30,v32);   v30 = *v32;
</programlisting>
</para>

<sect2><title><literal/if/ structures and test commands</title>

<para>
   An <literal/if/ structure looks like this:
</para><para>
<programlisting>
if (&lt;test commands&gt;) {
    &lt;action commands&gt;
}
</programlisting>
</para><para>
   or like this :
</para><para>
<programlisting>
if (&lt;test commands&gt;) {
    &lt;action commands&gt;
}
else {
    &lt;more action commands&gt;
}
</programlisting>
</para><para>
   Carriage returns are not necessary:
</para><para>
<programlisting>
if (&lt;test commands&gt;) { &lt;action commands&gt; } else { &lt;more action commands&gt; }
</programlisting>
</para><para>
   Test commands are coded like action commands except there is no
   semicolon. They are separated by &amp&amp or || for AND or OR.
</para><para>
<programlisting>
if (isset(f5) &&
    greatern(v5,6)) { ......
</programlisting>
</para><para>
   Again, carriage returns are not necessary within the if statement:
</para><para>
<programlisting>
if (lessn(v5,6) && (greatern(v5,2)) { .......

if (isset(f90) && equalv(v32,v34)
    && greatern(v34,20)) { .......
</programlisting>
</para><para>
   A ! placed in front of a command signifies a NOT.
</para><para>
<programlisting>
if (!isset(f7)) {
  ......
</programlisting>
</para><para>
   Boolean expressions are not necessarily simplified so they must follow
   the rules set down by the file format. If test commands are to be
   ORred together, they must be placed in brackets.
</para><para>
<programlisting>
if ((isset(f1) || isset(f2)) {
  ......

if (isset(f1) && (isset(f2) || isset(f3))) {
  ......

if (isset(1) || (isset(2) && isset(3))) {    is NOT legal
</programlisting>
</para><para>
   Depending on the compiler, simplification of boolean expressions may
   be supported, so the above may not apply in all cases (although if
   these are rules are followed then the logic will work with all
   compilers).
</para><para>
   Substitutions for the following test commands are available:
</para><para>
<programlisting>
equaln(v30,4)         v30 == 4
equalv(v30,v32)       v30 == v32
greatern(v30,4)       v30 > 4
greaterv(v30,v32)     v30 > v32
lessn(v30,4)          v30 < 4
lessv(v30,v32)        v30 < v32
!equaln(v30,4)        v30 != 4
!equalv(v30,v32)      v30 != v32
!greatern(v30,4)      v30 <= 4
!greaterv(v30,v32)    v30 <= v32
!lessn(v30,4)         v30 >= 4
!lessv(v30,v32)       v30 >= v32
</programlisting>
</para><para>
   Also, flags can be tested for by just using the name of the flag:
</para><para>
<programlisting>
if (f6) { .....

if (v7 > 0 && !f6) { .....
</programlisting>
</para>

<sect2><title>Argument types</title>
<para>
   There are 9 different types of arguments that commands use:

   <simplelist>
    <member>Number (no prefix)
    <member>Var (prefix ``v'')
    <member>Flag (prefix ``f'')
    <member>Message (prefix ``m'')
    <member>Object (prefix ``o'')
    <member>Inventory Item (prefix ``i'')
    <member>String (prefix ``s'')
    <member>Word (prefix ``w'')
    <member>Controller (prefix ``c'')
   </simplelist>
</para><para>
   The <function/said/ test command uses its own special arguments
   which will be described later.
</para><para>
   Each of these types of arguments is given by the prefix and then a
   number from 0--255, e.g. v5, f6, m27, o2.
</para><para>
   The word type is words that the player has typed in, not words that
   are stored in the <literal/words.tok/ file. Strings are the temporary string
   variables stored in memory, not to be confused with messages (that are
   stored in the LOGIC resources). Controllers are menu members and keys.
</para><para>
   Compilers can enforce type checking, so that the programmer must use
   the correct prefix for an argument so that they know they are using
   the right type. Decoders should display arguments with the right type.
</para><para>
<programlisting>
move.obj(so4,80,120,2,f66);
if (obj.in.box(so2,30,60,120,40)) { .....
</programlisting>
</para><para>
   A complete list of the commands and their argument types is available
   as part of AGI Specs.
</para><para>
   Messages and inventory members may be given in either numerical text
   format:
</para><para>
<programlisting>
print("He's not here.");
print(m12);
if (has("Jetpack")) { .....
if (has(io9)) { .....
</programlisting>
</para><para>
   Messages can also be split over multiple lines:
</para><para>
<programlisting>
print("This message is split "
      "over multiple lines.");
</programlisting>
</para><para>
   Quote marks must be used around messages and object names. This is
   important because some messages or object names may contain brackets
   or commas, which could confuse the compiler. This is also the case for
   the <literal/said/ command which will be described shortly.
</para><para>
<programlisting>
if (has("Buckazoid(s)")) { .....        // no ambiguity here about where
                                        // the argument ends
</programlisting>

</para><para>
   The <literal/said/ test command uses different parameters to all the other
   commands. Where as the others use 8 bit arguments (0--255), <literal/said/ takes
   16 bit arguments (0--65535). Also, the number of arguments in a <literal/said/
   command can vary. The numbers given in the arguments are the word
   group numbers from the <literal/words.tok/ file.
</para><para>

<programlisting>
if (said(4,80)) { .....
</programlisting>
</para><para>
   Words can also be given in place of the numbers:
</para><para>
<programlisting>
if (said("look")) { .....
if (said("open","door")) { .....
</programlisting>
</para><para>
   Quote marks must also be used around the words.
</para>

<sect2><title>Labels and the goto command</title>
<para>
   Labels are given like this:

</para><para>
<programlisting>
Label1:
</programlisting>
</para><para>

   The label name can contain letters, numbers, and the characters "_"
   and ".". No spaces are allowed.

   The <literal/goto/ command takes one parameter, the name of a label.

</para><para>
<programlisting>
goto(Label1);
</programlisting>
</para>

<sect2><title>Comments</title>
<para>
   There are three ways that comments can be used.

</para><para>
<programlisting>
// Rest of line is ignored
[  Rest of line is ignored
/* Text between these are ignored */
</programlisting>
</para><para>

   The /*...*/ can be nested:

</para><para>
<programlisting>
/* comment start
  print("Hello");    // won't be run
  /*                 // a new comment start (will be ignored!)
    v32 = 15;        // won't be run
  */                 // uncomments the most inner comment
  print("Hey!");     // won't be run, still inside comments
*/                   // uncomments
</programlisting>
</para>

<sect2><title>Defines</title>
<para>
   To give vars, flags etc. proper names the <literal/#define/ command is used.
   The name of the define is given followed by the define value:

</para><para>
<programlisting>
#define ego o0
#define room_descr "This is a large hall with tall pillars down each side."
</programlisting>
</para><para>

   Then the define name can be used in place of the define value:

</para><para>
<programlisting>
draw(ego);
print(room_descr);
</programlisting>
</para><para>

   Define names can only be used in arguments of commands (including
   <function/goto/s and the <literal/v0 == 3/ type syntax), although
   some compilers may allow you to use them anywhere.
</para><para>
   Defines must be defined in the file before they are used.
   The define name can contain letters, numbers, and the characters
   <literal/'_'/ and <literal/./. No spaces are allowed.
</para>

<sect2><title>Including files</title>
<para>
   You can include another file in your logic source code by using the
   <literal/#include/ command:

</para><para>
<programlisting>
#include "file.txt"
</programlisting>
</para><para>

   When the compiler encounters the above line, it will replace it with
   the contents of <filename/file.txt/.

</para><para>
   It is a good idea to have all the defines that you need for multiple
   logics in an <literal/#include/ file, so if you need to change the
   define value you only have to do it once (although you will need to
   recompile all logics that use that define).
</para>

<sect2><title>More on messages</title>
<para>
   In some cases you may want to assign a specific number to a message so
   you can refer to it in other places. This is done by using the
   <literal/#message/ command, followed by the number of the message then the
   message itself:

<programlisting>
#message 4 "You can't do that now."
</programlisting>

   Then you can give the message number as the parameter in commands:

<programlisting>
print(m4);
</programlisting>

   Or embed the message in commands as normal and the number you assigned
   to it before will be used:

<programlisting>
print("You can't do that now.");
</programlisting>

   <literal/#message/ can be used anywhere in the file, so you do not
   have to set the message before you use it.
</para>

<sect2><title>The return command</title>
<para>
   The return command is just a normal action command (number 0), with no
   arguments. This must be the last command in every logic.
</para>

</sect1>

<sect1 id="cmdref"><title>Reference of the LOGIC commands</title>
<para>
From the AGDS documentation translated by Vassili Bykov,
</para>

<sect2><title>Arithmetic commands</title>
<para>
   Commands that operate on variables:
   <variablelist>
    <varlistentry>
      <term><function id="increment">increment(n)</function></term>
      <listitem><para>
       The value of the variable <parameter/n/ is incremented by one,
       i.e. <parameter/vn/ = <parameter/vn/+1. If the value is already
       255, it is left unchanged.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="decrement">decrement(n)</function></term>
      <listitem><para>
       The value of the variable <parameter/vn/ is decremented by one,
       i.e. <parameter/vn/ = <parameter/vn/-1. If the value is 0, it
       is left unchanged.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="assign">assign(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is assigned the value m, i.e.
       <parameter/vn/ = <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="assignv">assignv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is assigned the value of <parameter/vm/,
       i.e. <parameter/vn/ = <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="addn">addn(n,m)</function>, <function id="addv">addv(n,m)</function></term>
      <listitem><para>
       The value of variable <parameter/vn/ is incremented by <parameter/m/
       (<parameter/vm/), i.e. <parameter/vn/ = <parameter/vn/ + <parameter/m/
       (<parameter/vm/).
      </para><para>
       If the value is greater than 255 the result wraps over 0
       (so 250 + 10 == 4).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="subn">subn(n,m)</function>, <function id="subv">subv(n,m)</function></term>
      <listitem><para>
       The value of <parameter/vn/ is decremented by <parameter/m/
       (<parameter/vm/), i.e. <parameter/vn/ = <parameter/vn/ - <parameter/m/
       (<parameter/vm/).
       If the value is lesser than 0 the result wraps (so 1 - 2 == 255).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="lindirectn">lindirectn(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vi/ where <emphasis/i/ is the value of
       <parameter/vn/ is assigned a value <parameter/m/, i.e.
       Var(<parameter/vn/) = <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="lindirectv">lindirectv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vi/ where <emphasis/i/ is the value of
       <parameter/vn/ is assigned the value of <parameter/vm/, i.e.
       Var(<parameter/vn/) = <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="rindirect">rindirect(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is assigned the value of <parameter/vi/
       where <emphasis/i/ is the value of <parameter/vm/, i.e.
       <parameter/vn/ = Var(<parameter/vm/).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>muln(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is multiplied by <parameter/m/, i.e.
       <parameter/vn/ = <parameter/vn/ * <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>mulv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is multiplied by the value of <parameter/vm/,
       i.e. <parameter/vn/ = <parameter/vn/ * <parameter/vm/.
      </para><para>
       <emphasis>(What happens on overflow? --VB)</emphasis>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>divn(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is divided by <parameter/m/, i.e.
       <parameter/vn/ = <parameter/vn/ / <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>divv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is divided by the value of <parameter/vm/,
       i.e. <parameter/vn/ = <parameter/vn/ / <parameter/vm/.
      </para><para>
       <emphasis>(What happens on division by 0? --VB)</emphasis>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="random">random(n,m,k)</function></term>
      <listitem><para>
       Variable <parameter/vk/ is assigned a random value in the range
       between <parameter/n/ and <parameter/m/.
       Now let us consider the commands changing flag values. Remember that a
       flag can only have a value 0 or 1.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set">set(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/n/ is set to 1.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.v">set.v(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/i/, where <emphasis/i/ is the value of
       <parameter/vn/, is set to 1. i.e.  flag(<parameter/vn/) = 1.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="reset">reset(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/n/ is set to 0.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="reset.v">reset.v(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/i/, where <emphasis/i/ is the value of
       <parameter/vn/, is set to 0, i.e. flag(<parameter/vn/) = 0.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="toggle">toggle(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/n/ toggles its value.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="toggle.v">toggle.v(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/i/, where <emphasis/i/ is the value of
       <parameter/vn/, i.e. flag(<parameter/vn/), toggles is value.
      </para></listitem>
    </varlistentry>
   </variablelist>
</para>
</sect2>

<sect2><title>Commands to load and unload resources</title>
<para>
   Commands in this chapter load (into the interpreter's memory) and
   unload (discard, thus freeing interpreter's memory) LOGIC, PICTURE,
   VIEW, and SOUND resources. Always remember that the internal memory of
   the interpreter is 64K. This restriction is rarely a problem, but do
   not forget about it.
</para><para>
   When the internal memory is full, the program has to be broken into
   parts which are loaded and unloaded as the story unfolds in the given
   room, or PICTURE, VIEW, and SOUND resources have to be manipulated
   using the commands below.

</para><para>
   Remember that when a resource is unloaded, all resources loaded after
   it <emphasis>are also automatically unloaded</emphasis>!

   <variablelist>

    <varlistentry>
      <term><function id="load.logic">load.logic(n)</function></term>
      <listitem><para>
       Load into memory the logic resource number <parameter/n/, i.e. Logic(n)
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>load.logic.v(n)</function></term>
      <listitem><para>
       Load into memory the logic resource number <parameter/i/, where
       <parameter/i/ is the value of <parameter/vn/, i.e. Logic(<parameter/vn/)
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="load.pic">load.pic(n)</function></term>
      <listitem><para>
       Loads into memory the picture resource number <parameter/i/,
       where <parameter/i/ is the value of <parameter/vn/, i.e.
       Picture(<parameter/vn/).
       <footnote><para>This may be a mistake in the original: I would expect
       this command to be <function/load.pic.v/, while <function/load.pic(n)/
       would load resource number <parameter/n/. (VB)</para>
       <para><function/load.pic.v/ may be a more appropriate name
       for it, but the name above is what they gave it. There is no
       equivalent command that takes a number rather than a variable. (LE)
       </para></footnote>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="load.view">load.view(n)</function></term>
      <listitem><para>
       Loads into memory the view resource number <parameter/n/, i.e. View(n).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="load.view.v">load.view.v(n)</function></term>
      <listitem><para>
       Loads into memory the view resource number <parameter/i/,
       where <parameter/i/ is the value of <parameter/vn/, i.e.
       View(<parameter/vn/)
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="load.sound">load.sound(n)</function></term>
      <listitem><para>
       Loads into memory the sound resource number <parameter/n/,
       i.e. Sound(n).
       <footnote><para>Note that there is no <function/load.sound.v/ listed.
       I wonder if this is a mistake or there really is no way to load a
       sound with indirection (unlikely, I think) (VB)</para><para>
       There really is no way of loading a sound with indirection.
       The command doesn't exist. (LE)</para></footnote>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="discard.pic">discard.pic(n)</function></term>
      <listitem><para>
       Unload the picture resource number <parameter/i/, where
       <parameter/i/ is the value of <parameter/vn/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="discard.view">discard.view(n)</function></term>
      <listitem><para>
       Unload the view resource number <parameter/n/, i.e. View(<parameter/n/).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="discard.view.v">discard.view.v(n)</function></term>
      <listitem><para>
       Unload the view resource number <parameter/i/ where <parameter/i/
       is the value of <parameter/vn/, i.e. View(<parameter/vn/).
       <footnote><para>And what about <function/discard.logic/,
       <function/discard.logic.v/, <function/discard.sound/, and
       <function/discard.sound.v/? (VB)</para><para>
       There must be some other way that those commands are removed from
       memory, because the commands you mention above don't exist. (LE)
       </para></footnote>
      </para></listitem>
    </varlistentry>

   </variablelist>
</para>
</sect2>

<sect2><title>Program control commands</title>
<para>
   The <function/new.room/ command is one of the most powerful commands
   of the interpreter.
   It is used to change algorithms of the object behaviour, props, etc.
   Automatic change of Ego coordinates imitates moving into a room
   adjacent to the edge of the initial one.<footnote><para>Sounds awkward
   but that's what it says. (VB)</para></footnote>
</para><para>
   The format of the command is:

</para><para>
   <variablelist>
    <varlistentry>
      <term>
       <function id="new.room">new.room(n)</function>,
       <function id="new.room.v">new.room.v(n)</function>
      </term>

      <listitem><para>
        These commands do the following:
      </para><para>

        <orderedlist>
         <listitem><para>
          <function>stop.update</function>
          and <function/unanimate/ are issued to all objects;
         </para></listitem>
     
         <listitem><para>
          All resources except Logic(0) are discarded;
         </para></listitem>
     
         <listitem><para>
          Command <function>player.control</function> is issued;
         </para></listitem>
     
         <listitem><para>
          <function><ulink url="unblock"/unblock/</function> command is issued;
         </para></listitem>
     
         <listitem><para>
          <function/set.horizon(36)/ command is issued;
         </para></listitem>
     
         <listitem><para>
          <function/v1/ is assigned the value of <literal/v0/;
          <literal/v0/ is assigned <parameter/n/ (or the value of <parameter/vn/
          when the command is
          <literal><ulink url="new.room.v"/new.room.v/</literal>);
         </para></listitem>
     
         <listitem><para>
          <literal/v4/ is assigned 0;
         </para></listitem>
     
         <listitem><para>
          <literal/v5/ is assigned 0;
         </para></listitem>
     
         <listitem><para>
          <literal/v16/ is assigned the ID number of the VIEW resource that was
          associated with Ego (the player character).
         </para></listitem>
     
         <listitem><para>
          Logic(i) resource is loaded where <parameter/i/ is the value of
          <literal/v0/!
         </para></listitem>
     
         <listitem><para>
          Set Ego coordinates according to <literal/v2/:
            <simplelist>
             <member>if Ego touched the bottom edge, put it on the horizon;
             <member>if Ego touched the top edge, put it on the bottom edge
               of the screen;
             <member>if Ego touched the right edge, put it at the left and
               vice versa.
            </simplelist>
         </para></listitem>
     
         <listitem><para>
          <literal/v2/ is assigned 0 (meaning Ego has not touched any edges).
         </para></listitem>
     
         <listitem><para>
          <literal/f5/ is set to 1 (meaning in the first interpreter cycle after
          the new_room command all initialization parts of all logics loaded
          and called from the initialization part of the new room's logic
          will be called. In the subsequent cycle <literal/f5/ is reset to 0
          (see <xref linkend="workcycle"> and
          the source of the ``Thunderstorm''. This is very important!).
         </para></listitem>
     
         <listitem><para>
          Clear keyboard input buffer and return to the main AGI loop.
         </para></listitem>

        </orderedlist>

      </para></listitem>
    </varlistentry>

   </variablelist>
</para>
</sect2>

<sect2><title>Subroutine call commands</title>
<para>
   <variablelist>

    <varlistentry>
      <term><function id="call">call(n), call.v(n)</function></term>
      <listitem><para>
       LOGIC resource number <parameter/n/ (or number <parameter/i/
       where <parameter/i/ the value of <parameter/vn/) is executed as a
       subroutine.
       If the logic with the given ID is not loaded in memory, it is
       temporarily loaded and discarded after returning from the call
       (this takes extra time). <function>call</function>
       does not change any variables or flags.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="return">return</function></term>
      <listitem><para>
       This command returns control to the interpreter if it is executed in
       Logic(0), or to the command following the call command which called
       the current logic.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>jump &lt;label&gt;</function></term>
      <listitem><para>
       This command unconditionally transfers control to a command starting
       after label <literal/label/ within the same logic.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.scan.start">set.scan.start(),
      reset.scan.start()</function></term>
      <listitem><para>
       Normally, when a logic is called using call command, execution begins
       at the first instruction.
       The <function><ulink url="set.scan.start"/set.scan.start/</function>
       command sets the entry point at the command following it, while
       <function><ulink url="reset.scan.start"/reset.scan.start/</function>
       returns the entry point to the beginning.
      </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Object control commands</title>
<para>
   The interpreter controls the movement of objects in the screen
   automatically checking the following conditions:

</para><para>
   <orderedlist>
    <listitem><para>
      If an object priority is 0 it cannot cross an unconditional barrier
      (pixels with priority 0).
    </para></listitem>

    <listitem><para>
      If an object priority is 15 and a command <function/ignore.block/ has not
      been given to it, it cannot cross a conditional barrier (pixels with
      priority 1) and leave the block set using the
      <function>block</function> command.
    </para></listitem>

    <listitem><para>
      If an object has not been given the <function>ignore.horizon</function>
      command, it cannot move above the horizon set using the
      <function>set.horizon</function> command.
    </para></listitem>

    <listitem><para>
      An object should follow the conditions set using
      <function>object.on.water</function>
      and <function>object.on.land</function>
      commands (see below).
    </para></listitem>
   </orderedlist>

   Object number 0 is called Ego. It is different from others in that the
   player may move it around using the keyboard.
</para>

<sect3><title>Object description commands</title>
<para>
   <variablelist>
    <varlistentry>
      <term><function id="animate.obj">animate.obj(n)</function></term>
      <listitem><para>
       Object number <parameter/n/ is included in the list of object
       controlled by the interpreter. <emphasis>Objects not included in
       that list are considered inexistent!</emphasis>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="unanimate.all">unanimate.all()</function></term>
      <listitem><para>
       All objects are removed from the control list and are considered
       inexistent.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.view">set.view(n,m), set.view.v(n,m)</function></term>
      <listitem><para>
       Object <parameter/n/ is associated with a view resource number
       <parameter/m/ (or pointed to by <parameter/vm/), which may be an
       image of the object.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.loop">set.loop(n,m), set.loop.v(n,m)</function>
      <listitem><para>
       Chooses a loop <parameter/m/ (or <parameter/vm/) in the view
       resource associated with the object <parameter/n/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="fix.loop">fix.loop(n)</function></term>
      <listitem><para>
       Turns off automatic choice of loop number for the object number
       <parameter/n/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="release.loop">release.loop(n)</function></term>
      <listitem><para>
       Turns on automatic choice of loop number depending on the direction
       of motion of the object <parameter/n/.
      </para><para>
       <literal>
                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - object stands still
                    / | \
                  /   |   \
                6     |     4
                      5
       </literal>
      </para><para>
       For objects with fewer than 4 but more than 1 loop, automatic
       choice of the loop is done according to the following table:
      </para><para>

       <informaltable>
        <tgroup cols="10">
         <thead>
          <row>
           <entry>Direction</entry>
           <entry>0</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>3</entry>
           <entry>4</entry>
           <entry>5</entry>
           <entry>6</entry>
           <entry>7</entry>
           <entry>8</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry>Loop</entry>
           <entry>x</entry>
           <entry>x</entry>
           <entry>0</entry>
           <entry>0</entry>
           <entry>0</entry>
           <entry>x</entry>
           <entry>1</entry>
           <entry>1</entry>
           <entry>1</entry>
          </row>
         </tbody>
        </tgroup>
       </informaltable>

      </para><para>
       For objects with more than 4 loops, the following table is used:
      </para><para>

       <informaltable>
        <tgroup cols="10">
         <thead>
          <row>
           <entry>Direction</entry>
           <entry>0</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>3</entry>
           <entry>4</entry>
           <entry>5</entry>
           <entry>6</entry>
           <entry>7</entry>
           <entry>8</entry>
          </row>
         </thead>
         <tbody>
          <row>
           <entry>Loop</entry>
           <entry>x</entry>
           <entry>3</entry>
           <entry>0</entry>
           <entry>0</entry>
           <entry>0</entry>
           <entry>2</entry>
           <entry>1</entry>
           <entry>1</entry>
           <entry>1</entry>
          </row>
         </tbody>
        </tgroup>
       </informaltable>

      </para><para>
       <literal/x/ means that the current loop number is retained.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.cel">set.cel(n,m), set.cel.v(n,m)</function>
      </term>
      <listitem><para>
       Selects a cel <parameter/m/ in the current loop of the object
       <parameter/n/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="last.cel">last.cel(n,m)</function></term>
      <listitem><para>
       The number of the last cel of the current loop of the object
       <parameter/n/ is stored in <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="current.cel">current.cel(n,m)</function></term>
      <listitem><para>
       The number of the current cel of the object <parameter/n/ is
       stored in <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="current.loop">current.loop(n,m)</function></term>
      <listitem><para>
       The number of the current loop of the object <parameter/n/ is
       stored in <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="current.view">current.view(n,m)</function></term>
      <listitem><para>
       The number of the current view resource associated with the
       object <parameter/n/ is stored in <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.priority">set.priority(n,m), set.priority.v(n,m)</function></term>
      <listitem><para>
       Set priority of the view of the object <parameter/n/ to
       <parameter/m/ (or <parameter/vm/).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="release.priority">release.priority(n)</function></term>
      <listitem><para>
        Turns on the automatic priority choice for the object <parameter/n/.
        The priority is set depending on the vertical coordinate of the object.
        This way, as an object moves down it approaches the viewer.
        See <xref linkend="bands"> for a table of y coordinates and the
        associated priorities.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="get.priority">get.priority(n,m)</function><term>
      <listitem><para>
        The value of the current priority of the object <parameter/n/ is
        stored in <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="position">position(n,x,y), position.v(n,x,y)</function></term>
      <listitem><para>
        Coordinates of the object <parameter/n/, not yet displayed on the
        screen, are set to <parameter/x/ and <parameter/y/ (or <parameter/vx/
        and <parameter/vy/).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="draw">draw(n)</function></term>
      <listitem><para>
        Object <parameter/n/ is shown on the screen. The image uses the
        values of the loop and the cel in the VIEW resource associated with
        the object <parameter/n/ (see <function>set.view</function>),
        as well as the priority and coordinates of the object. If a command
        <function>start.cycling</function>
        is also issued, a looped animation for object <parameter/n/ is
        shown until stopped (for example, with
        <function>stop.cycling</function>).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="erase">erase(n)</function></term>
      <listitem><para>
        Object <parameter/n/ is erased from the screen.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="get.posn">get.posn(n,x,y)</function></term>
      <listitem><para>
        Coordinates of the object <parameter/n/ are stored in <parameter/vx/
        and <parameter/vy/. Coordinates of the object are coordinates of the
        base point (bottom left corner) of cels of the view resource
        associated with the object.
      </para></listitem>
    </varlistentry>
   </variablelist>
</para><para>

   The interpreter automatically plays the animation (a loop in the VIEW
   resource) associated with the object, starting at the specified cel.
   The following commands control this process.

</para><para>
   <variablelist>
    <varlistentry>
      <term><function id="start.cycling">start.cycling(n)</function></term>
      <listitem><para>
        Enables automatic change of cels in a chosen (using
        <function>set.loop</function>) loop of
        a view resource associated with the object <parameter/n/ (using
        <function>set.view</function>).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="stop.cycling">stop.cycling(n)</function></term>
      <listitem><para>
        Disables automatic change of cels in a chosen (using
        <function>set.loop</function>) loop of
        a view resource associated with the object <parameter/n/ (using
        <function>set.view</function>).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="normal.cycle">normal.cycle(n)</function></term>
      <listitem><para>
        Cels of the loop associated with the object <parameter/n/ follow in
        a normal order: 0, 1, 2, ..., <parameter/k/-1, 0, 1, 2, ...
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="reverse.cycle">reverse.cycle(n)</function></term>
      <listitem><para>
        Cels of the loop associated with the object <parameter/n/ follow
        a reverse order: <parameter/k/-1, <parameter/k/-2, ..., 1, 0,
        <parameter/k/-1, <parameter/k/-2, ..., 1, 0, ...
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="end.of.loop">end.of.loop(n,m)</function></term>
      <listitem><para>
        Plays the loop associated with the object <parameter/n/ once,
        from the current cel to the last. When finished, <parameter/fm/
        is set.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="reverse.loop">reverse.loop(n,m)</function></term>
      <listitem><para>
        Plays the loop associated with the object <parameter/n/ once
        in a reverse order, from the current cel to the first. When
        finished, <parameter/fm/ is set.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="cycle.time">cycle.time(n,m)</function></term>
      <listitem><para>
        <parameter/vm/ sets the time in interpreter cycles between cel
        changes for the object <parameter/n/. When <parameter/vm/ = 1
        cels are changed every cycle.
      </para></listitem>
    </varlistentry>

   </variablelist>
</para>

<sect3><title>Object motion control commands</title>
<para>
   The following commands can be given to the object included in the
   interpreter control list with <function>animate.obj</function>:

   <variablelist>

    <varlistentry>
     <term><function id="set.horizon">set.horizon(n)</function></term>
     <listitem><para>
       Set the horizon y coordinate to <parameter/n/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="ignore.horizon">ignore.horizon(n)</function></term>
     <listitem><para>
       Object <parameter/n/ moves regardless of the horizon position.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="observe.horizon">observe.horizon(n)</function></term>
     <listitem><para>
       Object <parameter/n/ cannot move above the horizon.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="block">block(x1,y1,x2,y2)</function></term>
     <listitem><para>
       Sets a rectangular area (block).
       <literal>
      (x1, y1)
         +----------------+
         |                |
         |                |
         |                |
         +----------------+
                       (x2, y2)
       </literal>
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="unblock">unblock()</function></term>
     <listitem><para>
       Cancels previously set block.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="ignore.blocks">ignore.blocks(n)</function></term>
     <listitem><para>
       Object <parameter/n/ moves ignoring conditional barriers
       (pixels with priority 1) and a block set with the
       <function>block</function> command.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="observe.blocks">observe.blocks(n)</function></term>
     <listitem><para>
       Object <parameter/n/ may not cross conditional barriers or
       leave the block.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="ignore.objs">ignore.objs(n)</function></term>
     <listitem><para>
       Object <parameter/n/ moves regardless of positions of other objects.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="observe.objs">observe.objs(n)</function></term>
     <listitem><para>
       Object <parameter/n/ treats other objects as obstacles.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="player.control">player.control()</function></term>
     <listitem><para>
       The player is allowed to control Ego (object number 0) using the
       keyboard or the joystick.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="program.control">program.control()</function></term>
     <listitem><para>
       The player is not allowed to control object 0 (Ego).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="stop.motion">stop.motion(n)</function></term>
     <listitem><para>
       Motion of object <parameter/n/ is stopped. If <parameter/n/ is 0,
       <function>program.control</function> is automatically executed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="start.motion">start.motion(n)</function></term>
     <listitem><para>
       Motion of object <parameter/n/ is started. If <parameter/n/ is 0
       (Ego), <function>player.control</function> is automatically executed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="step.size">step.size(n,m)</function></term>
     <listitem><para>
       <parameter/vn/ determines the number of pixels the object
       <parameter/n/ moves each step. The actual value in pixels is the
       step size / 4.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="step.time">step.time(n,m)</function></term>
     <listitem><para>
       <parameter/vn/ determines the speed of object <parameter/n/
       motion: delay in the interpreter cycles between consecutive steps.
       If <parameter/vm/ is 1, step occurs on every cycle.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="move.obj">move.obj(n,x,y,s,m), move.obj.v(n,x,y,s,m)</function></term>
     <listitem><para>
       Object <parameter/n/ is told to move to the point
       <parameter/(x,y)/ (or <parameter/vx/, <parameter/vy/)
       by <parameter/s/ pixels every step. When the destination
       is reached, <literal/f/<parameter/m/ is set to 1.
       If <parameter/n/ is 0 (Ego), <function>program.control</function>
       is executed automatically.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="follow.ego">follow.ego(n,s,m)</function></term>
     <listitem><para>
       Object <parameter/n/ is told to chase object 0 (Ego) by
       <parameter/s/ pixels every step. When Ego and object coordinates
       become equal, <literal/f/<parameter/m/ is set.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="wander">wander(n)</function></term>
     <listitem><para>
       Object <parameter/n/ randomly changes the direction of its
       motion (wanders). If <parameter/n/ is 0 (Ego),
       <function>program.control</function> is issued automatically.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="normal.motion">normal.motion(n)</function></term>
     <listitem><para>
       Special object motion mode is canceled. The object continues to move
       in the direction it was moving in at the time the command was issued.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="set.dir">set.dir(n,m)</function></term>
     <listitem><para>
       Object <parameter/n/ is told to move in the direction <parameter/vm/.
       <literal>
                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - stop
                    / | \
                  /   |   \
                6     |     4
                      5
       </literal>
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="get.dir">get.dir(n,m)</function></term>
     <listitem><para>
       Direction of object <parameter/n/ motion is stored in <parameter/vm/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="object.on.water">object.on.water(n)</function></term>
     <listitem><para>
       Object <parameter/n/ is allowed to be only in the area where its
       base line is completely on pixels with priority 3 (water surface).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="object.on.land">object.on.land(n)</function></term>
     <listitem><para>
       Object <parameter/n/ is not allowed to touch pixels of water
       surface (priority 3).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="object.on.anything">object.on.anything(n)</function></term>
     <listitem><para>
       Motion restrictions previously set on the object <parameter/n/
       with commands <function>object.on.water</function> or
       <function/object.on.land/ are cancelled.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="reposition">reposition(n,dx,dy)</function></term>
     <listitem><para>
       Object <parameter/n/ jumps from its current location into the
       location with coordinates (<parameter/x/ + <parameter/vdx/,
       <parameter/y/ + <parameter/vdy/).
       <footnote>
        <para>
         Shouldn't there be <function/reposition/ and <function/reposition.v/?
         (VB)
        </para><para>
         There should be, but they don't exist. (LE)
        <para>
       </footnote>
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="reposition.to">reposition.to(n,x,y), reposition.to.v(n,x,y)</function></term>
     <listitem><para>
       Similar to the preceding command, but the object is moved to the point
       <parameter/x/, <parameter/y/ (<parameter/vx/,<parameter/vy/).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="stop.update">stop.update(n)</function></term>
     <listitem><para>
       Object <parameter/n/ is removed from the list of objects updated by the
       interpreter on each step. The object stays on the screen unchanged.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="start.update">start.update(n)</function></term>
     <listitem><para>
       Object <parameter/n/ is redrawn on each interpreter step.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="force.update">force.update(n)</function></term>
     <listitem><para>
       Object <parameter/n/ is redrawn immediately, without waiting for
       the end of the interpreter cycle.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="distance">distance(n,m,d)</function></term>
     <listitem><para>
       If both objects <parameter/n/ and <parameter/m/ are on the screen,
       then <parameter/vd/ = abs(x(n) - x(m)) + abs(y(n) - y(m)),
       otherwise <parameter/vd/ = 255.
     </para></listitem>
    </varlistentry>

   </variablelist>
</para>

<sect3><title>Inventory member management commands</title>
<para>
   Object resources, stored in a separate file <filename/object/, are
   most often used to represent inventory members. An member is a
   structure which consists of a one-byte field called room and a
   string of text (the member name).
</para><para>
   If the room field of an member is 255, the member belongs to the player.
   Otherwise the member is considered to be in the room with the
   corresponding ID number.

</para><para>
   <variablelist>
    <varlistentry>
     <term><function id="get">get(n), get.v(n)</function></term>
     <listitem><para>
       Stores 255 in room field of an object <parameter/n/, which means that
       the player owns it.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="drop">drop(n)</function></term>
     <listitem><para>
       Stores 0 in the room field of object <parameter/n/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="put">put(n,m), put.v(n,m)</function></term>
     <listitem><para>
       Stores the value <parameter/m/ (or <parameter/vm/) in the room field
       of the object <parameter/n/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="get.room.v">get.room.v(n,m)</function></term>
     <listitem><para>
       Stores the value of the room field of object <parameter/vn/ in
       <parameter/vm/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="status">status()</function></term>
     <listitem><para>
       The screen is switched to text mode; the top line displays ``You are
       carrying:'', then the names of the object with room field equal to 255
       are listed. If there are no such objects, the word ``nothing'' is
       displayed.
     </para><para>
       If <parameter/f13/ is set (allow member selection), a highlight
       appears which allows the player to select an member name.
       When <keycap/ENTER/ is pressed, the selected object number is
       stored in <parameter/v25/. When <keycap/ESC/ is pressed, 255
       is stored in <parameter/v25/.
     </para></listitem>
    </varlistentry>

   </variablelist>
</para>

<sect2><title>Picture resource management commands</title>
<para>
   The following commands operate on PICTURE resources,
   prepared using PM editor and loaded in the interpreter memory using
   <function>load.pic</function>:

   <variablelist>
    <varlistentry>
     <term><function id="draw.pic">draw.pic(n)</function></term>
     <listitem><para>
       A picture resource number <parameter/i/, where <parameter/i/
       is the value of <parameter/vn/, is executed. As the result,
       the background picture is created in the internal buffer of
       the interpreter. Before execution, the buffer is cleared,
       i.e. all pixels are set to colour 15 and priority 4.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="overlay.pic">overlay.pic(n)</function></term>
     <listitem><para>
       Just like the above, only the internal buffer is not cleared before
       drawing. Picture(<parameter/vn/) is drawn over the existing picture.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="add.to.pic">add.to.pic(a,b,c,d,e,f,g), add.to.pic.v(a,b,c,d,e,f,g)</function></term>
     <listitem><para>
       The image of a view resource is added to the background as its
       component. Typically, this is used to add small complicated details
       which would require too many picture resource commands to draw.
     </para><para>
       Parameters are:
       <simplelist>
        <member><parameter/a/ (<parameter/va/): number of the view resource;
        <member><parameter/b/ (<parameter/vb/): loop number;
        <member><parameter/c/ (<parameter/vc/): cel number;
        <member><parameter/d/ (<parameter/vd/): x coordinate;
        <member><parameter/e/ (<parameter/ve/): y coordinate;
        <member><parameter/f/ (<parameter/vf/): priority;
        <member><parameter/g/ (<parameter/vg/): margin.
       </simplelist>
     </para><para>
       If margin is 0, 1, 2, or 3, the base of the cel is surrounded with a
       rectangle of the corresponding priority. If margin > 4, this extra
       margin is not shown.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="show.pic">show.pic()</function></term>
     <listitem><para>
       Shows internal buffer on the screen.
     </para><para>
       <emphasis>ATTENTION!</emphasis>
       Please use the following sequence of commands when loading picture
       resources in the interpreter memory:
     </para><para>

       <programlisting>
load.pic(n);
draw.pic(n);
discard.pic(n);
...
show.pic();
       </programlisting>

     </para><para>
       Any other order may crash the interpreter without any diagnostic
       messages.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Sound resource management commands</title>
<para>
   <variablelist>
    <varlistentry>
     <term><function id="sound">sound(n,m)</function></term>
     <listitem><para>
       Starts playback of the sound resource <parameter/n/. When
       finished, <parameter/fm/ is set.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="stop.sound">stop.sound()</function></term>
     <listitem><para>
       Stops the playback.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Text management commands</title>
<para>
   <variablelist>
    <varlistentry>
     <term><function id="prevent.input">prevent.input()</function></term>
     <listitem><para>
       Prevents the user from entering anything using the keyboard.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="accept.input">accept.input()</function></term>
     <listitem><para>
       Allows the user to enter text using the keyboard.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="print">print(n), print.v(n)</function></term>
     <listitem><para>
       Opens a text window in the centre of the screen, where a message
       number <parameter/n/ (or <parameter/vn/) from the messages field
       of the current logic resource is displayed. Output mode is
       determined by <parameter/f15/ (see flag description).
       The message is a NULL-terminated string of text. In addition to
       letters, digits, and other symbols, the string may contain:
     </para><para>

       <simplelist>
         <member>Newline character (0x0A);
         <member><literal>%v&lt;decimal number&gt;</literal>:
          at this place the output will include a decimal value of
          variable with the given number.
         <member><literal>%m &lt;number&gt;</literal>:
          the text of the message with the given number is
          inserted at this place.
         <member><literal>%0 &lt;number&gt;</literal>:
          the name of the member with the given number is
          inserted at this place.
         <member><literal>%w &lt;number&gt;</literal>:
          a vocabulary word with the given number is
          inserted at this place.
         <member><literal>%s &lt;number;gt</literal>:
          a string variable with the given number is inserted at
          this place.
         <member><literal>%g &lt;number</literal>:
          a message with this number from message field of Logic(0)
          is inserted at this place.
       </simplelist>

     </para><para>
       For <literal/%v/, you can add a vertical line and a number
       of characters the output should take. In this case leading
       zeros are not suppressed in the output.
     </para><para>
       Example: <literal/%v34|2/
     </para><para>
       When you write your messages, remember that the interpreter wraps
       the text between the lines as needed when the message is displayed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="display">display(r,c,n), display.v(r,c,n)</function></term>
     <listitem><para>
       Prints a message number <parameter/n/ (<parameter/vn/) in the
       row <parameter/r/ (<parameter/vr/), starting with the column
       <parameter/c/ (<parameter/vc/). No window is created, so it is
       up to the programmer to erase the output when it is no longer needed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term>
      <function id="print.at">print.at(n,x,y,l)</function>,
      <function id="print.at.v">print.at.v(n,x,y,l)</function>
     </term>
     <listitem><para>
       Analogous to <function>print</function> but the programmer can
       specify the window location. <parameter/x/, <parameter/y/, and
       <parameter/l/ are constants specifying coordinates of the
       top left corner of the window and its width in character cells
       of a 40x25 screen.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="version">version()</function></term>
     <listitem><para>
       Prints interpreter version in the centre of the screen.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="text.screen">text.screen()</function></term>
     <listitem><para>
       The screen switches to the text mode 40x25.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="graphics">graphics()</function></term>
     <listitem><para>
       The screen returns to the graphics mode. The picture on the screen is
       restored.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="set.cursor.char">set.cursor.char(n)</function></term>
     <listitem><para>
       First byte of the message <parameter/n/ is used as a text mode cursor.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="set.text.attribute">set.text.attribute(fg,bg)</function></term>
     <listitem><para>

       Sets foreground and background colours for <function>display</function>,
       <function/get.num/ and <function>get.string</function> commands.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="clear.lines">clear.lines(n,m,c)</function></term>
     <listitem><para>
       Clears text lines from <parameter/n/ to <parameter/m/ using
       colour <parameter/c/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="clear.text.rect">clear.text.rect(x1,y1,x2,y2,c)</function></term>
     <listitem><para>
       Clears a rectangular area with top left corner coordinates
       <parameter/(x1,y1)/ and bottom right coordinates <parameter/(x2,y2)/
       using colour <parameter/c/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="status.line.on">status.line.on()</function></term>
     <listitem><para>
       Shows the status line containing the current score and sound status
       (on/off).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="status.line.off">status.line.off()</function></term>
     <listitem><para>
       Removes the status line.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>String management commands</title>
<para>
   <variablelist>
    <varlistentry>
     <term><function id="set.string">set.string(n,m)</function></term>
     <listitem><para>
       Stores message number <parameter/m/ in the string variable
       <parameter/n/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="word.to.string">word.to.string(n,m)</function></term>
     <listitem><para>
       Word number <parameter/m/ of the user input is stored in
       <literal/s/<parameter/n/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="get.string">get.string(n,m,x,y,l)</function></term>
     <listitem><para>
       User input is stored in <literal/s/<parameter/n/. <parameter/m/
       is the number of the message used as the prompt. <parameter/x/,
       <parameter/y/ and <parameter/l/ are input position and maximum
       string length.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="parse">parse(n)</function></term>
     <listitem><para>
       Parses <literal/s/<parameter/n/ as if it was entered by the player.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="get.num">get.num(n,m)</function></term>
     <listitem><para>
       Enters a number from the keyboard into <parameter/vm/.
       Message <parameter/n/ is used as the prompt.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Initialization commands</title>
<para>
   <variablelist>
    <varlistentry>
     <term><function id="set.key">set.key(s,c)</function></term>
     <listitem><para>

   Set interpreter's special key.  <parameter/c/ is the key code (decimal number
   from 0 to 255) and <parameter/s/ (if the key is a regular, or <literal/CTRL/+key pair).
   the ASCII code (for example, <literal/TAB/ is 0x0009).
   If the key is a function key or <literal/ALT/+key pair,
   the corresponding IBM-PC keyboard scan code is in the high byte of
   <parameter/s/. For example, the scan code of <literal/F1/ is 0x3B00, <literal/ALT/+<literal/Z/
   is 0x2C00.

   <parameter>Does ``key code'' mean the key scan code, or the ASCII code of the
   character? Is the IBM-PC scan code valid in other platforms as well?
   -- CM</parameter>
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="set.game.id">set.game.id(n)</function></term>
     <listitem><para>
   Message n is scanned by the interpreter and compared with its internal
   identifier. On mismatch, the program exits. For the AGDS interpreter the
   identifier is ``TQ''. See also <xref linkend="gameid">.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="script.size">script.size(n)</function></term>
     <listitem><para>

   Sets the size of script table in bytes. Script table stores codes of
   some interpreter commands. It is needed by the interpreter to
   correctly reload resources when <literal/restore_game/ is executed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="trace.info">trace.info(n,m,l)</function></term>
     <listitem><para>
   Sets the built-in debugger parameters.
   <parameter/n/ is the number of LOGIC resource with command names, and
   <parameter/m/ and <parameter/l/ are the first line and height of the debugger window.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="trace.on">trace.on()</function></term>
     <listitem><para>
   Turns on the debugger. In general, the debugger is turned on with
   <literal/SCROLL LOCK/ key when the command name table is loaded even if this
   command does not occur in the program.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="log">log(n)</function></term>
     <listitem><para>
   This is a debugging command. It writes a log message in the format

<programlisting>
Room &lt;current room&gt; Input line &lt;current input line&gt; ... message ...
</programlisting>
   where the message is given by number <parameter/n/. Output is sent to a file.

   <parameter>(Are these debugging commands valid only for AGDS, or they work
   in AGI as well? --CM)</parameter>
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Menu management commands</title>
<para>
   Creating your program, you can offer the player a choice using a
   system of menus. These may be short one-line questions (menu header)
   with several answers (menu elements), or a prompt to change some of
   the system parameters, for example, object movement speed. Let us
   consider these commands.

   <variablelist>
    <varlistentry>
     <term><function id="set.menu">set.menu(n)</function></term>
     <listitem><para>
   Message <parameter/n/ is used as the header of the menu elements which follow.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="set.menu.member">set.menu.member(n,c)</function></term>
     <listitem><para>

   Message <literal/n/ is used as a menu element, where <parameter/c/ is this
   element's code (a number between 0 and 255).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="submit.menu">submit.menu()</function></term>
     <listitem><para>
   Ends menu creation.

    <varlistentry>
     <term><function id="enable.member">enable.member(c), disable.member(c)</function></term>
     <listitem><para>
   Enables or disables a menu member with the code <parameter/c/.
   <literal>
                              +-------- heading
                              v
                          +-----------------------------+
                          | File                        |
                          +------------+----------------+
               Menu   --->| Save       |
               Element    |------------|
                          | Restore    |
                          |------------|
                          |XXXXXXXXXXXX|&lt;---- menu element disabled
                          |------------|      using disable.member
                          | Quit       |
                          +------------+
   </literal>

    <varlistentry>
     <term><function id="menu.input">menu.input()</function></term>
     <listitem><para>
   If <literal/f14/ is set, a menu system is shown on the screen, allowing the
   user to choose an member. Whether an member with the code c has been
   chosen can be tested using a command <literal/controller(c)/, where <parameter/c/ is
   the code assigned to the menu member.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Logical commands</title>

<sect3><title>Test commands</title>
<para>
   The result of test command can be either TRUE or FALSE.

   <variablelist>
    <varlistentry>
     <term><function id="equaln">equaln(n,m)</function></term>
     <listitem><para>
   TRUE if <parameter/vn/ = <parameter/m/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="equalv">equalv(n,m)</function></term>
     <listitem><para>
   true if <parameter/vn/ = <parameter/vm/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="lessn">lessn(n,m)</function></term>
     <listitem><para>
   TRUE if <parameter/vn/ &lt; <parameter/m/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="lessv">lessv(n,m)</function></term>
     <listitem><para>
   TRUE if <parameter/vn/ &lt; <parameter/vm/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="greatern">greatern(n,m)</function></term>
     <listitem><para>
   TRUE if <parameter/vn/ > <parameter/m/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="greaterv">greaterv(n,m)</function></term>
     <listitem><para>
   TRUE if <parameter/vn/ > <parameter/vm/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="isset">isset(n)</function></term>
     <listitem><para>
   TRUE if <literal/f/<parameter/n/ is set.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function>isset.v(n)</function></term>
     <listitem><para>
       TRUE if Flag(<parameter/vn/) is set.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="has">has(n)</function></term>
     <listitem><para>
   TRUE if the room field of member <parameter/n/ is 255, i.e. the member belongs to the
   player.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="obj.in.room">obj.in.room(n,m)</function></term>
     <listitem><para>
   TRUE if room field of the object <parameter/n/ is <parameter/vm/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="posn">posn(n,x1,y1,x2,y2)</function></term>
     <listitem><para>
   TRUE if the coordinates of the base point of the cel which is the
   current image of object <parameter/n/ satisfies the equations
   <parameter/x1/ &lt;= <parameter/x/ &lt;= <parameter/x2/ and <parameter/y1/ &lt;= <parameter/y/ &lt;= <parameter/y2/.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="obj.in.box">obj.in.box(n,x1,y1,x2,y2)</function></term>
     <listitem><para>

   TRUE if the base of the object <parameter/n/ is completely within the rectangle
   specified using its top left <parameter/(x1,y1)/ and bottom right <parameter/(x2,y2)/
   corners.
<programlisting>
(x1, y1)
   +----------------+
   |                |
   |                |
   |                |
   +----------------+
                  (x2, y2)
</programlisting>

   <function>center.position(n,x1,y1,x2,y2)</function>
   TRUE of the center of the base line of the object <parameter/n/ is inside the
   rectangle specified as its top left and bottom right corners.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function>right.position(n,x1,y1,x2,y2)</function></term>
     <listitem><para>
   TRUE of the right side of the base line of the object <parameter/n/ is inside the
   rectangle specified as its top left and bottom right corners.

    <varlistentry>
     <term><function id="have.key">have.key()</function></term>
     <listitem><para>
   TRUE if the user has pressed any key on the keyboard. Used to create
   cycles to wait until any key is pressed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="compare.strings">compare.strings(s1,s2)</function></term>
     <listitem><para>
   TRUE if <literal/s1/ == <literal/s2/.

    <varlistentry>
     <term><function id="said">said(n,W(i))</function></term>
     <listitem><para>
   where <parameter/i/ = 1, ..., <parameter/n/.

   See <xref linkend="parsing">.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="controller">controller(n)</function></term>
     <listitem><para>
   TRUE if the event with code <parameter/n/ has occurred:
   <simplelist>
    <member>a key with the code <parameter/n/ was pressed (set using <literal/set_key/);
    <member>menu member with code <parameter/n/ was selected in command <literal/menu_input/.
   </simplelist>
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Other commands</title>
<para>
   <variablelist>
    <varlistentry>
     <term><function id="configure.screen">configure.screen(a,b,c)</function></term>
     <listitem><para>
   Sets position of lines on the screen, where <parameter/a/ = 1 (the minimum line
   number for print), <parameter/b/ is the user input line and <parameter/c/ is the status
   line.

   <parameter>(Sounds confuse --CM)</parameter>
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="obj.status.v">obj.status.v(n)</function></term>
     <listitem><para>
   Prints a message for the object <parameter/vn/ in the format

<programlisting>
Obj &lt;n&gt; x: &lt;pos&gt; y: &lt;pos&gt; pri: &lt;priority&gt; stepsize: &lt;step size&gt;
</programlisting>

    <varlistentry>
     <term><function id="show.mem">show.mem()</function></term>
     <listitem><para>
   Displays a report of the interpreter memory status.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="show.pri.screen">show.pri.screen()</function></term>
     <listitem><para>
   Shows priorities of the screen pixels. Priority n is shown as color
   number <parameter/n/ (see color setting commands in I.1.2.1.1).
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="show.obj">show.obj(n)</function></term>
     <listitem><para>
   Show cel 0 of loop 0 of the VIEW resource <parameter/n/ in the bottom center of
   the screen. In the center of the screen, a message associated with the
   VIEW resource is printed.

   <parameter>(That's what they say but I suspect they mean OBJECT n, not VIEW
   resource. --VB)</parameter>

   <parameter>(Actually, in this case the argument does refer to the VIEW resource.
   This is because the VIEW in question isn't meant to be a controlled
   object but instead is simply the picture and textual description of
   the an inventory member. --LE)</parameter>
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="shake.screen">shake.screen(n)</function></term>
     <listitem><para>
   The screen shakes <parameter/n/ times.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="echo.line">echo.line()</function></term>
     <listitem><para>
   The last line entered by the user is displayed in the input line.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="cancel.line">cancel.line()</function></term>
     <listitem><para>
   Input line is cleared.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="close.window">close.window()</function></term>
     <listitem><para>
   If there is a text window on the screen, it is removed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="open.dialogue">open.dialogue, close.dialogue()</function></term>
     <listitem><para>
   Enables and disables <function>get.string</function> and <literal/get.num/ commands if
   <function>prevent.input</function> has been issued.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="restart.game">restart.game()</function></term>
     <listitem><para>
   Restarts the game from the very beginning.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="save.game">save.game, restore.game()</function></term>
     <listitem><para>
   These command save and restore the current state of the game into disk
   files.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="pause">pause()</function></term>
     <listitem><para>
   Stops the interpreter until any key is pressed.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="quit">quit(n)</function></term>
     <listitem><para>
   Exits the interpreter. If <parameter/n/ = 1, quits immediately.
   If <parameter/n/ = 0, asks ``Press ENTER to quit. Press ESC to continue.''
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="init.joy">init.joy()</function></term>
     <listitem><para>
   Initialize joystick.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function id="toggle.monitor">toggle.monitor()</function></term>
     <listitem><para>
   Switch RGB monitor into the graphics mode.
     </para></listitem>
    </varlistentry>

    <varlistentry>
     <term><function>upper.left()</function></term>
     <listitem><para>
   Usually the crossing by an object of various areas and lines is
   tracked by the base point (bottom right corner) of its cel. After this
   command, top left corner is used as such a point.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Other commands</title>
<para>
   Described by <author><firstname/Dark/ <surname/Minister/</author>,
   13 October 1998.
</para>
<para>
   <variablelist>
    <varlistentry>
     <term><function id="unknown170">unknown170(n)</function></term>
     <listitem><para>
   This command modifies the behavior of the commands
   <function/restore.game/ and <function/save.game/.

   After calling <function/unknown170(n)/,
   where <parameter/n/ is a string number (ie: if <parameter/n/ == 2 then <literal/s2/)
   <function/restore.game()/ will automatically
   (without any prompt) restore a savegame with the name stored in
   string number <parameter/n/ and <function>save.game</function>
   will automatically save a savegame with the name of string number <parameter/n/.

   Note: make sure that at least one savegame is present when you call
   <function/restore.game()/ or <function/save.game()/ (that is, when saving a
   game too).

   Example:
<programlisting>
set.string(s1,"test");
unknown170(1);
</programlisting>
   will automatically load the savegame named ``test''.

    <varlistentry>
     <term><function id="unknown173">unknown173(n)</function></term>
     <listitem><para>
   This command changes the way that ego is controlled.
   After calling <literal/unknown173()/, Ego will only move when a direction key
   is maintained pressed. If the key is released, ego will stop walking.
   See also command <function/unknown181/.

    <varlistentry>
     <term><function id="unknown177">unknown177(n)</function></term>
     <listitem><para>
   This command control the access to the menu. <literal/unknown177(0)/ will
   disable access to the menu, even if flag 14 (<literal/menu_enabled/) is set.
   Calling <literal/unknown177()/ with a value greater than 0 seem to do nothing
   else than enabling access to the menu.

    <varlistentry>
     <term><function id="unknown181">unknown181(n)</function></term>
     <listitem><para>
   This command restablishes the default control of Ego.
   It is normally used after a call to
   <function/unknown173/.
     </para></listitem>
    </varlistentry>
   </variablelist>

   Note: Be aware that commands 175, 176, 178, 179 and 180 of the last
   version of AGI (ver 3.002.149) do absolutely nothing.
</para>

</sect1>


<sect1 id="kq4code"><title>Discussion of sample LOGIC code from KQ4</title>
<para>
<emphasis>
(Last updated: 31 August 1997).
</emphasis>

   Some of you may know that ``The Official Book of King's Quest'' included
   three small fragments of AGI code for room 7 in the AGI version of
   KQ4. These fragments are given below along with the same fragments
   taken from the game itself. There are a few differences which is to be
   expected but generally the code is very similar. These examples show
   how the coder wrote the code and what it now looks like in the final
   product. I've included a few comments where some interesting
   observations can be seen.
</para>

<sect2><title>Animating the smoke</title>
<para>
From the book:
<programlisting>
animate.obj( smoke);
ignore.horizon( smoke);
set.view( smoke, v.fish.cabin);
set.loop( smoke, 1);
ignore.blocks( smoke);
position( smoke, 95, 16);
work = 3;
step.time( smoke, work);
cycle.time( smoke, work);
draw( smoke);
</programlisting>

From the game:
<programlisting>
animate.obj(7);
ignore.horizon(7);
set.view(7, 114);
set.loop(7, 1);
ignore.objs(7);                [ These two lines have been added.
set.priority(7, 5);            [
ignore.blocks(7);
position(7, 95, 16);
assignn(152, 3);               [ Equivalent to 'work = 3;'
step.time(7, 152);
cycle.time(7, 152);
draw(7);
</programlisting>
</para>

<sect2><title>Opening the door</title>
<para>
From the book:
<programlisting>
if (said( open, door)) {     [ must be close enough
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      if ( door.open) {
        print("The door is already open. . .
      }
      else {
        set( game.control);
        set.priority( ego, 11);
        start.update( door);
        end.of.loop( door, door.done);
      }
    }
    else {
      print("You can't -- it's locked...
    }
  }
  else {
    set( notCloseEnough);
  }
}
</programlisting>

From the game:
<programlisting>
if (said(OPEN, DOOR||DOORS||DOORWAY||DOORWAYS)) {
  if (posn(0, 86, 120, 106, 133)) {
    if (!isset(38)) {
      if (isset(231)) {
        print("The door is already open.");
      }
      else {
        set(36);
        prevent.input();
        start.update(5);
        assignn(152, 3);
        cycle.time(5, 152);
        end.of.loop(5, 232);
        sound(70, 154);
      }
    }
    else {
      print("You can't.  It's locked and you
             don't have the key.");
    }
  }
  else {
    set(113);
  }
}
</programlisting>
</para>

<sect2><title>Unlocking the door</title>
<para>
From the book:
<programlisting>
if (said( unlock, door)) {     [must be close enough
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      print("The door is already unlocked. . .
    }
    else {
      printf("You can't, it's locked. . .
    }
  }
  else {
    set( notCloseEnough);
  }
}
</programlisting>

From the game:
<programlisting>
if (said(UNLATCH||UNLOCK, DOOR||DOORS||DOORWAY||DOORWAYS)) {
  if (posn(0, 86, 120, 106, 133)) {
    if (!isset(38)) {
      print("The door is already unlocked.");
    }
    else {
      print("You can't.  It's locked and you
             don't have the key.");
    }
  }
  else {
    set(113);
  }
}
</programlisting>
</para>

<sect2><title>Knocking on the door</title>
<para>
From the book:
<programlisting>
if ((said( knock, at, door) || said( knock) ||
     said( knock, on, door) || said( knock, door)) {
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      print("You knock on the door. . .
             a woman says. . .
    }
    else {
      printf("You knock on the. . .
              a man calls out. . .
    }
  }
  else {
    set( notCloseEnough);
  }
}
</programlisting>

From the game:
<programlisting>
if (said(BANG||KNOCK||RAP||TAP) ||
    said(BANG||KNOCK||RAP||TAP, DOOR||DOORS||DOORWAY||DOORWAYS)) {
  if (posn(0, 86, 120, 106, 133)) {
    if (!isset(38)) {
      print("You assertively knock on the shanty
             door.  A woman's voice answers, "Jest come on in!"");
    }
    else {
      print("You assertively knock on the shanty
             door.  From inside, a man's voice calls out, "D'ya know
             what TIME it is?!  GO AWAY!!"");
    }
  }
  else {
    set(113);
  }
}
</programlisting>
</para>

<sect2><title>Fall rocks</title>
<para>
From the book:
<programlisting>
if (hit.special) {
  if ((rf2 || rf3 || rf4)) {
    reset(hit.special);
    get.posn(ego, priorx, priory);
    position.f(dude, priorx, priory);
    ignore.blocks(dude);
    set( game.control);
    set.view( dude, v.ego.land);
    if ((ego.dir == 3 || ego.dir == 4)) {
      set.loop( dude, 2);
    }
    else {
      set.loop( dude, 3);
    }
    fix.loop(dude);
    work = 3;
    step.size( dude, work);
    work = 3;
    cycle.time( dude, work);
    start.cycling(dude);
    erase(ego);
    draw(dude);
    if (rf3) {
      work6 = 0;
      move.obj.f( dude, tempx, tempy, work6, fall.done);
    }
    if (rf4) {
      work6 = 0;
      move.obj.f( dude, tempx, tempy, work6, fall.done);
    }
    if (rf2) {
      if (priory < 125) {
        set.priority( dude, 9);
        tempy=132;
        work6=0;
        move.obj.f( dude, ego,x, tempy, work6, fall.done);
      }
      else {
        set.priority(dude, 15);
        tempy = 156;
        work6 = 0;
        move.obj.f( dude, ego.x, tempy, work6, fall.done);
      }
    }
  }
}
</programlisting>

From the game:
<programlisting>
if (isset(3)) {     [ hit.special
  if (isset(222) || isset(223) || isset(224)) {     [ rf2, rf3, rf4
    reset(3);
    sound(51, 154);
    get.posn(0, 134, 135);
    position.v(12, 134, 135);
    ignore.blocks(12);
    set(36);
    prevent.input();
    set.view(12, 11);
    if (equaln(6, 3) || equaln(6, 4)) {
      set.loop(12, 2);
    }
    else {
      set.loop(12, 3);
    }
    fix.loop(12);
    assignn(152, 3);
    step.size(12, 152);
    assignn(152, 3);
    cycle.time(12, 152);
    start.cycling(12);
    erase(0);
    draw(12);
    if (isset(223)) {
      assignn(158, 0);
      move.obj.v(12, 107, 108, 158, 226);
    }
    if (isset(224)) {
      assignn(158, 0);
      move.obj.v(12, 107, 108, 158, 226);
      set.priority(12, 14);
    }
    if (isset(222)) {
      if (lessn(135, 125)) {
        set.priority(12, 9);
        assignn(108, 132);
        assignn(158, 0);
        move.obj.v(12, 33, 108, 158, 226);
      }
      else {
        set.priority(12, 14);
        assignn(108, 158);
        assignn(158, 0);
        move.obj.v(12, 33, 108, 158, 226);
      }
    }
  }
}
</programlisting>
</para>

</sect1>


<chapter id="formats"><title>Formats of the resource files</title>

<sect1 id="dirfmt"><title>Directory files</title>
<para>
   Written by <author><firstname/Lance/ <surname/Ewing/</author>,
   31 August 1997.
</para><para>
   All AGI games have either one directory file, or more commonly, four.
   AGI version 2 games will have the files <literal/logdir/, <literal/picdir/,
   <literal/viewdir/, and <literal/snddir/. Games that use version 3 of the AGI
   interpreter will have a single file called <literal/*dir/ where the star
   is the initials of the game (e.g. BC, GR, MH2, MH1, KQ4). This single
   file is basically the four version 2 files joined together except that
   it has an 8 byte header giving the position of each directory within
   the single file.
</para><para>
   The directory files give the location of the data types within the VOL
   files. The type of directory determines the type of data. For example,
   the <literal/logdir/ gives the locations of the LOGIC files. For a brief
   introduction to the different data types, see
   <xref linkend="overview">.
</para><para>
   Note: In this description and elsewhere in documents written by me,
   the AGI data called LOGIC, PICTURE, VIEW, and SOUND data are referred
   to by me as files even though they are part of a single VOL file. I
   think of the VOL file as sort of a virtual storage device in itself
   that holds many files. Some documents call the files contains in VOL
   files ``resources''.
</para>

<sect2><title>Version 2 directories</title>
<para>
   Each directory file is of the same format. They contain a finite
   number of three byte entries, no more than 256. The size will vary
   depending on the number of files of the type that the directory file
   is pointing to. Dividing the filesize by three gives the maximum file
   number of that type of data file. Each entry is of the following
   format:
</para><para>
<programlisting>
    Byte 1           Byte 2           Byte 3
7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0
V V V V P P P P  P P P P P P P P  P P P P P P P P
</programlisting>
</para><para>
   where V = VOL number and P = position (offset into VOL file).
</para><para>
   The entry number itself gives the number of the data file that it is
   pointing to. For example, if the following three byte entry is entry
   number 45 in the SOUND directory file,
</para><para>
<programlisting>
12 3D FE
</programlisting>
</para><para>
   then <literal/sound.45/ is located at position 0x23DFE in the <literal/vol.1/ file.
   The first entry number is entry 0.

   If the three bytes contain the value 0xFFFFFF, then the resource does
   not exist.
</para>

<sect2><title>Version 3 directories</title>
<para>
   In the case of version 3 of the AGI interpreter, the <literal/logdir/,
   <literal/picdir/, <literal/viewdir/, and <literal/snddir/ files are concatenated together
   in that order with an eight byte header giving the starting offset of
   each directory.
</para><para>
   Header
</para><para>
<programlisting>
Byte 0 1 2 3 4 5 6 7
     L L P P V V S S
</programlisting>

   where L = offset of <literal/logdir/, P = offset of <literal/picdir/, V = offset
   of <literal/viewdir/ and S = offset of <literal/snddir/.

   Each offset is two bytes in length where the first byte is the low
   byte and the second byte is the high byte as is the case in the whole
   AGI system. For example, the first two bytes will always be 0x0800
   since the header is a fixed size of eight bytes.

   The format of each of the individual directory sections then follows
   as above for AGI v2.

</para>
</sect1>

<sect1 id="volfmt"><title>Format of Vol files (version 2)</title>
<para>
   Written by <author><firstname/Lance/ <surname/Ewing/</author>,
   31 August 1997.
</para><para>
   Vol files are the main data files for AGI games. They contain four
   types of data: LOGIC, PICTURE, VIEW, and SOUND data. A Vol file is a
   collection of a large number of these "resource" files which can be in
   any order. The directory files determine the start of each resource.
</para><para>

   The start of every resource file has a five byte header.
</para><para>

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Signature (0x12--0x34)
  2   Vol number that the resource is contained in
 3-4  Length of the resource taken from after the header
----- -----------------------------------------------------------
</programlisting>

</para><para>
   The data after the header depends on the type of resource file. These
   formats are documented elsewhere.
</para>
</sect1>

<sect1 id="v3fmt"><title>Version 3 resource storage</title>
<para>
   Written by <author><firstname/Lance/ <surname/Ewing/</author>,
   27 January 1997.

</para><para>
   AGIv3 stores resources in a slightly different way from AGIv2. The
   first significant difference is in the length of the resource header
   which is now seven bytes.
</para><para>

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Signature (0x12--0x34)
  2   Vol number that the resource is contained in
 3-4  Uncompressed resource size (LO-HI)
 5-6  Compressed resource size (LO-HI)
----- -----------------------------------------------------------
</programlisting>

</para><para>
   Instead of one resource size as in AGIv2, there are now two sizes.
   Most of the resources in AGIv3 games are compressed with a form of
   LZW. Some of them are not though. The interpreter determines whether
   the resource is compressed by comparing the values of the two sizes
   given in the header information. If they are equal, then it knows that
   the resource is stored uncompressed. However, if the sizes do not
   match, this does not mean that the file is compressed with LZW. If the
   file is a PICTURE file, then it is stored with its own limited form of
   compression. This is why the top bit of the third byte in the header
   is used to tell the interpreter that the resource is a PICTURE file,
   otherwise it would think that the resource was compressed with LZW.
</para><para>

   As far as I can tell, none of the PICTUREs are compressed with LZW.
   This may well be possible though. It could also be possible for the
   PICTURE to be totally uncompressed (i.e. it wouldn't use the PICTURE
   compression method), but I haven't seen any examples of either of the
   above two cases.
</para>

<sect2><title>LZW compression</title>
<para>
   The compression used with version 3 games is an adaptive form of LZW.
   The LZW algorithm is not explained here, but it basically compresses
   data by representing previous strings by single codes. When these
   strings are encountered again, the code can be stored instead. The
   following information states how the AGIv3 algorithm differs from the
   standard LZW algorithm. There are plenty of places on the net where
   you can find a description of the LZW algorithm if you are not
   familiar with it.
</para><para>
   AGIv3 uses an adaptive form of LZW that starts by using 9 bit codes
   and when the code space is full, it progresses on to 10 bits and so
   on. As with normal LZW, codes 0-255 represent the standard ASCII
   characters. The next two codes have a special meaning:
</para><para>
   <simplelist>
    <member>256 is used as a start over code. The table is cleared, the number
   of bits set back to 9, and the process begins again with the next code
   being 258.
    <member>257 tells the interpreter that it has reached the end of the
   resource.
   </simplelist>
</para><para>
   Code 256 seems to be the first code stored in all compressed
   resources. This is probably just to make sure everything is
   initialized for beginning the compression process. As was mentioned
   above, the first code used for the LZW table itself is code 258. From
   there it stores pairs of prefix codes and appended characters for each
   table entry until it reaches code 512 at which stage it switches to
   storing the codes using 10 bits and then 11 and so on. It appears that
   it will never get to 12 bits because code 256 always seems to turn up
   just before it needs to switch up to 12 bits, i.e. when code 2048 is
   required. Carl Muckenhoupt's decrypt routine for SCI games specifically
   prevents it from switching to 12 bits anyway. Whether there is ever a
   case where code 256 does not intervene, it has not yet been
   determined.
</para><para>
   Note: I should point out that Carl and myself both arrived at the
   above algorithm independently which confirms that the compression used
   in the early SCI games was identical to that used in AGIv3.
</para>

<sect2><title>Picture compression</title>
<para>
   Pictures in AGI version 3 use a simple form of compression to shrink
   their size my a tiny amount. It was obviously recognised by the
   interpreter coders that four bits were being wasted for picture codes
   0xF0 and 0xF2. These are the two codes that change the visual and the
   priority colour respectively. Since there are only 16 colours, there
   need not be a whole byte set aside for storing the colour. All the
   picture compression does is store these colours in 4 bits rather than 8.
</para><para>
   Example:
</para><para>
<programlisting>
Original picture codes: F0 06 F8 12 45 F0 07 F2 05 F8 14 67 ...
Compressed picture code: F0 6F 81 24 5F 07 F2 5F 81 46 7 ...
</programlisting>
</para>

</sect1>

<sect1 id="rescode"><title>Sample code</title>
<para>
   <simplelist>
    <member><filename/agifiles.c/ by Lance Ewing:
      routines to handle loading of resources
    <member><filename/agifiles.h/ by Lance Ewing:
      header file for <filename/agifiles.c/
    <member><filename/general.h/ by Lance Ewing:
      general definitions
    <member><filename/volx2.c/ by Lance Ewing, Joakim Möller and
      Martin Tillenius: program to extract resources from AGI version 2 games
    <member><filename/xv3.pas/ by Lance Ewing: program to extract
      resources from AGI version 3 games
    <member><filename/agiver.pas/ by Jeremy Hayes:
      displays version number of game and interpreter
   </simplelist>
</para>

</sect1>
</chapter>



<chapter id="logicres"><title>LOGIC resources</title>
<para>
   Lance Ewing, 27 January 1997.
</para>

<sect1 id="logicfmt"><title>Introduction</title>
<para>
   At the heart of Sierra's Adventure Game Interpreter is the LOGIC file.
   These files contain the code that makes up the game. Each room has a
   logic script that goes with it. This logic script governs what can
   take place in that room. Here is an example of what the programmer
   writes when a game is being created.
</para><para>
   Example 0: KQ4. Room 7.
</para><para>
<programlisting>
if (said( open, door))       [ must be close enough
{
   if (posn( ego, 86, 120, 106, 133))
   {
      if (!night)
      {
         if ( door.open)
         {
            print("The door is already open");
         }
         else
         {
            set( game.control);
            set.priority( ego, 11);
            start.update( door);
            end.of.loop( door, door.done);
         }
      }
      else
      {
         print("You can't -- it's locked");
      }
   }
   else
   {
      set( notCloseEnough);
   }
}
</programlisting>

</para><para>
   The logic script is not stored like this in the game files though.
   Instead each AGI command is stored as a bytecode and the resulting data
   doesn't look much like the above example at all. This document will
   try to explain each component of a logic script the way it is stored
   in the actual game data.

</para>
</sect1>

<sect1 id="cmdlist"><title>Command list and argument types</title>
<para>
   Peter Kelly, 3 March 1998.

</para><para>
   This is a list of all AGI commands and their argument types. The
   function and name of some of these is not yet known. Check out
   <literal/agicommands.pas/ in section ``Sample code'' for a Delphi/Pascal
   unit containing this information.
</para>

<sect2><title>Text commands</title>
<para>
<programlisting>
 #  Name              No.  arg1 arg2 arg3 arg4 arg5 arg6 arg7
01 equaln              2   var  num
02 equalv              2   var  var
03 lessn               2   var  num
04 lessv               2   var  var
05 greatern            2   var  num
06 greaterv            2   var  var
07 isset               1   flag
08 issetv              1   var
09 has                 1   Iobj
0A obj.in.room         2   Iobj var
0B posn                5   Sobj num  num  num  num
0C controller          1   ctr
0D have.key            0
0E said                -  ...
0F compare.strings     2   str  str
10 obj.in.box          5   Sobj num  num  num  num
11 center.posn         5   Sobj num  num  num  num
12 right.posn          5   Sobj num  num  num  num
</programlisting>
</para>

<sect2><title>Action commands</title>
<para>
<programlisting>
 #  Name              No.  arg1 arg2 arg3 arg4 arg5 arg6 arg7
00 return              0
01 increment           1   var
02 decrement           1   var
03 assignn             2   var  num
04 assignv             2   var  var
05 addn                2   var  num
06 addv                2   var  var
07 subn                2   var  num
08 subv                2   var  var
09 lindirectv          2   var  var
0A rindirect           2   var  var
0B lindirectn          2   var  num
0C set                 1   flag
0D reset               1   flag
0E toggle              1   flag
0F set.v               1   var
10 reset.v             1   var
11 toggle.v            1   var
12 new.room            1   num
13 new.room.v          1   var
14 load.logics         1   num
15 load.logics.v       1   var
16 call                1   num
17 call.v              1   var
18 load.pic            1   var
19 draw.pic            1   var
1A show.pic            0
1B discard.pic         1   var
1C overlay.pic         1   var
1D show.pri.screen     0
1E load.view           1   num
1F load.view.v         1   var
20 discard.view        1   num
21 animate.obj         1   Sobj
22 unanimate.all       0
23 draw                1   Sobj
24 erase               1   Sobj
25 position            3   Sobj num  num
26 position.v          3   Sobj var  var
27 get.posn            3   Sobj var  var
28 reposition          3   Sobj var  var
29 set.view            2   Sobj num
02 set.view.v          2   Sobj var
02 set.loop            2   Sobj num
02 set.loop.v          2   Sobj var
02 fix.loop            1   Sobj
02 release.loop        1   Sobj
02 set.cel             2   Sobj num
1E set.cel.v           2   Sobj var
1F last.cel            2   Sobj var
20 current.cel         2   Sobj var
21 current.loop        2   Sobj var
22 current.view        2   Sobj var
23 number.of.loops     2   Sobj var
24 set.priority        2   Sobj num
25 set.priority.v      2   Sobj var
26 release.priority    1   Sobj
27 get.priority        2   Sobj var
03 stop.update         1   Sobj
03 start.update        1   Sobj
03 force.update        1   Sobj
03 ignore.horizon      1   Sobj
03 observe.horizon     1   Sobj
03 set.horizon         1   num
28 object.on.water     1   Sobj
29 object.on.land      1   Sobj
2A object.on.anything  1   Sobj
2B ignore.objs         1   Sobj
2C observe.objs        1   Sobj
2D distance            3   Sobj Sobj
2E stop.cycling        1   Sobj
2F start.cycling       1   Sobj
30 normal.cycle        1   Sobj
31 end.of.loop         2   Sobj flag
04 reverse.cycle       1   Sobj
04 reverse.loop        2   Sobj flag
04 cycle.time          2   Sobj var
04 stop.motion         1   Sobj
04 start.motion        1   Sobj
04 step.size           2   Sobj var
32 step.time           2   Sobj var
33 move.obj            5   Sobj num
34 move.obj.v          5   Sobj var
35 follow.ego          3   Sobj num
36 wander              1   Sobj
37 normal.motion       1   Sobj
38 set.dir             2   Sobj var
39 get.dir             2   Sobj var
3A ignore.blocks       1   Sobj
3B observe.blocks      1   Sobj
05 block               4   num  num
5B unblock             0
05 get                 1   Iobj
05 get.v               1   var
05 drop                1   Iobj
05 put                 2   Iobj
3C put.v               2   var  var
3D get.room.v          2   var  var
3E load.sound          1   num
3F sound               2   num  flag
64 stop.sound          0
41 print               1   msg
42 print.v             1   var
43 display             3   num  num
44 display.v           3   var  var
45 clear.lines         3   num  num
6A text.screen         0
6B graphics            0
06 set.cursor.char     1   msg
06 set.text.attribute  2   num  num
06 shake.screen        1   num
06 configure.screen    3   num  num
70 status.line.on      0
71 status.line.off     0
48 set.string          2   strinmessa
49 get.string          5   strinmessa
4A word.to.string      2   word strin
4B parse               1   strin
4C get.num             2   messavar
77 prevent.input       0
78 accept.input        0
4F set.key             3   num  num
07 add.to.pic          7   num  num
07 add.to.pic.v        7   var  var
7C status              0
7D save.game           0
7E restore.game        0
7F init.disk           0
80 restart.game        0
51 show.obj            1   num
52 random              3   num  num
83 program.control     0
84 player.control      0
55 obj.status.v        1   var
56 quit                1   num
87 show.mem            0
88 pause               0
89 echo.line           0
8A cancel.line         0
8B init.joy            0
8C toggle.monitor      0
8D version             0
08 script.size         1   num
08 set.game.id         1   messa
5A log                 1   messa
91 set.scan.start      0
92 reset.scan.start    0
5D reposition.to       3   Sobj num
5E reposition.to.v     3   Sobj var
95 trace.on            0
60 trace.info          3   num  num
61 print.at            4   messanum
62 print.at.v          4   messavar
63 discard.view.v      1   var
09 clear.text.rect     5   num  num
9B set.upper.left      2   ???  ???
09 set.menu            1   messa
09 set.menu.member       2   messacntrl
9E submit.menu         0
09 enable.member         1   cntrl
00 disable.member        1   cntrl
A1 menu.input          0
00 show.obj.v          1   var
A3 open.dialogue       0
A4 close.dialogue      0
00 mul.n               2   var  num
00 mul.v               2   var  var
00 div.n               2   var  num
00 div.v               2   var  var
A9 close.window        0
AA unknown170          1   ???
AB unknown171          0
AC unknown172          0
AD unknown173          0
AE unknown174          1   ???
AF unknown175          1   ???
B0 unknown176          0   (1 arg for AGI version 3.002.086)
B1 unknown177          1   ???
B2 unknown178          0
B3 unknown179          4   ???  ???  ???  ???
B4 unknown180          2   ???  ???
B5 unknown181          0
</programlisting>
</para>
</sect1>

<sect1><title>LOGIC resource format</title>
<sect2><title>The header</title>
<para>
   The header of each logic script is seven bytes in length for games
   before 1988. After this date compression seems to have been introduced
   and the header was subsequently altered. This compression will be
   discussed at a later stage.

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  0x1234: signature for the start of a file in the VOL block
  2   Vol file number
 3-4  Length of the logic script
 5-6  Offset of logic code end and text begin
----- -----------------------------------------------------------
</programlisting>

   All text that can be printed to the screen from within a logic script
   is stored in an encrypted form at the end of the logic script.

   Example 1: KQ1. Room 2.

<programlisting>
 12 34    Signature
 01       vol.1
 5F 06    Length = 0x065F
 BA 02    Text start = 0x02BA
</programlisting>
</para>

<sect2><title>The LOGIC codes</title>
<para>
   The logic code section starts immediately after the header and
   continues until the start of the text section has been reached. There
   are three sets of codes used in a logic script. Most codes will have
   between one and seven arguments inclusive. This is discussed later on.
   The first set of codes is the AGI commands themselves and they have
   the range:

<programlisting>
0x00 - 0xB5    AGI commands. (eg. animate.obj)
</programlisting>

   The value 181 (0xB5) may well be different for each game. Sierra will
   have added more commands to their set as they went along. The value
   above is for Manhunter 2 which is one of the last AGI games made. The
   second set of codes is as follows:

<programlisting>
   FF      if
   FE      else (or goto)
   FD      not (!)
   FC      or (||)
</programlisting>

   At present these are the only high value codes encountered. The <literal/if/
   and <literal/or/ codes are more like brackets, ie. the code will be at the
   start and the end of the section of codes that it refers to. The
   following example will illustrate this:

   Example 2: KQ1. Room 2.
<programlisting>
   FF      'if' conditions start.
   07      07 = isset
   05      05 = flag 5
   FF      'if' conditions close.
</programlisting>

   The above translates to:

<programlisting>
if (isset(5))
</programlisting>

   which tests whether flag number 5 is set. The 0xFF effectively switches
   the interpreter into a condition checking mode which leads us to the
   next set of codes which I call the condition codes:
</para><para>
<programlisting>
0x00 - 0x12    Condition codes.
</programlisting>
</para><para>

   The <function/isset/ condition code was introduced in example 2 above.
   When the interpreter encounters a 0xFF it will then interpret the
   following code values as being in the condition code range until it
   encounters the next 0xFF which switches it back into normal AGI command
   mode. The two bytes immediately following the second 0xFF determine how
   many bytes this <function/if/ statement lasts for before the <function/if/
   is ended.  When the second 0xFF is encountered the interpreter, be it
   us or the machine, does three things:
</para><para>
   <orderedlist>
    <listitem><para>Reads in the following two bytes.</para></listitem>
    <listitem><para>Opens a bracket.</para></listitem>
    <listitem><para>Switches to AGI command mode.</para></listitem>
   </orderedlist>
</para><para>

   Example 3: KQ1. Room 2.
</para><para>
<programlisting>
FF 07 05 FF    if (isset(5))
84 00          {			[ For 0x0084 bytes.
18 00              load.pic(0);
19 00              draw.pic(0);
1B 00              discard.pic(0);
...		   ...
               }			[ Closed. 0x0084 bytes counted.
</programlisting>

</para><para>
   Of course, the code inside the brackets is only executed if the <literal/if/
   condition is met.
</para>

<sect2><title>The <literal/else/ command and more on brackets</title>
<para>
   The else statement will always continue after an <literal/if/ bracket block.
   This next feature is important and has caused a number of hassles in
   the past. When an <literal/else/ statement follows an <literal/if/, then the bracket
   distance given after the <literal/if/ statement <emphasis>will be three bytes
   longer</emphasis> (this is a consequence of the way the interpreter handles
   <literal/if/ and <literal/else/ codes which is discussed later).

</para><para>
   Here's an example:
</para><para>
<programlisting>
if (isset(231)) {                          FF 07 E7 FF 05 00
    printf("The door is already open.");   65 0F
}
else {                                     FE 11 00
    set(36);                               0C 24
    prevent.input();                       77
    start.update(5);                       3B 05
    assignn(152, 3);                       03 98 03
    cycle.time(5, 152);                    4C 05 98
    end.of.loop(5, 232);                   49 05 E8
    sound(70, 154);                        63 46 9A
}
</programlisting>

</para><para>
   Usually you would expect the bracket distance to be 0x0002 but in the
   above case it is clearly 0x0005 which illustrates the difference
   between a straight <literal/if/ statement and an <literal/if..else/ structure. The
   situation is the same for nested <literal/if..else/ structures.

</para><para>
   The <literal/else/ statements themselves are a lot like <literal/if/ statements
   except that they're test condition is given after the 0xFE code but is
   instead the inverse of the condition given by the above <literal/if/
   statement. Only the bracket distance is given after the 0xFE code and
   then the AGI command clock that the <literal/else/ statement encompasses.
</para>

<sect2><title>Test conditions</title>
<para>
   Conditions can be one of the following types:
</para><para>
<programlisting>
FF 07 05 FF                         One condition tested, ie. isset(5)
FF FD 07 05 FF                      One condition NOTed, ie. !isset(5)
FF 07 05 07 06 FF                   Multiple conditions, ANDed.
FF FC 07 05 07 06 FC FF             Multiple conditions ORed.
FF FC 07 06 07 06 FC FD 07 08 FF    Combination.
</programlisting>
</para><para>
   These conditions translate to:
</para><para>
<programlisting>
if (isset(5))
if (!isset(5))
if (isset(5) && isset(6))
if (isset(5) || isset(6))
if ((isset(5) || isset(6)) && !isset(7))
</programlisting>
</para><para>

   If multiple boolean expressions are grouped together, then there
   respective values are ANDed together. If multiple boolean expressions
   are grouped together and then surrounded by a pair of 0xFC codes, then
   their values are ORed together.

</para><para>
   The 0xFD code only applies to the following condition code whose
   boolean value it inverts.
</para>

<sect2><title>Arguments</title>
<para>
   You may well be asking how the interpreter knows how many arguments
   each code has and what type of argument each argument is. This
   information is stored in a file called <literal/agidata.ovl/ (MS-DOS version).
   Inside this file there is a table which contains four bytes for each
   AGI command and condition code. These four bytes are interpreted as
   follows:

</para><para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Pointer to the machine code implementation contained in the
      file agi
  2   Number of arguments
  3   The type of arguments
----- -----------------------------------------------------------
</programlisting>

</para><para>
   The type of arguments value is interpreted as follows:
</para><para>

<programlisting>
Bit        7     6     5     4     3     2     1       0
command( arg1, arg2, arg3, arg4, arg5, arg6, arg7); (unknown)
</programlisting>

</para><para>
   If the bit is set, argument is interpreted as a variable; otherwise
   the argument is interpreted as a number. It is unknown what bit 0 does
   since no AGI command or AGI condition code has more than seven arguments.

</para><para>
   Examples:
</para><para>
   <simplelist>
    <member>0x80 Says that the commands first argument is a variable.
    <member>0x60 Says that the second and third arguments are variable numbers.
   </simplelist>
</para>


<sect2><title>The text section</title>
<para>
   The text section of a logic script contains all the strings that can
   be displayed by that logic script. These strings are encrypted by
   xoring every eleven bytes with the string "Avis Durgan".

</para><para>
   Example 4: KQ1. Room 2.
</para><para>
<programlisting>
if (said(look, alligators))
{
    print("The alligators are swimming in the moat.");
}
</programlisting>

</para><para>
   In the above example, the print statement is represented as:
</para><para>

<programlisting>
65 08
</programlisting>

</para><para>
   The 0x08 is the number given to the string and corresponds to its
   position in the list of strings at the end of the logic script.

</para><para>
   The format of the text section is as follows:
</para><para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Number of messages
 1-2  Pointer to end of messages
 3-4  A list of offsets which point to each of the messages. The
      first offset naturally enough points to the start of the
      textual data
 ...
  ?   Start of the text data. From this point the messages are
      encrypted with Avis Durgan (in their unencrypted form, each
      message is separated by a 0x00 value)
----- -----------------------------------------------------------
</programlisting>
</para>

<sect2><title>Machine code implementation</title>
<para>
   The machine code for each AGI statement is found in the AGI file. This
   is the AGI interpreter itself. The data in the <literal/agidata.ovl/ file is
   used to find the start of the implementation for an AGI statement.
   Below are a couple of examples:

</para><para>
   Example 5: MH2. equaln.
</para><para>
<programlisting>
;equaln   (eg.   if (work = 3)   )
0D71 AC            LODSB                       ;get variable number
0D72 32FF          XOR     BH,BH
0D74 8AD8          MOV     BL,AL
0D76 AC            LODSB                       ;get test number
0D77 3A870900      CMP     AL,[BX+0009]        ;test if var = number
0D7B B000          MOV     AL,00               ;return 0 if not equal
0D7D 7502          JNZ     0D81
0D7F FEC0          INC     AL                  ;return 1 if equal
0D81 C3            RET
</programlisting>

</para><para>
   Example 6: MH2. equalv.
</para><para>
<programlisting>
;equalv  (eg.   if (work = maxwork)   )
0D82 AC            LODSB                       ;get first var number
0D83 32FF          XOR     BH,BH               ;clear bh
0D85 8AD8          MOV     BL,AL               ;BX = variable number
0D87 8AA70900      MOV     AH,[BX+0009]        ;get first var value
0D8B AC            LODSB                       ;get second var number
0D8C 8AD8          MOV     BL,AL
0D8E 32C0          XOR     AL,AL               ;return 0 if not equal
0D90 3AA70900      CMP     AH,[BX+0009]        ;compare variables
0D94 7502          JNZ     0D98
0D96 FEC0          INC     AL                  ;return 1 if equal
0D98 C3            RET
</programlisting>

</para><para>
   These two examples show the difference between how numbers and
   variables are dealt with. In the case of a variable, the variables
   number is used as an index into the table of variable values to get
   the value which is being tested. It appears that the variable table is
   at offset 0x0009 in the data segment.
</para>

<sect2><title>How the interpreter handles LOGIC code</title>
<para>
   Now that you know a bit about what the actual code looks like once it
   has been converted into the LOGIC game data, we will now look at how
   these codes are interpreted by the interpreter. The following 8086
   assembly language code is the actual code from the MS-DOS version of
   Manhunter: San Francisco. There are some calls
   to routines which aren't displayed. Take my word for it that they do
   what the comment says. For those of you who can't follow whats going
   on, I'll explain the interpretation in steps after the code block.

</para><para>
<programlisting>
;Decoding a LOGIC file.
1E6C:2EF2 56            PUSH  SI
1E6C:2EF3 57            PUSH  DI
1E6C:2EF4 55            PUSH  BP
1E6C:2EF5 8BEC          MOV   BP,SP
1E6C:2EF7 83EC02        SUB   SP,+02
1E6C:2EFA 8B7608        MOV   SI,[BP+08]    ;SI -> start of LOGIC script.
1E6C:2EFD 8B7406        MOV   SI,[SI+06]    ;Skip first 6 bytes (header).
1E6C:2F00 AC            LODSB               ;Get next byte in LOGIC file.
1E6C:2F01 84C0          TEST  AL,AL         ;Is code a zero?
1E6C:2F03 7414          JZ    2F19          ;If so, jump to exit.
1E6C:2F05 3CFF          CMP   AL,FF         ;If an opening 'if' code is found
1E6C:2F07 7419          JZ    2F22          ;jump to 'if' handler.
1E6C:2F09 3CFE          CMP   AL,FE         ;If an 'else' has not been found
1E6C:2F0B 7505          JNZ   2F12          ;jump over else/branch.
1E6C:2F0D AD            LODSW               ;Get word (bracket distance)
1E6C:2F0E 03F0          ADD   SI,AX         ;Add to SI. Skip else code.
1E6C:2F10 EBEE          JMP   2F00          ;Go back to get next byte.
1E6C:2F12 E8A8D6        CALL  05BD          ;Execute AGI command.
1E6C:2F15 85F6          TEST  SI,SI         ;
1E6C:2F17 75E8          JNZ   2F01          ;Jump back to top.
1E6C:2F19 8BC6          MOV   AX,SI
1E6C:2F1B 83C402        ADD   SP,+02
1E6C:2F1E 5D            POP   BP
1E6C:2F1F 5F            POP   DI
1E6C:2F20 5E            POP   SI
1E6C:2F21 C3            RET

;Handler for 'if' statement.
;BH determines if its in an OR bracket (BH=1 means OR).
;BL determines the nature of the evalutation (BL=1 means NOT)
1E6C:2F22 33DB          XOR   BX,BX
1E6C:2F24 AC            LODSB               ;Get next byte
1E6C:2F25 3CFC          CMP   AL,FC         ;If less than 0xFC, then
1E6C:2F27 721C          JB    2F45          ;jump to normal processing.
1E6C:2F29 7508          JNZ   2F33          ;If greater, jump to 'if' close.
1E6C:2F2B 84FF          TEST  BH,BH         ;(Could BH be the evaluation reg?
1E6C:2F2D 7551          JNZ   2F80          ;or whether its the second FC?
1E6C:2F2F FEC7          INC   BH            ;
1E6C:2F31 EBF1          JMP   2F24          ;Go back to get next byte.

1E6C:2F33 3CFF          CMP   AL,FF         ;Is the code for an 'if' close?
1E6C:2F35 7505          JNZ   2F3C          ;If not, jump to 'not' test.
1E6C:2F37 83C602        ADD   SI,+02        ;
1E6C:2F3A EBC4          JMP   2F00          ;
1E6C:2F3C 3CFD          CMP   AL,FD         ;Is the code for a 'not'?
1E6C:2F3E 7505          JNZ   2F45          ;If not, jump to test command.
1E6C:2F40 80F301        XOR   BL,01         ;
1E6C:2F43 EBDF          JMP   2F24          ;Go back to get next byte.
1E6C:2F45 53            PUSH  BX            ;BX = test conditions??
1E6C:2F46 E8E8DD        CALL  0D31          ;Evaluate separate test command.
1E6C:2F49 5B            POP   BX            ;
1E6C:2F4A 32C3          XOR   AL,BL         ;Toggle the result for NOT.
1E6C:2F4C B300          MOV   BL,00         ;
1E6C:2F4E 7506          JNZ   2F56          ;If true jump to 2F56.
1E6C:2F50 84FF          TEST  BH,BH         ;If BH=0 then not in OR and
1E6C:2F52 742C          JZ    2F80          ;test is truely false.
1E6C:2F54 EBCE          JMP   2F24          ;Otherwise evaluate next OR.
1E6C:2F56 84FF          TEST  BH,BH         ;Are we in OR mode?
1E6C:2F58 7424          JZ    2F7E          ;If not, continue with testing.
1E6C:2F5A 32FF          XOR   BH,BH         ;If so, then we will skip the
1E6C:2F5C 32E4          XOR   AH,AH         ;rest of the tests in the OR
1E6C:2F5E AC            LODSB               ;bracket since the first is true.
1E6C:2F5F 3CFC          CMP   AL,FC         ;OR: Waiting for closing OR.
1E6C:2F61 741B          JZ    2F7E          ;If OR found, then continue testing.
1E6C:2F63 77F9          JA    2F5E          ;
1E6C:2F65 3C0E          CMP   AL,0E         ;If 'said' then goto said handler
1E6C:2F67 7507          JNZ   2F70          ;else goto normal handler
1E6C:2F69 AC            LODSB               ;Work out number of words in said
1E6C:2F6A D1E0          SHL   AX,1          ;and jump over them.
1E6C:2F6C 03F0          ADD   SI,AX         ;
1E6C:2F6E EBEE          JMP   2F5E          ;
1E6C:2F70 8BF8          MOV   DI,AX         ;Jumps over arguments.
1E6C:2F72 D1E7          SHL   DI,1          ;
1E6C:2F74 D1E7          SHL   DI,1          ;
1E6C:2F76 8A856407      MOV   AL,[DI+0764]  ;Load up the number of arguments
1E6C:2F7A 03F0          ADD   SI,AX         ;Add to the execution pointer
1E6C:2F7C EBE0          JMP   2F5E          ;
1E6C:2F7E EBA4          JMP   2F24

;Test is false.
;This routine basically skips over the rest of the codes until it finds the
;closing 0xFF at which point it will load the following two bytes and add
;them to the execution pointer SI.
1E6C:2F80 32FF          XOR   BH,BH
1E6C:2F82 32E4          XOR   AH,AH
1E6C:2F84 AC            LODSB               ;
1E6C:2F85 3CFF          CMP   AL,FF         ;If the closing 0XFF is found,
1E6C:2F87 741D          JZ    2FA6          ;jump 2FA6.
1E6C:2F89 3CFC          CMP   AL,FC         ;If greater than FC,
1E6C:2F8B 73F7          JNB   2F84          ;get next byte.
1E6C:2F8D 3C0E          CMP   AL,0E         ;If 'said' then goto said handler
1E6C:2F8F 7507          JNZ   2F98          ;else goto normal handler.
1E6C:2F91 AC            LODSB               ;Work out number of words in said
1E6C:2F92 D1E0          SHL   AX,1          ;and jump over them.
1E6C:2F94 03F0          ADD   SI,AX
1E6C:2F96 EBEC          JMP   2F84
1E6C:2F98 8AD8          MOV   BL,AL         ;Jump over arguments.
1E6C:2F9A D1E3          SHL   BX,1
1E6C:2F9C D1E3          SHL   BX,1
1E6C:2F9E 8A876407      MOV   AL,[BX+0764]  ;Load up the number of arguments.
1E6C:2FA2 03F0          ADD   SI,AX         ;Add to the execution pointer.
1E6C:2FA4 EBDE          JMP   2F84
1E6C:2FA6 AD            LODSW
1E6C:2FA7 03F0          ADD   SI,AX         ;Skip over if (includes 3 else byte
s)
1E6C:2FA9 E954FF        JMP   2F00
</programlisting>

</para><para>
   <emphasis/Situation 1./ Okay, every LOGIC file starts in normal AGI command
   execution mode. In this routine, if the code is below 0xFC, then it is
   presumed to be an AGI command. It will then call the main command
   execution routine which will jump to the relevant routine for the
   specific command using the jump table stored in <literal/agidata.ovl/. The
   command is performed and it returns to the main execution routine
   where it loops back to the top and deals with the next code in the
   LOGIC file.

</para><para>
   <emphasis/Situation 2./ If the code is an 0xFF code, then if jumps to the <literal/if/
   statement handler. In this routine is basically assesses whether the
   whole test condition evaluates to true or to false. It does this by
   treating each test separately and calling the relevant test command
   routines using the jump table in the <literal/agidata.ovl/ file. Each test
   command routine will return a value in <literal/AL/ which says whether it is
   true or not. Depending on the NOTs and ORs, the whole expression is
   evaluated. If at any stage during the evaluation the routine decides
   that the expression will be false, it exits to another routine which
   skips the rest of the <literal/if/ statement and then adds the two byte word
   following the closing 0xFF code to the execution pointer. This usually
   has the affect of jumping over the <literal/if/ block of code. If the
   <literal/if/ handler gets to the ending 0xFF then it knows the expression
   is true simply because it hasn't exited out of the routine yet. At this
   stage it jumps over the two bytes following the closing 0xFF and then
   goes back to executing straight AGI commands.

</para><para>
   <emphasis/Situation 3./ If in the normal execution of AGI commands, the code 0xFE
   is encountered, a very simple action takes place. The two bytes which
   follow form a 16-bit twos complement value which is added to execution
   pointer. This is all it does. Previously we said that the 0xFE code
   stood for the <literal/else/ statement which is in actual fact correct for
   over 90% of the time, but the small number of other occurrences are
   best described as <literal/goto/ statements. If you're confused by this, the
   following example will probably explain things.

</para><para>
   Example:
</para><para>
<programlisting>
if (said( open, door)) {
    [ first block of AGI statements
}
else {
    [ second block of AGI statements
}
</programlisting>

</para><para>
   The above example is how the original coder would have written the AGI
   code. If we now look at the following example, it is not hard to see
   that it would achieve the same thing.
</para><para>

<programlisting>
if (!said( open, door)) goto label1;
    [ first block of AGI statements
    goto label2:

label1:
    [ second block of AGI statements

label2:
</programlisting>

</para><para>
   This is exactly how all <literal/if/s and <literal/else/s are implemented in the LOGIC
   code. The <literal/if/ statement is a conditional branch where the branch is
   taken if the condition is not met, while the <literal/else/ statement is a
   nonconditional jump. If a 0xFE code appears in the middle of some AGI
   code and wasn't actually originally coded as an <literal/else/, then it was
   most likely a <literal/goto/ statement.
</para>

<sect2><title>The <literal/said/ test command</title>
<para>
   The above assembly language code does raise a very important point.
   The <literal/said/ command can have a variable number of arguments. Its
   code is 0x0E, and the byte following this byte gives the number of
   two byte words that follow as parameters.

</para><para>
   Examples:
</para><para>

<programlisting>
if (said(marble))                          FF 0E 01 1E 01 FF
if (said( open, door))                     FF 0E 02 37 02 73 00 FF
</programlisting>

</para><para>
   In the above examples, the values 0x011E, 0x0237, and 0x0073 are just
   random word numbers that could stand for the words given.
</para>

<sect2><title>Inner loops</title>
<para>
   At first I almost totally discarded the existence of loops in the AGI
   code because it seemed to me that execution of the LOGIC file
   continually looped. Loop code like ``while'', ``do..while'', and ``for''
   statements wouldn't be needed because you could just use a variable to
   increment with each pass and an <literal/if/ statement to test the value of
   the variable and take action if it was withing the desired range.

</para><para>
   Example:
</para><para>
<programlisting>
if (greatern(30, 45) && lessn(30, 55)) {
    print("You're in the hot zone!);
    increment(30);
}
</programlisting>

</para><para>
   I have found evidence of this sort of thing taking place which means
   that they must loop over continuously. I don't know whether this is
   something that the interpreter does itself or whether it is part of
   the AGI code, e.g. at the end of one LOGIC file it calls another which
   then calls the first one again. With the existence of the conditional
   branching and unconditional branching nature of the <literal/if/ and <literal/else/
   statement, it is easy to see that some of the structures such as
   ``do..while'' can infact be coded into LOGIC code.

</para><para>
   Example:
</para><para>

<programlisting>
FF FD 0D FF 03 00 FE F7 FF

do {
} while (!havekey);
</programlisting>

</para><para>
   The above translation is a simple one which is taken from SQ2. The
   value 0xFFF7 is the twos complement notation for -9 which is the exact
   branching value to take the execution back to the start of the <literal/if/
   statement. If the above example had AGI code between the 0x00 and the
   0xFE, then there would be code within the brackets of the ``do..while''
   structure. I don't know whether the original AGI coders used these
   statements or used <literal/goto/ statements to achieve the same result.
</para>

<sect2><title>New information on LOGIC interpretation</title>
<para>
   It has now come to light that <literal/logic.0/ is run over and over again with
   each interpretation cycle. The other LOGICs that have been loaded will
   only get executed if <literal/logic.0/ calls them directly or indirectly (i.e.
   LOGICs called from <literal/logic.0/ can call other LOGICs and so on).

</para><para>
   I have also become aware that code 0x00 can basically be thought of
   as the command <literal/return/. If <literal/logic.0/ calls another logic, the
   execution will return to <literal/LOGIC.0/ when the 0x00 code is encountered.

</para><para>
   It is also possible to set the entry point for a LOGIC file. The
   <literal/set.scan.start/ command makes the entry point of the LOGIC file being
   executed equal to the position of the command following
   <literal/set.scan.start/. This means that the next time the LOGIC file is
   executed, execution begins at that point. The <literal/reset.scan.start/
   command sets the entry point back to the start of the LOGIC.
</para>


<sect1 id="logiccode"><title>Sample code</title>
<para>
   <simplelist>
    <member><filename/logic.c/
      by Lance Ewing: loads LOGIC resources into LOGICFile structure
    <member><filename/logic.h/
      by Lance Ewing: header file for <filename/logic.c/
    <member><filename/agifiles.c/
      by Lance Ewing: routines to handle loading of resources
    <member><filename/agifiles.h/
      by Lance Ewing: header file for <filename/agifiles.c/
    <member><filename/agicommands.pas/
      by Peter Kelly: Delphi/Pascal unit with a list of all commands and
      argument types
   </simplelist>
</para>
</sect1>

</chapter>


<chapter id="picture"><title>PICTURE resources</title>
<para>
   Lance Ewing, updated by Claudio Matsuoka based on the AGDS documentation,
   22 May 1999.
</para>

<sect1 id="picintro"><title>Introduction</title>
<para>
   PICTURE is usually used for background pictures and other full
   screen images. Pictures in AGI and early SCI games are not stored as a
   complete picture. Instead they're constructed and stored as
   coordinates and vectors. Vectors give the instructions for drawing a
   picture and they have the advantage of taking less space than would a
   bit image of a complete picture.

</para><para>
   Pictures are drawn using nine different drawing actions. These actions
   are given values from 0xF0 to 0xFA and are defined as follows:

</para><para>
   <simplelist>
    <member>0xF0: Change picture colour and enable picture draw.
    <member>0xF1: Disable picture draw.
    <member>0xF2: Change priority colour and enable priority draw.
    <member>0xF3: Disable priority draw.
    <member>0xF4: Draw a Y corner.
    <member>0xF5: Draw an X corner.
    <member>0xF6: Absolute line (long lines).
    <member>0xF7: Relative line (short lines).
    <member>0xF8: Fill.
    <member>0xF9: Change pen size and style.
    <member>0xFA: Plot with pen.
    <member>0xFB--0xFE: Unused in most AGI games.
   </simplelist>
</para><para>

   Note: SQ2 appears to be the only AGI version 2 game that uses 0xF9 and
   0xFA. The AGI interpreters before this game will most likely not
   support these two drawing actions.

</para><para>
   In the following detailed descriptions of each action, the word
   ``picture'' refers to the screen that is seen by the player when they
   play the AGI screen. The word ``priority'' refers to the screen that is
   held in memory and contains control information invisible to the
   player. As a picture is drawn, both screens are updated depending on
   whether drawing is enabled from each screen.
</para>
</sect1>

<sect1 id="picfmt"><title>PICTURE resource format</title>
<para>
   The PICTURE data can be processed byte by byte. Whenever a value of
   0xF0 or greater is encountered, the action is changed to the one given
   and then all the bytes between this code and the next action code are
   arguments to this action. Half of the actions have a set number of
   arguments, the other half can have an unlimited number of arguments.
   The special code 0xFF says that the end of the picture data has been
   reached. All other values are used by the various drawing actions to
   tell them what to draw and will always be less than 0xF0.
</para>

<sect2><title>Color palette</title>
<para>
   The following colors are used in AGI. RGB is given in 6 bit values.
</para><para>
   <programlisting>
Code  Color             R    G    B
----- ---------------- ---- ---- ----
  0   black            0x00 0x00 0x00
  1   blue             0x00 0x00 0x2A
  2   green            0x00 0x2A 0x00
  3   cyan             0x00 0x2A 0x2A
  4   red              0x2A 0x00 0x00
  5   magenta          0x2A 0x00 0x2A
  6   brown            0x2A 0x15 0x00
  7   light grey       0x2A 0x2A 0x2A
  8   dark drey        0x15 0x15 0x15
  9   light blue       0x15 0x15 0x3F
 10   light green      0x15 0x3F 0x15
 11   light cyan       0x15 0x3F 0x3F
 12   light red        0x3F 0x15 0x15
 13   light magenta    0x3F 0x15 0x3F
 14   yellow           0x3F 0x3F 0x15
 15   white            0x3F 0x3F 0x3F
   </programlisting>
</para>

<sect2><title>General actions</title>
<para>
   <variablelist>
    <varlistentry><term/0xF0: Change picture colour and enable picture draw/
     <listitem><para>
       Changes the current drawing colour for the picture screen to that
       given by the one and only argument, and enables subsequent actions
       to draw to the picture screen.
     </para><para>
       Initially all pixels of the background are white and have priority 4.
       After this command is executed, all the subsequent graphic commands
       draw using the colour set by the command.
     </para><para>
       Example: <literal/F0 0D/ changes picture screen drawing colour to
       light magenta and enables drawing to the picture screen.
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF1: Disable picture draw/
     <listitem><para>
       Disables drawing to the picture screen. This is done whenever there
       is something which only needs to be drawn on the priority screen
       such as the control lines. There are no arguments for this action.
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF2: Change priority colour and enable priority draw/
     <listitem><para>
       Changes the current drawing colour for the priority screen to that
       given by the one and only argument, and enables subsequent actions
       to draw to the priority screen.
     </para><para>
       Example: <literal/F0 04/ changes priority screen drawing colour to
       red and enables drawing to the priority screen.
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF3: Disable priority draw/
     <listitem><para>
       Disables drawing to the priority screen. This is done whenever there
       is something which only needs to be drawn on the picture screen such
       as the finer details of the picture. There are no arguments for this
       action.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>The corner action</title>
<para>
   I call the following two actions the ``corner actions'' because they do
   not draw diagonal lines at all but instead alternate from horizontal
   line to vertical line (or vice versa) giving rise to a series of right
   angled corners.
<programlisting>
       _________
      |         |    B__
      |         |_____  |
      |               |_|
      A
</programlisting>
   The above diagram shows the type of pattern created. If A were the
   starting coordinate, then it would be called a Y corner. This is
   because the Y or vertical component is changed first. If B were the
   starting coordinate, then it would be called an X corner. This is
   because the X or horizontal component is changed first.

   <variablelist>
    <varlistentry><term/0xF4: Draw a Y corner/
     <listitem><para>
       The first two arguments for this action are the coordinates of the
       starting position on the screen in the order x and then y. The
       remaining arguments are in the order y1, x1, y2, x2, ...
     </para><para>
       Note that the y component is the first to be changed and also note
       that this action does not necessarily end on either component, it just
       ends when the next byte of 0xF0 or above is encountered. A line is
       drawn after each byte is processed.
     </para><para>
       Example: <literal/F4 16 16 18 12 16 F?/
     </para><para>
<programlisting>
 (0x12, 0x16)     (0x16, 0x16)
             E   S                  S = Start
             X   X                  E = End
             XXXXX                  X = normal piXel
 (0x12, 0x18)     (0x16, 0x18)
</programlisting>
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF5: Draw an X corner/
     <listitem><para>
       The first two arguments for this action are the coordinates of the
       starting position on the screen in the order x and then y.
       The remaining arguments are in the order x1, y1, x2, y2, ...
     </para><para>
       Note that the x component is the first to be changed and also note
       that this action does not necessarily end on either component, it just
       ends when the next byte of 0xF0 or above is encountered. A line is
       drawn after each byte is processed.
     </para><para>

       Example: <literal/F5 16 16 18 12 16 F?/
     </para><para>
<programlisting>
  (0x16, 0x12)   (0x18, 0x12)
              EXX
                X            S = Start
                X            E = End
                X            X = normal piXel
              SXX
  (0x16, 0x16)   (0x18, 0x16)
</programlisting>
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF6: Absolute line/
     <listitem><para>
       Draws lines between points. The first two arguments are the
       starting coordinates. The remaining arguments are in groups of two
       which give the coordinates of the next location to draw a line to.
       There can be any number of arguments but there should always be an
       even number.
     </para><para>
       Example: <literal/F6 30 50 34 51 38 53 F?/
     </para><para>
       This sequence draws a line from (48, 80) to (52, 81), and a line from
       (52, 81) to (56, 83).
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF7: Relative line/
     <listitem><para>
       Draw short relative lines. By relative we mean that the data
       gives displacements which are relative from the current location.
       The first argument gives the standard starting coordinates. All the
       arguments which follow these first two are of the following format:
     </para><para>
<programlisting>
+---+-----------+---+-----------+
| S |   Xdisp   | S |   Ydisp   |
+---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+---+---+---+---+---+---+---+---+
</programlisting>
     </para><para>
       This gives a displacement range of between -7 and +7 for both the X
       and the Y direction.
     </para><para>
       Example: <literal/F7 10 10 22 40 06 CC F?/
     </para><para>
<programlisting>
              S
               +              S = Start
                X+++X         X = End of each line
                    +         + = pixels in each line
                E   +         E = End
                 +  +
                  + +         Remember that CC = (x-4, y-4).
                   ++
                    X
</programlisting>
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xF8: Fill/
     <listitem><para>
       Flood fill from the locations given. Arguments are given in
       groups of two bytes which give the coordinates of the location to
       start the fill at. If picture drawing is enabled then it flood fills
       from that location on the picture screen to all pixels locations that
       it can reach which are white in colour. The boundary is given by any
       pixels which are not white.
     </para><para>
       If priority drawing is enabled, and picture drawing is not enabled,
       then it flood fills from that location on the priority screen to all
       pixels that it can reach which are red in colour. The boundary in this
       case is given by any pixels which are not red.
     </para><para>
       If both picture drawing and priority drawing are enabled, then a flood
       fill naturally enough takes place on both screens. In this case there
       is a difference in the way the fill takes place in the priority
       screen. The difference is that it not only looks for its own boundary,
       but also stops if it reaches a boundary that exists in the picture
       screen but does not necessarily exist in the priority screen.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Brush style</title>
<para>
   Drawing actions 0xF9 and 0xFA deal with plotting patterns. Most
   drawing programs have options to change the size, and style of the pen
   or brush. The style covers different shapes and textures. AGI PICTURES
   provide these tools as well.
</para><para>

   <variablelist>
    <varlistentry><term/0xF9: Change pen size and style/
     <listitem><para>
       Change the characteristics of the pattern plotted by drawing
       action 0xFA. If bit 5 is not set, then the pattern is a solid shape.
       If bit 5 is set, then the pattern is like a splatter. Bit 4 selects
       whether the brush is a circle or a rectangle. Bits 0-2 give the size
       of the shape which will be a value from 0 to 7. These characteristics
       appear to only affect drawing action 0xFA.
     </para><para>
       The default brush is a solid circle or rectangle of size 0, which
       should be used until an 0xF9 action is encountered.
     </para><para>
<programlisting>
           ___ ___ ___ ___ ___ ___ ___ ___
          | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
          |___|___|___|___|___|___|___|___|
                    |   |       |___|___|
 0 = Solid _________|   |           |
 1 = Splatter           |           |______ Pen size
                        |
 0 = Circle ____________|
 1 = Rectangle

   RECTANGLE SIZES
 X XX XXX XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX         size+1
 0 X* XXX XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX       _____________
   XX X*X XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
   1  XXX XX*X XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
      XXX XXXX XX*XX XXXXXX XXXXXXX XXXXXXXX      |             |
       2  XXXX XXXXX XXX*XX XXXXXXX XXXXXXXX      |             | (size*2)+1
          XXXX XXXXX XXXXXX XXX*XXX XXXXXXXX      |             |
           3   XXXXX XXXXXX XXXXXXX XXXX*XXX      |             |
               XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
                 4   XXXXXX XXXXXXX XXXXXXXX      |             |
                     XXXXXX XXXXXXX XXXXXXXX      |             |
  WHERE                5    XXXXXXX XXXXXXXX      |_____________|
                            XXXXXXX XXXXXXXX
    X = agi pixels             6    XXXXXXXX         IN GENERAL
    * = coordinates given           XXXXXXXX
        for plot                       7

   CIRCLE SIZES
 X XX  X   XX    X     XX     XXX      XX            size+1
 0 X* XXX  XX   XXX   XXXX   XXXXX    XXXX         _____________
   XX X*X XXXX XXXXX  XXXX   XXXXX   XXXXXX       |             |
   1  XXX XX*X XXXXX  XXXX   XXXXX   XXXXXX       |             |
       X  XXXX XX*XX XXXXXX XXXXXXX  XXXXXX       |             |
       2   XX  XXXXX XXX*XX XXXXXXX XXXXXXXX      |             | (size*2)+1
           XX  XXXXX XXXXXX XXX*XXX XXXXXXXX      |             |
           3    XXX   XXXX  XXXXXXX XXXX*XXX      |             |
                 X    XXXX  XXXXXXX XXXXXXXX      |             |
                 4    XXXX   XXXXX  XXXXXXXX      |             |
                       XX    XXXXX   XXXXXX       |             |
  WHERE                5     XXXXX   XXXXXX       |_____________|
                              XXX    XXXXXX
    X = agi pixels             6      XXXX           IN GENERAL
    * = coordinates given              XX
        for plot                       7
</programlisting>
     </para><para>
       To implement this you will need to store bitmaps for each of these of
       these circles.
     </para></listitem>
    </varlistentry>

    <varlistentry><term/0xFA: Plot with pen/
     <listitem><para>
       Plots points with the pen defined with drawing action 0xF9.
       If the pen style is set to solid, then the arguments are just a list
       of coordinates to be plotted. If the pen style is set to splatter
       brush (texture), then the arguments are in groups of three with the
       first argument giving the texture number and the other two giving the
       coordinates. The texture number determines in what way the pixels will
       splatter within the defined shape. Bits 1-7 seem to give the actual
       texture number. Bit 0 does not do anything. This means that there are
       120 different pixel splatter bitmaps (values 0xF0 and above can not be
       used as they are treated as drawing actions). There is actually only
       32 bytes of texture data which means that most of the splatter bitmaps
       overlap.
     </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Texture data</title>
<para>
   All of the data needed for the 128 texture patterns is included in the
   following 32 bytes (256 bits):
</para><para>
<programlisting>
0x20, 0x94, 0x02, 0x24, 0x90, 0x82, 0xa4, 0xa2,
0x82, 0x09, 0x0a, 0x22, 0x12, 0x10, 0x42, 0x14,
0x91, 0x4a, 0x91, 0x11, 0x08, 0x12, 0x25, 0x10,
0x22, 0xa8, 0x14, 0x24, 0x00, 0x50, 0x24, 0x04
</programlisting>

</para><para>
   The only difference between each texture pattern is its starting
   position within this table. The following table gives the starting bit
   position in the above table for each texture pattern number given as
   the first argument of each pen plot:
</para><para>
<programlisting>
0x00, 0x18, 0x30, 0xc4, 0xdc, 0x65, 0xeb, 0x48,
0x60, 0xbd, 0x89, 0x04, 0x0a, 0xf4, 0x7d, 0x6d,
0x85, 0xb0, 0x8e, 0x95, 0x1f, 0x22, 0x0d, 0xdf,
0x2a, 0x78, 0xd5, 0x73, 0x1c, 0xb4, 0x40, 0xa1,
0xb9, 0x3c, 0xca, 0x58, 0x92, 0x34, 0xcc, 0xce,
0xd7, 0x42, 0x90, 0x0f, 0x8b, 0x7f, 0x32, 0xed,
0x5c, 0x9d, 0xc8, 0x99, 0xad, 0x4e, 0x56, 0xa6,
0xf7, 0x68, 0xb7, 0x25, 0x82, 0x37, 0x3a, 0x51,
0x69, 0x26, 0x38, 0x52, 0x9e, 0x9a, 0x4f, 0xa7,
0x43, 0x10, 0x80, 0xee, 0x3d, 0x59, 0x35, 0xcf,
0x79, 0x74, 0xb5, 0xa2, 0xb1, 0x96, 0x23, 0xe0,
0xbe, 0x05, 0xf5, 0x6e, 0x19, 0xc5, 0x66, 0x49,
0xf0, 0xd1, 0x54, 0xa9, 0x70, 0x4b, 0xa4, 0xe2,
0xe6, 0xe5, 0xab, 0xe4, 0xd2, 0xaa, 0x4c, 0xe3,
0x06, 0x6f, 0xc6, 0x4a, 0x75, 0xa3, 0x97, 0xe1
</programlisting>
</para><para>

   Important note: When drawing the brush, if the bit position in the
   texture data (first table above) reaches 255, it should loop round to
   0, instead of looping at 256 as you would normally expect. This may be
   because of a bug in the picture drawing code in the interpreter. If
   you loop at 256 then some of the patterns will not be correct.
</para><para>
   When a texture pattern is drawn in the shape of a circle, the texture
   pattern 'fills' the shape of the circle. This diagram will explain
   what I mean:
</para><para>
<programlisting>
   X.XX          X.
   X.X.          XX
   ....         X.X.
   .X.X         ....
   X...         .X.X
   ..X.          X.
   XXXX          ..

 Rectangle     Circle
</programlisting>
</para><para>

   The corner pixels of the circle which aren't part of the circle are
   totally ignored. The circle isn't just a cut out of the equivalent
   rectangle. A bit hard to explain. Look at the source of Showpic for
   more info.
</para>
</sect1>

<sect1 id="picimpl"><title>Implementation</title>
<para>
   Writing code to interpret the picture data in order to draw the
   picture on the screen is easier said than done. It turns out that you
   have to have a line drawing algorithm which exactly matches the one
   that Sierra uses. A pixel out of place can mean that a fill overflows
   or doesn't work at all.
</para><para>
   You will also have to write your own fill routine because not many of
   the standard fill routines can stop at a multicoloured boundary. You
   are also dealing with two screens both of which will probably be
   stored in memory somewhere rather than the screen.
</para><para>
   The picture screen has a starting state of being completely white. The
   priority screen has starting state of being completely red. It is
   important that you set all pixels in each screen to the relevant
   background colour else you won't get the right result.
</para>

<sect2><title>General guidelines</title>
<para>
   The screen mode used by the AGI games is the 320x200x16 standard EGA
   mode. However, all graphics is designed to be shown on a 160x200x16
   mode. This was apparently the resolution that the original PCjr
   interpreter used. They stuck with it when they started supporting EGA
   and thus have a situation where each AGI pixel has a width of two
   normal 320x200 pixels.
</para>

<sect2><title>Line drawing</title>
<para>
   This routine is relatively straight forward and I suggest that you
   look at it and try to understand it or you'll be having headaches
   trying to get you're routines acting like the Sierra ones. Basically
   it draws a line from (x1, y1) to (x2, y2) using a function called pset
   to draw a single pixel. The function <function/round()/ is what makes
   it act like Sierra's. Essentially when it comes down to a 50:50 decision
   about where to put a pixel, the direction in which the line is being drawn
   is taken into account. I've only noticed one pixel out of place in all
   the screens I've tried Showpic on which makes me believe its probably
   not a fault in this algorithm, but somewhere else in the code.
</para><para>
   Note that Sarien (see <xref linkend="otheragi">)
   use a more efficient line drawing algorithm written by Joshua Neal and
   Stuart George.
</para><para>
<programlisting>
int round(float aNumber, float dirn)
{
   if (dirn < 0)
      return ((aNumber - floor(aNumber) <= 0.501) ?
	floor(aNumber) : ceil(aNumber));
   return ((aNumber - floor(aNumber) < 0.499) ?
	floor(aNumber) : ceil(aNumber));
}

void drawline(word x1, word y1, word x2, word y2)
{
   int height, width;
   float x, y, addX, addY;

   height = (y2 - y1);
   width = (x2 - x1);
   addX = (height==0? height:(float)width/abs(height));
   addY = (width==0? width:(float)height/abs(width));

   if (abs(width) > abs(height)) {
      y = y1;
      addX = (width == 0? 0 : (width/abs(width)));
      for (x=x1; x!=x2; x+=addX) {
         pset(round(x, addX), round(y, addY));
         y+=addY;
      }
      pset(x2,y2);
   }
   else {
      x = x1;
      addY = (height == 0? 0 : (height/abs(height)));
      for (y=y1; y!=y2; y+=addY) {
         pset(round(x, addX), round(y, addY));
         x+=addX;
      }
      pset(x2,y2);
   }
}
</programlisting>
</para>

<sect2><title>Flood filling</title>
<para>
   I have discovered that using a queue in a flood fill routine works
   quite well. It is also the easiest method to understand as far as I'm
   concerned. I just thought about what needed to be done and this method
   took shape.
</para><para>
   Basically you start at a particular location. If its the desired
   background colour (white or red depending on the screen), then set
   that pixel. You then check the pixels immediately up, left, down, and
   right to see if they are of the desired background colour. If they
   are, store them in the queue. You then retrieve the first pixel
   position from the queue and repeat the above steps.
</para>
</sect1>

<sect1><title>Using higher resolution modes</title>
<para>
   I've often wondered if it would be possible to show PICTUREs in a
   higher resolution, for example, 640x400. Since the data is stored as
   vectors, it should be possible to multiply all the x components by
   four and all the y components by two and then draw the lines. This
   would give less blocky pictures. There would be a number of problems
   to overcome. Firstly, the fill action (or tool) may cause problems
   because pixels could be in the wrong places. There will also be a need
   to draw end pixels of a line with a width of four so that there are no
   holes for the flood fill to flow out of.
</para>
</sect1>

<sect1><title>Sierra's picture editor</title>
<para>
   The picture editor that Sierra used back in the vector picture days
   was much like a CAD program. I've seen a few photos of it in ``The
   Official Book of King's Quest''. It has a status bar at the top which
   gives the current tool being used (Line, Fill, etc), the current X and
   Y locations, and four others which I explain below.

</para><para>
   Status bar examples:
<programlisting>
Tool:Line V:8 P:A C:o X=249 Y=89 Pri:5
Tool:Fill V:B P:0 C:B X=96 Y=99 Pri:6
Tool:Line V:A P:o C:o X=199 Y=55 Pri:2
</programlisting>
</para><para>
   <literal/o/ = off (or disabled)
</para><para>
   <literal/Pri/ looks like it could be giving the current priority band
   that the cursor location is in. The above status lines are for the SCI
   Picture Editor. I ran these values past SQ3 and the values given for
   <literal/Pri/ are indeed the values of the priority band at the
   locations given.
</para><para>
   I think that <literal/V/, <literal/P/, and <literal/C/ refer to the
   colours being used on the three different screens (SCI games have a
   separate screen for the control lines rather than having both the
   priority bands and control lines on the same screen. This is why there
   were three screens and not the two that we are used to in AGI games).
   This would mean that <literal/V/ = Visual, <literal/P/ = Priority and
   <literal/C/ = Control.
</para><para>
   In an AGI Picture Editor, there would only be the Visual screen and
   the Priority screen. The picture editor would obviously be able to
   switch between the two screens. I've also noticed that the early
   vector based SCI picture editor supports a feature which removes solid
   colours (Fills) with a single keystroke and I presume another
   keystroke puts them back. When the fills have been removed, they are
   represented as a tiny cross. Apparently removing the solid colours
   makes it easier to add small details like flowers.
</para>
</sect1>

<sect1 id="piccode"><title>Sample code</title>
<para>

   <simplelist>
    <member><filename/picv3-v2.c/
       by Lance Ewing: converts version 3 pictures to version 2 pictures
    <member><filename/showpic.c/
       by Lance Ewing: displays pictures
   </simplelist>
</para>
</sect1>

</chapter>


<chapter id="view"><title>VIEW resources</title>
<para>
  Peter Kelly, updated by Claudio Matsuoka, 22 May 1999.
</para>

<sect1><title>Introduction</title>
<para>
   View resources contain some of the graphics for the game. Unlike the
   picture resources which are full-screen background images, view
   resources are smaller <emphasis/sprites/ used in the game, such as
   animations and objects. They are also stored as bitmaps, whereas
   pictures are stored in vector format.
</para><para>
   Each view resource consists of one or more <emphasis/loops/. Each loop
   in the resource consists of one or more <emphasis/cels/ (frames).
   Thus several animations can be stored in one view, or a view can just
   be used for a single image. The maximum number of loops supported by
   the interpreter is 255 (0-254) and the maximum number of cels in each
   is 255 (0-254).
</para>
<warning>
  <para>
    Except when noted otherwise, 16 bit data is stored in little endian
    format (i.e. the value has the least significant byte stored first, and
    the most significant byte stored second). Most word values in AGI are
    stored like this, but not all.
  </para>
</warning>

<sect1><title>VIEW resource format</title>

<sect2><title>View header (7+ bytes)</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Unknown (always seems to be either 1 or 2)
  1   Unknown (always seems to be 1)
  2   Number of loops
 3-4  Position of description (more on this later)
      Both bytes are 0 if there is no description
 5-6  Position of first loop
 7-8  Position of second loop (if any)
 9-10 Position of third loop (if any)
 ...  ...
----- -----------------------------------------------------------
   </programlisting>
</para>
<warning>
   <para>
    Two of these loop references CAN point to the same place. This
    is done when you want to use mirroring (more on this later).
   </para>
</warning>

<sect2><title>Loop header (3+ bytes)</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Number of cels in this loop
 1-2  Position of first cel, relative to start of loop
 3-4  Position of second cel (if any), relative to start of loop
 5-6  Position of third cel (if any), relative to start of loop
----- -----------------------------------------------------------
   </programlisting>
</para>

<sect2><title>Cel header (3 bytes)</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Width of cel (remember that AGI pixels are 2 normal EGA
      pixels wide so a cel of width 12 is actually 24 pixels
      wide on screen)
  1   Height of cel
  2   Transparency and cel mirroring
----- -----------------------------------------------------------
   </programlisting>
</para><para>
   The first four bits of this byte tell the interpreter how to handle
   the mirroring of this cel (explained later).
</para><para>
   The last four bits represent the transparent color. When the cel is
   drawn on the screen, any pixels of this color will show through to the
   background.
</para><para>
   All cels have a transparent color, so if you want an opaque cel then
   you must set the transparent color to one that is not used in the cel.
</para>

<sect2><title>Cel data</title>
<para>
   The actual image data for each cel is stored using RLE (run length
   encoding) compression. This means that instead of having one byte for
   each single pixel (or 1/2 byte as you would use for 16 colors), each
   byte specifies how many pixels there are to be in a row and what
   colour they are. I will refer to these groups of pixels as ``chunks''.
</para><para>
   This method of compression is not very efficient if there is a lot of
   single pixels in the image (e.g. a view showing static on a TV
   screen), but in most cases it does save a fair amount of space.
</para><para>
   Each line (not to be confused with a chunk) in the cel consists of
   several bytes of pixel data, then a 0 to end the line. Each byte of
   pixel data represents one chunk. The first four bits determine the
   colour, and the last four bits determine the number of pixels in the
   chunk.
</para><para>
   Example: <literal/AX BY CZ 00/
</para><para>
   This line will have:
   <simplelist>
    <member>X pixels of colour A (<literal/AX/)
    <member>Y pixels of colour B (<literal/BY/)
    <member>Z pixels of colour C (<literal/CZ/)
    <member>(then that will be the end of the line) (<literal/00/)
   </simplelist>
</para><para>
   If the color of the last chunk on the line is the transparent color,
   there is no need to store this. For example, if C was the transparent
   color in the above example, you could just write <literal/AX BY 00/.
   This also saves some space.
</para>

<sect2><title>Mirroring</title>
<para>
   Mirroring is when you have one loop where all the cels are a mirror
   image of the corresponding cels in another loop. Although you could do
   this manually by drawing one loop and then copying and pasting all the
   cels to another loop and flipping them horizontally, AGI views provide
   the ability to have this done automatically -- you can draw one loop,
   and have another loop which is set as a mirror of this loop. Thus,
   when you change one loop you change the other. This is useful if you
   have an animation of a character walking left and right -- you just
   draw the right-walking animation and have another loop a mirror of
   this which will have the left-walking animation. Another advantage of
   cel mirroring is to save space -- it doesn't make much difference these
   days, but back when AGI was written the games were designed to run on
   256K systems which meant that memory had to be used as efficiently as
   possible.
</para><para>
   Mirroring is done by having both loops share the same cel data -- you
   saw above that you can have two loop references pointing to the same
   place. The first four bits of the 3rd byte in the header of each cel
   tell the interpreter what is mirrored:
</para><para>
   <programlisting>
 Bit  Meaning
----- -----------------------------------------------------------
  0   Specify whether or not this cel is mirrored.
 1-3  Specify the number of the loop (from 0-7) which is NOT
      mirrored
----- -----------------------------------------------------------
   </programlisting>

</para><para>
   When the interpreter goes to display a loop, it looks at the bit 0 and
   sees if it is mirrored or not. If it is, then it checks the loop
   number -- if this is NOT the same as the current loop, then it flips
   the cel before displaying it.
</para>

<para>
   If you have a cel that is mirrored, you need to ensure that the number
   of bytes the cel takes up in the resource is greater than or equal to
   the number of bytes that the flipped version of the cel would take up.
   The reason for this is that the interpreter loads the view resource
   into memory and works with that for displaying cels, rather than
   decoding it and storing it in memory as a non-compressed bitmap. I
   assume that it doesn't even bother ``decoding'' it as such -- it probably
   just draws the chunks of color on the screen as they are. When it has
   to display the flipped version of a cel, instead of storing the
   flipped cel somewhere else in memory, it flips the version that is
   there. So in memory you have the view resource that was read from the
   file, except that some of the cels have been changed. This is why
   there is mirroring information stored in each cel -- the interpreter
   has to know what cels have been changed. When it flips a cel, it
   changes the loop number in the 3rd byte of the cel header to the
   number of the loop it is currently displaying the cel for. So when it
   looks at this number the next time for a different loop, it will see
   that the cel is not the right way round for that loop and mirror it
   again.
</para><para>
   This process seems very inefficient to me. I don't know why it doesn't
   just draw the chunks of color on the screen back to front. But since
   it does it this way we have to make sure that there is enough room for
   the flipped cel.
</para><para>
   It seems that not all versions of the interpreter require this,
   however -- I was working with version 2.917 when I was testing this
   out, but I noticed that versoin 2.440 did not require this. I will
   attempt to try this with all different interpreters and provide a list
   of which ones use this in a future version of this document. But it is
   best to put these bytes in just in case, as the views will still work
   regardless.
</para>

<sect2><title>Description</title>
<para>
   All the views in the game that are used as close-ups of inventory
   members have a description. When a player ``examines'' these (in some
   games you can select ``see object'' from the menu), they will see the
   first cel of the first loop of this view and the description of the
   object they are examining. This is brought up using the <literal/show.obj/
   command.
</para><para>
   The description is stored in plain text, and terminated by a null
   character. Lines are separated by an 0x0A.
</para>

<sect1><title>VIEW table</title>
<para>
  Lance Ewing, 31 August 1997.
</para><para>
   Firstly we should note that there is a difference between a VIEW and a
   VIEW object. A VIEW is a collection of animated sequences that are
   stored in a VOL file. When a view is loaded into memory, it is then
   connected to one or more VIEW table entries (see below) that store
   information on what the interpreter calls objects (don't confuse this
   with inventory members). An object is an animated sprite that is
   currently being controlled by the interpreter. With each
   interpretation cycle, the state of each object in the VIEW table is
   updated and, if required, updated on the screen. It is therefore
   possible to have five or more hungry crocodiles swimming in a moat
   each which have there own VIEW table entries, all of which point to
   the same VIEW data.
</para><para>
   View objects appear to have the following properties:
</para><para>
   <simplelist>
    <member>x position
    <member>y position
    <member>current view
    <member>current loop
    <member>current cel
    <member>priority
    <member>cycle time (1/n gives the fraction of the maximum speed)
    <member>step time (1/n gives the fraction of the maximum speed)
    <member>x size (in pixels)
    <member>y size (in pixels)
    <member>step size
    <member>direction
    <member>number of loops
    <member>number of cels
   </simplelist>
</para><para>
   There are probably other properties that aren't listed here which they
   also possess. In an object oriented environment such as SCI, these
   properties are stored as instance variables (or selectors) as part of
   the object. Since AGI isn't object oriented, we would expect to find
   some sort of VIEW table stored in memory which holds theses properties
   within it. In SQ2 this VIEW table consisted of 43 byte entries. Most
   commands that deal with VIEW objects will make adjustments to the data
   in the entry for the relevant object.
</para>

<sect2><title>View table entry</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
00-01 step.time (stored twice)
  02  ??	entry number
03-04 x position
05-06 y position
  07  current view
08-09 pointer to start of view data.
  0A  current loop
  0B  number of loops
0C-0D pointer to start of loop data
  0E  current cel
  0F  number of cels
10-11 pointer to start of cel data
12-13 pointer to start of cel data (same as above)
14-15 ??
16-17 copy of x position
18-19 copy of y position
1A-1B x size
1C-1D y size
  1E  step size
1F-20 cycle time (stored twice)
  21  direction (heading)
      0 = stationary, 1 = north, 2 = north/east, 3 = east,
      4 = south/east, 5 = south, 6 = south/west, 7 = west,
      8 = north/west
  22  0 = normal.motion, 1 = wander, 2 = follow.ego, 3 = move.obj
  23  0 = normal.cycle, 1 = end.of.loop, 2 = reverse.loop,
      3 = reverse.cycle
  24  priority
25-26 View flags (see below)
----- -----------------------------------------------------------
   </programlisting>
</para><para>
View flags:
</para><para>
   <programlisting>
 Bit  Meaning
----- -----------------------------------------------------------
   0  ??
   1  0 = observe blocks, 1 = ignore blocks
   2  0 = priority released, 1 = fixed priority
   3  0 = observe horizon, 1 = ignore horizon
   4  ??
   5  0 = stop cycling, 1 = cycling.
   6  ??
   7  ??
   8  1 = view on water
   9  0 = observe objects, 1 = ignore objects
  10  ??
  11  1 = view on land
  12  ??
  13  0 = loop released, 1 = loop fixed
  14  ??
  15  ??
  27  ?? (storage for some view related command parameters)
  28  ?? (storage for some view related command parameters)
  29  ?? (storage for some view related command parameters)
  2A  ?? (storage for some view related command parameters)
----- -----------------------------------------------------------
   </programlisting>

</para>
<warning>
  <para>
    The above format structure is simply the way in which Sierra's
    AGI interpreter stores information about VIEW objects. In attempting
    to write an AGI interpreter, you would not have to restrict yourself
    to this format, just as long as you store this information in some
    manner that the interpreter can have access to.
  </para>
</warning>
</sect1>

<sect1><title>VIEW test commands</title>
<para>
   Lance Ewing, 31 August 1997.
</para><para>

   There are four LOGIC test commands that are to do with views. These are:
</para><para>
   <programlisting>
obj.in.box()
posn()
right.posn()
centre.posn()
   </programlisting>
</para><para>

   All of these commands are for testing whether a VIEW object is within
   a given rectangle on the screen. All of them take the same parameters
   and apart from a slight change in each case, they do exactly the same
   thing and even share about 95% of their code. The general form is the
   following:
</para><para>
   <programlisting>
command (VIEW object num, left, top, right, bottom)
   </programlisting>
</para><para>

   A VIEW has a position stored in its VIEW table entry that says where
   abouts on the screen the view object is at the present time. The
   problem with this position is saying which pixel is the position pixel
   for an object that takes up usually over a hundred pixels. Okay, you
   might say that most views are actors or props that sit on the ground
   and therefore the bottom row of pixels will give you a y position.
   This is a good argument, but now you need to say which of these pixels
   in the bottom row is the actual position. Sierra must have faced this
   problem or they wouldn't have provided four commands for achieving
   essentially the same thing.
</para><para>

   By default the position hot spot in a VIEW is the bottom left pixel.
</para><para>
   <programlisting>
.........
.........
.........
.........          X = position hot spot.
.........
.........
X........
   </programlisting>

</para><para>
   This is the location that gets stored in the VIEW object table. The
   difference between the test commands given above is how they adjust
   the x position before testing it against the rectangle border lines.
   <function/posn/ leaves the x position as it is (left side).
   <function/right.posn/ adds (xsize - 1) to the x position giving the
   right side. <function/center.posn/ adds (xsize / 2) to the x position
   giving the centre. <function/obj.in.box/ tests both the left and right
   sides which essentially tests whether the whole bottom row of pixels
   is in the ``box''.

</para><para>
   The test is TRUE if
</para><para>
   <programlisting>
(X1 >= left) && (y >= top) && (X2 <= right) && (y <= bottom).
   </programlisting>
</para>
</sect1>

<sect1 id="viewcode"><title>Sample code</title>
<para>
   <simplelist>
    <member><filename/viewview.pas/
      by Peter Kelly: unit from AGIhack that displays VIEWs
   </simplelist>
</chapter>


<chapter id="soundresource"><title>SOUND resources</title>
<para>
   Lance Ewing, updated by Claudio Matsuoka, 22 May 1999.
</para>

<sect1><title>Introduction</title>
<para>
   Most people who think of AGI games remember that they played their
   music and sounds over the PC speaker. What they may not know is that
   all sounds in the MS-DOS, Tandy and Macintosh versions are composed of
   four parts, one which is the melody, two which are accompaniment, and
   the final one being noise. The IBM PC can only play one note at a time
   so all AGI games for the PC play the melody by itself. The Apple IIgs
   version has much more sophisticated sound: 16 channel wavetable based
   MIDI songs for the soundtracks, and digitally sampled PCM sound effects.
</para><para>
   According to Donald B. Trivette, author of ``The Official Book of King's
   Quest'', a year before the IBM PCjr was announced IBM asked Sierra to
   create a game that would show off the new computers color graphics
   capabilities. IBM supplied the company with a prototype Junior, and
   Roberta set to work designing a new type of adventure game. The game
   produced was called King's Quest. This is important because the IBM
   PCjr had a different method of sound generation than the IBM
   compatibles of today. The sound data was stored to make it easy to
   send to the Juniors sound generators. This format appears to have
   remained right through the AGI games up until 1989--90 when SCI took
   over even though the PCjr had long since been surpassed by the 286,
   and 386.
</para>

<sect1><title>Sound in the IBM PCjr</title>
<para>
   The best known source of sound in the Junior is the TI SN76496A sound
   generator chip. This source has four separate sound voices. Three of
   these are tone generators and the fourth is a noise source. All four
   voices have an independent volume control, providing an evenly
   graduated set of 15 volume levels, plus a zero volume (off). Each of
   the three pure voices has an independently selected frequency. The
   noise voice has three preselected frequencies and a fourth option,
   which borrows the frequency of the third pure voice. The data stored
   in the AGI games is designed to be sent to these four voices.
</para>

<sect2><title>The tone generation</title>
<para>
   A tone is produced on a voice by passing the sound chip a 3-bit
   register address and then a 10-bit frequency divisor. The register
   address specifies which voice the tone will be produced on. This is
   done through port 192 on the IBM PCjr by sending it 2 bytes in the
   following format:
</para><para>
<programlisting>
First Byte
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Identifies first byte (command byte)
.  R0 R1 R2 .  .  .  .      Register number in T1 chip (0, 2, 4).
.  .  .  .  F6 F7 F8 F9     4 of 10-bits in frequency count.

Second Byte
7  6  5  4  3  2  1  0

0  .  .  .  .  .  .  .      Identifies second byte (completing byte)
.  X  .  .  .  .  .  .      Unused, ignored.
.  .  F0 F1 F2 F3 F4 F5     6 of 10-bits in frequency count.

Register Addresses:
R0      R1      R2

 0       0       0          Holds voice 1 frequency number.
 0       1       0          Holds voice 2 frequency number.
 1       0       0          Holds voice 3 frequency number.
</programlisting>
 
</para><para>
   The actual frequency produced is the 10-bit frequency divisor given by
   F0 to F9 divided into 1/32 of the system clock frequency (3.579 MHz)
   which turns out to be 111,860 Hz. Keeping all this in mind, the
   following is the formula for calculating the frequency:
</para><para>
<programlisting>
f = 111860 / (((Byte2 & 0x3F) << 4) + (Byte1 & 0x0F))
</programlisting>

</para><para>
   Note: The order of the bytes are reversed for AGI sound data.
</para>

<sect2><title>Attenuation</title>
<para>
   Each voice in the T1 sound chip has an independent sound-level
   control, which is calculated in terms of decibels of attenuation, or
   softening. There are four bits uses to control the volume. These bits,
   labeled A0 through A3, can be set independently or added together to
   produce sixteen volume levels as shown below.
</para><para>
<programlisting>
A0 A1 A2 A3        Value        Attenuation (decibels)

 .  .  .  1          1                    2
 .  .  1  .          2                    4
 .  1  .  .          4                    8
 1  .  .  .          8                   16
 1  1  1  1                           Volume off
</programlisting>

</para><para>
   When a bit is set on, the sound is attenuated (reduced) by a specific
   amount: either 2, 4, 8, or 16 decibels. When all four bits are set on,
   the sound is turned completely off. When all four bits are off, the
   sound is at
   its fullest volume.

</para><para>
   The attenuation is set by sending a byte of the following format to
   the T1 sound chip:
<programlisting>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Identifies first byte (command byte)
.  R0 R1 R2 .  .  .  .      Register number in T1 chip (1, 3, 5, or 7).
.  .  .  .  A0 A1 A2 A3     4 attenuation bits

   Register Addresses:
R0      R1      R2

 0       0       1          Holds voice 1 attenuation.
 0       1       1          Holds voice 2 attenuation.
 1       0       1          Holds voice 3 attenuation.
 1       1       1          Holds noise voice attenuation.
</programlisting>
</para>

<sect2><title>The noise generator</title>
<para>
   There are two modes for the noise operation, besides the four
   frequency selections. One, called periodic noise, produces a steady
   sound; the other, called white noise, produces a hissing sound. These
   two modes are controlled by a bit known as the FB bit. When FB is 0,
   the periodic noise is generated; when FB is 1, the white noise is
   produced.
</para><para>

   Two bits, known as NF0 and NF1, control the frequency at which the
   noise generator works. Three of the four possible combinations of NF0
   and NF1 set an independent noise frequency based on the timer. The
   fourth combination borrows the frequency from the third of the three
   pure voices made by the tone generators.
</para><para>
<programlisting>
 NF0  NF1       Noise Frequency

  0    0         1,193,180 / 512 = 2330
  0    1         1,193,180 / 1024 = 1165
  1    0         1,193,180 / 2048 = 583
</programlisting>
</para><para>

   The noise frequency is set by sending a byte of the following format
   to the T1 sound chip:
</para><para>
<programlisting>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Identifies first byte (command byte)
.  1  1  0  .  .  .  .      Register number in T1 chip (6)
.  .  .  .  X  .  .  .      Unused, ignored; can be set to 0 or 1
.  .  .  .  .  FB .  .      1 for white noise, 0 for periodic
.  .  .  .  .  . NF0 NF1    2 noise frequency control bits
</programlisting>
</para>

<sect1><title>Sound in the Apple IIgs</title>
<para>
   The Apple IIgs uses the Ensoniq 5503 DOC (Digital Oscillator Chip)
   to produce its sound. The 5503 has 32 oscillators and is capable of
   playing wavetable based music using digital sound samples stored in
   its own dedicated RAM (much like the Gravis Ultrasound card for the
   IBM PC). Thanks to the 5503, AGI games for the IIgs have a much richer
   sound than the PC, Mac or Tandy versions.
</para><para>

   Follows an excerpt of the Apple II Sound and Music FAQ, version 1.7.
</para>

<sect2><title>Technical Specs for the GS Ensoniq chip</title>
<para>
   Ian Schmidt, 3 November 1997.

</para><para>
   The 5503 Ensoniq Digital Oscillator Chip (DOC) contains 32 fundamental
   sound-generator units, known as ``oscillators''. Each oscillator is
   capable of either making an independent tone by itself, or of being
   paired up cooperatively with it's neighbor in a pairing known as a
   ``generator''. The generator arrangement is used by most programs, for
   it allows more flexibility and a thicker, lusher sound.

</para><para>
   The DOC plays 8-bit waveforms, with the centerline at 0x80 (128
   decimal). This format is known as ``8-bit unsigned''. 0x00 (0 decimal
   too) is reserved for `stop'. If a sample value of 0 is encountered by
   a DOC oscillator, the oscillator will immediately halt and not produce
   any more sound. The DOC additionally has an 8-bit volume register for
   each oscillator, with a linear slope. The dynamic range of the DOC
   (the `space' between the softest and loudest sounds it can produce) is
   approximately 42 dB, or about on par with an average cassette tape.

</para><para>
   Each oscillator has it's own 16 bit frequency register, ranging from 0
   to 65535. In a normal DOC configuration, each step of the frequency
   register increases the play rate by 51 Hz, and computing the maximum
   theoretical play rate is left as an exercise for the student.

</para><para>
   When oscillators are paired to create generators, there are 4 possible
   modes:
   <simplelist>
    <member>Free-run: the oscillator simply plays the waveform and stops. No
       interaction with it's 'twin' occurs.
    <member>Swap: Only one oscillator of the pair is active at a time. When
       one stops, the other immediately starts.
    <member>Loop: The oscillator simply plays the waveform and if it hits the
       end without encounter.cgiing a zero, it starts over at the
       beginning.
    <member>Sync/AM: This actually has 2 possible effects: either one
       oscillator of the pair modulates the volume of the other with the
       waveform it's playing, or both oscillators sync up perfectly,
       causing a louder and more 'solid' sound.
   </simplelist>

</para><para>
   Oscillators play waves stored in up to 128k of DRAM. This DRAM is not
   directly visible from the GS's 65816 CPU, but can be accessed (slowly)
   via services supplied by the Sound GLU chip. Note that no widely
   manufactured IIgs motherboard supported the full 128k of DRAM that the
   DOC can see. Conversely, no synthesizer Ensoniq made using the DOC had
   anything less than the full 128k.

</para><para>
   The output of an oscillator can be directed to any one of 16 possible
   channels. Apple only makes 8 channels avalible via the 3 bits on the
   sound expansion connector, and all current stereo cards limit this to
   1 bit, or two channels. However, the ``Bernie II The Rescue'' IIgs
   emulator for the Power Mac expands this support to 4 discrete output
   channels, two of which are encoded to the rear channel for Dolby
   Pro-Logic compatible output. No IIgs software that I'm aware of
   supports more than 2 channels however.
</para>

<sect1><title>Sound in other platforms</title>
<para>
   According to Paul Lunga, sound in the Macintosh and Tandy versions of
   the AGI games are pretty much the same as the PCjr version (three
   sound channels plus noise). AIFF files of AGI music in these platforms
   are available at <ulink url="http://agi.helllabs.org/sound">
   http://agi.helllabs.org/sound</ulink>.
</para>

<sect1><title>Sound resource format (PCjr version)</title>
<para>
   We now know enough about the PCjr's T1 sound chip to discuss the AGI
   sound format. The sound is stored as four separate units of data, one
   for each voice. Each sound file stored in the VOL files has an 8-bit
   header which contains offsets into file. The format is as follows:
</para><para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Offset of first voice data
 2-3  Offset of second voice data
 4-5  Offset of third voice data
 6-7  Offset of noise voice data
----- -----------------------------------------------------------
</programlisting>
</para><para>

   The data starting at each voice offset is stored as 5-byte notes which
   give the frequency and duration of a note played on that voice. The 5
   bytes have the following meanings:
</para><para>

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Duration (16-bit word)
 2-3  Frequency divisor of the format described in the PCjr
      section above except the two bytes are around the other way
  4   Attenuation of the note in the format described above in
      the PCjr section
----- -----------------------------------------------------------
</programlisting>

</para><para>
   Note that the last three bytes were around the other way in version 1
   of the AGI interpreter. The above order is opposite from the order
   that would be output to the T1 sound chip.

</para><para>
   Each voice's data section in the SOUND resource file is usually
   terminated by two consecutive 0xFF codes. Another way of checking for
   the end is to see if it has reached the start of the next voice
   section, or in the case of the noise voise, the end of the SOUND data.
</para>

<sect2><title>Summary</title>
<para>
   The header consists of four two-byte offsets, one for each voice. The
   format is little-endian. Each offset points to the note data for the
   relevant voice. The note data for a voice consists entirely of five-byte
   note entries of the following format:

</para><para>
   <simplelist>
    <member>First and second byte: Note duration
    <member>Third byte
       In the case of a tone voice,
<literal>
7  6  5  4  3  2  1  0

0  .  .  .  .  .  .  .      Always 0.
.  X  .  .  .  .  .  .      Unused, ignored.
.  .  F0 F1 F2 F3 F4 F5     6 of 10-bits in frequency count.
</literal>
       In the case of the noise voice, this byte is equal to zero.
    <member>Fourth byte
       In the case of a tone voice,
<literal>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Always 1.
.  R0 R1 R2 .  .  .  .      Register number in T1 chip (0, 2, 4).
.  .  .  .  F6 F7 F8 F9     4 of 10 bits in frequency count.

F = frequency = 111860 / (((Byte3 & 0x3f) << 4) + (Byte4 & 0x0f))
R = register address
</literal>
       In the case of the noise voice,
<literal>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Always 1.
.  1  1  0  .  .  .  .      Register number in T1 chip (6)
.  .  .  .  X  .  .  .      Unused, ignored; can be set to 0 or 1
.  .  .  .  .  FB .  .      1 for white noise, 0 for periodic
.  .  .  .  .  . NF0 NF1    2 noise frequency control bits

NF0  NF1       Noise Frequency

 0    0         1,193,180 / 512 = 2330
 0    1         1,193,180 / 1024 = 1165
 1    0         1,193,180 / 2048 = 583
</literal>
    <member>Fifth byte
<literal>
   7  6  5  4  3  2  1  0

   1  .  .  .  .  .  .  .      Identifies first byte (command byte)
   .  R0 R1 R2 .  .  .  .      Register number in T1 chip (1, 3, 5, or 7).
   .  .  .  .  A0 A1 A2 A3     4 attenuation bits


   A0 A1 A2 A3        Value        Attenuation (decibels)

    .  .  .  1          1                    2
    .  .  1  .          2                    4
    .  1  .  .          4                    8
    1  .  .  .          8                   16
    1  1  1  1                           Volume off


 Register Addresses:

   R0 R1 R2        Parameter

    0  0  0        Voice 1 frequency control number (10 bits)
    0  0  1        Voice 1 attenuation (4 bits)
    0  1  0        Voice 2 frequency control number (10 bits)
    0  1  1        Voice 2 attenuation (4 bits)
    1  0  0        Voice 3 frequency control number (10 bits)
    1  0  1        Voice 3 attenuation (4 bits)
    1  1  0        Noise voice control (4 bits; 3 used)
    1  1  1        Noise voice attenuation (4 bits)
</literal>
   </simplelist>
   The note data for one voice is terminated by two consecutive 0xFF
   values.
</para>

<sect2><title>AGI v1.12 sound format</title>
<para>
   The sound format used in version 1.12 of the AGI interpreter was quite
   different from the format described above for AGIv2 and AGIv3. It
   still uses the PCjr format for the note data but it does not store the
   duration as a separate field. The best way to describe it is by an
   example:
</para><para>
<programlisting>
90 80 16 B0 A0 15 D0 C0 0E FF E4 00 80 17 A0 16 C0 11 00
80 16 B1 A0 14 C0 12 00 80 16 B2 A0 16 C0 13 00 ...
</programlisting>

</para><para>
   The first thing to point out is that the PCjr note data is in the
   opposite order to AGIv2. Secondly, all four parts are included
   together rather than in separate sections. Taking the above example,
   lets look at the first note and show the equivalent AGIv2 notation.
</para><para>
<programlisting>
90 80 16 --> 03 00 16 80 90
</programlisting>

</para><para>
   Now, the duration isn't immediately obvious, but we will come to that
   in a short while. The followint three bytes give the first note for
   the second part, the third part, and the noise part (at least as far
   as this example is concerned).
</para><para>
<programlisting>
B0 A0 15 --> 03 00 15 A0 B0
D0 C0 0E --> 03 00 0E C0 D0
FF E4 00 --> 33 00 00 E4 FF
</programlisting>

</para><para>
   The data that follows after these initial four starting notes is
   basically any changes in the note value which each 3 duration step.
   For example,
</para><para>
<programlisting>
80 17 --> 03 00 17 80 90
</programlisting>

</para><para>
   Note that 0x90 doesn't need to be stored because that byte has
   retained its value. Every 0x00 byte that is encountered is the end of
   one set of note changes. Each set of note changes is the equivalent of
   a duration of 3 in the AGIv2 format. Continuing with our example,
</para><para>
<programlisting>
A0 16 --> 03 00 16 A0 B0
C0 11 --> 03 00 11 C0 D0
</programlisting>

</para><para>
   The example now encounters a 0x00 byte which means that the noise
   voice isn't changed at this point. In fact, from the AGIv2 equivalent
   note above, you will see that the noise note will not change until 49
   (or 0x33) sets of note changes have been processed.
</para><para>
<programlisting>
80 16    --> 03 00 16 80 90
B1 A0 14 --> 03 00 14 A0 B1
C0 12    --> 03 00 12 C0 D0
</programlisting>

</para><para>
   How exactly the AGIv1.12 interpreter knows which voice is having its
   notes changed, and which bytes of the note are being changed, is not
   yet certain. On some occassion a sets of changes will contain only one
   byte which corresponds to one of the bytes which makes up one of the
   voices note value, but how it knows which one is a mystery to me.

</para><para>
   On other occassions, there could be a whole chain of 0x00 bytes which
   means that during that whole time, none of the voices are changing
   their notes value.
</para>

<sect1><title>Sound resource format (IIgs version)</title>
<para>
   There are two types of SOUND resources in the IIgs AGI games: PCM
   samples (used for sound effects) and MIDI sequences. The first
   two bytes can tell what type of resource we have:

</para><para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Resource type (01 00 = sample, 02 00 = MIDI)
----- -----------------------------------------------------------
</programlisting>
</para>

<sect2><title>Sampled sounds</title>
<para>
   Sampled sounds (resource type 01) are stored in 8 bit, unsigned format
   after a 54 byte header described below.

</para><para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Resource type (01 00)
 2-7  ???
 8-9  Sample size
10-53 ???
----- -----------------------------------------------------------
</programlisting>
</para>

<sect2><title>MIDI sequences</title>
<para>
   Ian Schmidt, 3 April 1999.

</para><para>
   MIDI songs have a stram of MIDI data following the resource type.
   The following dump shows the MIDI data in the King's Quest I opening
   theme resource:
</para><para>

<programlisting>
02 00		Type: MIDI sequence

00 c0 28	Set patch 0x28 in channel 0
00 c1 28	Set patch 0x28 in channel 1
00 c2 29	Set patch 0x29 in channel 2
00 c3 16	Set patch 0x16 in channel 3
00 c4 01	Set patch 0x01 in channel 4

00 b0 07 7f	Set channel volumes (MIDI controller 07)
00 b2 07 7f	...
00 b4 07 6a
01 b3 07 6e
18 b1 07 7b

4d 90 43 38	Play note 0x43 in channel 0 with velocity 0x38
0a 80 43 40	Resease note 0x43 in channel 0 with velocity 0x40
0c 90 43 45	...
0b 80 43 40
01 91 3c 35
00 92 30 40
00 91 43 39
00 40 37
02 90 48 40
</programlisting>

</para><para>
   The patch number is mapped to a sound sample stored in the
   <filename/sierrastandard/ file in a more complicated way. The IIgs
   interpreter uses the patch number as a lookup into a list of
   instrument definitions, which are stored in a format used by an
   API called the ``Note Synthesizer''.

</para><para>
   For example, here's instrument 0 from Police Quest, as dumped out of the
   <filename/pq.sys16/ file:
</para><para>

<programlisting>
INST #000:
Envelope:
[seg 0]: BP 7f  Inc f00
[seg 1]: BP 78  Inc a
[seg 2]: BP 78  Inc 0
[seg 3]: BP 0  Inc 514
[seg 4]: BP 0  Inc 0
[seg 5]: BP 0  Inc 0
[seg 6]: BP 0  Inc 0
[seg 7]: BP 0  Inc 0
rel seg: 3, pri inc: 32, bend range: 2, vib dep: 75, vib spd: 50
A wave count: 1, B wave count: 1
[A 1 of 1] top: 7f, wave address: 50, size: 12 mode: 00, relPitch: 00fe
[B 1 of 1] top: 7f, wave address: 50, size: 12 mode: 00, relPitch: 00fe
</programlisting>

</para><para>
   Now, that's a bit scary looking, but all the important information is
   there :-)

</para><para>
   Basically the Note Synth API groups 2 5503 voices together to make 1 voice,
   and this has all the data you need to control it. Let me rephrase some
   info from my dusty old ``IIgs Toolbox Reference, Volume 3''.

</para><para>
   The envelope is first: for each segment there's a breakpoint (target
   volume, which is on a logarithmic scale in 6 decibel units) and an
   Increment (a 8.8 fixed point number telling how much to adjust the volume
   on each tick).  For instance, if the first segment had BP = 1 and Inc =
   0x0001, it would take 256 ticks for the volume to reach 1.  The <emphasis/rel seg/
   tells which segment of the envelope is the final one. Ticks in the Note
   Synth default to 100 Hz, although the AGI interpreter may well have used a
   different value -- I'll have to check.

   <emphasis/Bend range/ is the number of semitones the instrument will be bent by if
   a pitch wheel message at maximum deflection in either direction is
   encountered.  For this instrument, that's 3 semitones in each direction.

   <emphasis/Vib Dep/ and <emphasis/Vib Spd/ aren't being dumped properly yet (minor
   bug in my utility), but they specify the depth and speed of an optional
   vibrato effect.

   <emphasis/A wave count/ and <emphasis/B wave count/ tell how many wavelists there are
   for each 5503 voice. If there's more than 1 wavelist you compare the note
   being started with the <emphasis/top/ value in each wavelist and if <emphasis/top/ is
   greater than or equal to the note you're starting you use that wavelist.
   In this case there's only 1 possible wavelist so <emphasis/top/ is naturally 0x7f,
   the highest possible numbered MIDI note.

</para><para>
   Once you've picked a wavelist using the note, the other information is all
   there.  Wave address is the offset in 256-byte pages into the 64k
   <literal/sierrastandard/ image (ie, (Wave Address)&lt;&lt;8 gives a true offset).
   In this case the wave starts 0x5000 bytes into the image. For size you
   mask off all but the lowest 3 bits and it gives you the basic wave size as
   follows:

</para><para>
   Case the wave starts 0x5000 bytes into the image: For size you mask off
   all but the lowest 3 bits and it gives you the basic wave size as follows:

</para><para>
   <simplelist>
    <member>%000 = 1 page (256 bytes)
    <member>%001 = 2 pages (512 bytes)
    <member>%010 = 4 pages (1k bytes)
    <member>%011 = 8 pages (2k bytes)
    <member>%100 = 16 pages (4k bytes)
    <member>%101 = 32 pages (8k bytes)
    <member>%110 = 64 pages (16k bytes)
    <member>%111 = 128 pages (32k bytes)
   </simplelist>

</para><para>
   Note that if a zero is encountered in the wave before that size you still
   stop at the zero.

</para><para>
   <emphasis/Mode/ is the 5503 oscillator mode for the voice in the bits 1 and 2.
   The lowest bit (bit 0) is a ``halt'' flag.
   0 is looping, 1 is oneshot (play once), 2 is sync/AM (which nobody uses, but
   I'll try to explain it if they actually are), and 3 is swap (oscillator 0
   plays once, generates an IRQ, and oscillator 1 starts automatically.  If
   oscillator 1 is also in swap mode, it will play once, generate and IRQ, and
   auto-start oscillator 0 again.  If oscillator 1 is loop mode it will just
   loop continuously - this setup is often used to have a sampled ``attack'' on
   an instrument followed by a loop.

</para><para>
   The top 4 bits of the mode is the stereo channel where even numbers are
   right and odd numbers are left, I believe (no real harm in reversing them).

</para><para>
   The full bitmap for the control register is:
</para><para>
<programlisting>
% cccc 0mmh
</programlisting>

</para><para>
   Where:
   <simplelist>
    <member><literal/c/ - stereo output channel. Odd values mean left, even mean right.
    <member><literal/m/ - mode, as described previously.
    <member><literal/h/ - halt bit. 0 to start the oscillator, 1 to halt it.
      This is handled specially in swap mode.
   </simplelist>

   <emphasis/relPitch/ is the fine-tune value in 8.8 fixed point, given in semitones.

</para><para>
   So you'd then start 2 voices using the appropriate A and B wavelist entries
   and handle them accordingly.

</para><para>
   The full structures look like this:
   (there is no structure padding on the IIgs - all bytes are jammed right
   together!)

</para><para>
   In Police Quest these structures start at offset 0x8469 in PQ.SYS16.
   <emphasis>(The same offset is used for KQ1 --CM)</emphasis> I can't find any of my
   other old disks with AGI games to locate their offsets. PQ only defines
   28 instruments.

</para><para>
<programlisting>
ENVELOPE:

Byte  Meaning
----- -----------------------------------------------------------
  0   Breakpoint for this segment
 1-2  Increment for this segment
----- -----------------------------------------------------------

WAVELIST:

Byte  Meaning
----- -----------------------------------------------------------
  0   Top key
  1   Wave address
  2   Wave size
  3   Mode / stereo position
 4-5  relPitch
----- -----------------------------------------------------------

INSTRUMENT:

Byte  Meaning
----- -----------------------------------------------------------
0-23  8 envelope segments
 24   Release segment
 25   Priority increment (you can ignore this)
 26   Bend range
 27   Priority increment (you can ignore this)
 28   Bend range
 29   Vibrato depth
 30   Vibrato speed
 31   "spare" (unused)
 32   A wave count (number of A oscillator wavelists)
 33   B wave count (number of B oscillator wavelists)
34-?  (A wave count number of wavelists)
  ?   (B wave count number of wavelists)
----- -----------------------------------------------------------
</programlisting>

</para>

<sect1><title>Playing the sounds on a sound card</title>
<para>
   Lance Ewing, 18 August 1997
</para><para>
   Writing a program to play the tunes will require four pointers which
   keep track of where in each voice segment the program currently is
   since all four voices are played simultaneously. The first voice is
   the melody and is the voice that is played on the PC speaker in
   today's modern PC compatibles, the other two voices being ignored. I'd
   imagine that other platforms such as the Amiga and Macintosh would
   probably play all three voices.

</para><para>
   A program would start by reading each of the four offsets in the
   header. It would then go through a loop which begins by reading the
   first note of each voice section. The duration's are then monitored
   and when each note finishes, another note is read. Note that the notes
   for each voice will usually finish at different times. The program
   finishes when all of the voice sections have been entirely played.
   This will usually occur for each voice at the same time but not
   necessarily I don't think.

</para><para>
   Then of course you could always convert the AGI SOUND to a MIDI file
   and play that which will sound a hundred times better :)
</para>

<sect2><title>Calculating frequencies when playing notes on a sound card</title>
<para>
   My program reads in the duration as a 16 bit word. It then loads the
   two following bytes and calculates the frequency as follows:
<programlisting>
f = 111860 / (((Byte2 & 0x3F) << 4) + (Byte3 & 0x0F))
</programlisting>

</para><para>
   The 111860 comes from the PCjr discussion above. Note that the bytes
   are in the opposite order from that mentioned in the PCjr information.

</para><para>
   Remember also that the SOUND format includes volume information for
   each voice. The exact conversion from the decible values to the volume
   control on todays sound cards is uncertain at this stage.
</para>

<sect1 id="soundcode"><title>Sample code</title>
<para>

</para><para>
   <simplelist>
    <member><filename/adlib.c/ by Kevin A. Lee: low level adlib routines
    <member><filename/adlib.h/ by Kevin A. Lee: header for <filename/adlib.c/
    <member><filename/oldplay.c/ by Lance Ewing: old program to play AGI sounds
    <member><filename/play.c/ by Jens Christian Restemeier:
      new program for playing AGI sounds (plays as a MIDI file)
    <member><filename/agiplay.c/ by Claudio Matsuoka: program to play PCjr
      AGI sound resources in Linux using software mixing and
      <filename>/dev/dsp</filename>.
   </simplelist>

</para>
</chapter>


<chapter id="otherdata"><title>Other game data</title>
<para>
    Lance Ewing, 31 August 1997.
</para>

<sect1><title>Format of the <literal/object/ file</title>
<para>
   The <literal/object/ file stores two bits of information about the inventory
   members used in an AGI game. The starting room location and the name of
   the inventory member. It also has a byte that determines the maximum
   number of animated objects.
</para>

<sect2><title>The file encryption</title>
<para>
   The first obstacle to overcome is the fact that most <literal/object/ files are
   encrypted. I say most because some of the earlier AGI games were not,
   in which case you can skip to the next section. Those that are
   encrypted are done so with the string ``Avis Durgan'' (or, in case of
   AGDS games, ``Alex Simkin''). The process of unencrypting the file is
   to simply taken every eleven bytes from the file and XOR each element
   of those eleven bytes with the corresponding element in the string
   ``Avis Durgan''. This sort of encryption is very easy to crack if you
   know what you are doing and is simply meant to act as a shield so as
   not to encourage cheating. In some games, however, the object names are
   clearly visible in the saved game files even when the <literal/object/ file
   is encrypted, so it's not a very effective shield.

<sect2><title>File format</title>
   <para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Offset of the start of inventory member names
  2   Maximum number of animated objects
----- -----------------------------------------------------------
</programlisting>

   Following the first three bytes as a section containing a three byte
   entry for each inventory member all of which conform to the following
   format:
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Offset of inventory member name i
  2   Starting room number for inventory member i or 255 carried
----- -----------------------------------------------------------
</programlisting>
   where <emphasis/i/ is the entry number starting at 0. All offsets are taken from
   the start of entry for inventory member 0 (not the start of the file).

   Then comes the textual names themselves. This is simply a list of NULL
   terminated strings. The offsets mentioned in the above section point
   to the first character in the string and the last character is the one
   before the 0x00.
</para>
</sect1>

<sect1><title>Format of <literal/words.tok/</title>
<para>
   The <literal/words.tok/ file is used to store the games vocabulary, i.e. the
   dictionary of words that the interpreter understands. These words are
   stored along with a word number which is used by the <literal/said/ test
   commands as argument values for that command. Many words can have the
   same word number which basically means that these words are synonyms
   for each other as far as the game is concerned.

   The file itself is both packed and encrypted. Words are stored in
   alphabetic order which is required for the compression method to work.
</para>

<sect2><title>The first section</title>
<para>
   At the start of the file is a section that is always 26x2 bytes long.
   This section contains a two byte entry for every letter of the
   alphabet. It is essentially an index which gives the starting location
   of the words beginning with the corresponding letter.
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Hi and then Lo byte for 'A' offset
 ...
50-51 Hi and then Lo byte for 'Z' offset
 52   Words section
----- -----------------------------------------------------------
</programlisting>

   The important thing to note from the above is that the 16 bit words are
   big-endian (HI-LO). The little endian (LO-HI) byte order convention used
   everywhere else in the AGI system is not used here. For example, 0x00
   and 0x24 means 0x0024, not 0x2400. Big endian words are used later on
   for word numbers as well.

   All offsets are taken from the beginning of the file. If no words
   start with a particular letter, then the offset in that field will be
   0x0000.
<para>

<sect2><title>The words section</title>
<para>
   Words are stored in a compressed way in which each word will use part
   of the previous word as a starting point for itself. For example,
   ``forearm'' and ``forest'' both have the prefix ``fore''. If ``forest''
   comes immediately after ``forearm'', then the data for ``forest'' will
   specify that it will start with the first four characters of the previous
   word. Whether this method is used for further confusion for would be
   cheaters or whether it is to help in the searching process, I don't
   yet know, but it most certainly isn't purely for compression since the
   <literal/words.tok/ file is usally quite small and no attempt is made to
   compress any of the larger files (before AGI version 3 that is).

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Number of characters to include from start of prevous word
  1   Char 1 (xor 0x7F gives the ASCII code for the character)
  2   Char 2
 ...
  n   Last char
 n+1  Wordnum (LO-HI) -- see below
----- -----------------------------------------------------------
</programlisting>

   If a word does not use any part of the previous word, then the prefix
   field is equal to zero. This will always be the case for the first
   word starting with a new letter. There is nothing to indicate where
   the words starting with one letter finish and the next set starts,
   infact the words section is just one continuous chain of words
   conforming to the above format. The index section mentioned earlier is
   not needed to read the words in which suggests that the whole
   <literal/words.tok/ format is organised to find words quickly.
</para>

<sect2><title>A note about word numbers</title>
<para>
   Some word numbers have special meaning. They are listed below:

<programlisting>
Word# Meaning
----- -----------------------------------------------------------
  0   Words are ignored (e.g. the, at)
  1   Anyword
9999  ROL (Rest Of Line) -- it does matter what the rest of the
      input list is
----- -----------------------------------------------------------
</programlisting>

   Example:
<programlisting>
if (said(take, anyword)) {
    print("You can't - Blackbeard has chopped both your arms off.");
}
</programlisting>
</para>
</sect1>

<sect1 id="othercode"><title>Sample code</title>
<para>

   <simplelist>
    <member><filename/object.pas/
      by Peter Kelly: displays contents of the <filename/object/ file
    <member><filename/words.pas/
      by Peter Kelly: displays contents of the <filename/words.tok/ file
   </simplelist>
</chapter>




</book>

