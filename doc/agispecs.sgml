<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V3.0//EN" [
        <!ENTITY lt "<">
        <!ENTITY gt ">">
        <!ENTITY amp "&">
]>

<Book>
  <Title>The Sierra Adventure Game Interpreter Specification</Title>

  <TitleAbbrev>AGI Specs</TitleAbbrev>

  <BookInfo>
    <Author>
     <firstname>Peter</firstname>
     <surname>Kelly</surname>
     <AuthorBlurb><Para>
      Peter Kelly (<email>ptrkelly@ozemail.com.au</email>)
     </Para></AuthorBlurb>
    </Author>

    <Author>
     <firstname>Lance</firstname>
     <surname>Ewing</surname>
     <AuthorBlurb><Para>
      Lance Ewing (<email> </email>)
     </Para></AuthorBlurb>
    </Author>

    <Author>
     <firstname>Anders</firstname>
     <surname>Olsson</surname>
     <AuthorBlurb><Para>
      Anders M. Olsson (<email></email>)
     </Para></AuthorBlurb>
    </Author>

    <Author>
     <firstname>Jeremy</firstname>
     <surname>Hayes</surname>
     <AuthorBlurb><Para>
       Jeremy Hayes (<email></email>)
     </Para></AuthorBlurb>
    </Author>

    <Author>
     <firstname>Claudio</firstname>
     <surname>Matsuoka</surname>
     <AuthorBlurb><Para>
      Claudio Matsuoka (<Email>claudio@helllabs.org</Email>) is the
      current maintainer of this document and the Sarien AGI interpreter.
     </Para></AuthorBlurb>
    </Author>

    <Abstract><Para>
      This document is a collection of all the information currently known
      about the structure and operation of the Adventure Game Interpreter,
      used in 1984--1989 for a variety of adventure games published by
      Sierra On-Line such as Space Quest I and II, and Leisure Suit Larry in
      the Land of the Lounge Lizards.
    </Para></Abstract>

    <ReleaseInfo>
      $Id$
    </ReleaseInfo>

    <LegalNotice>
     <Para>
     Copyright (C) 2001 by the authors
     </Para>
     <Para>
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this documentation to deal in the Documentation without restriction,
   including without limitation the rights to use, copy, modify, merge,
   publish, distribute, sublicense, and/or sell copies of the Documentation,
   and to permit persons to whom the Documentation is furnished to do so,
   subject to the following conditions:
</Para><Para>
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Documentation.
</Para><Para>
   THE DOCUMENTATION IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE DOCUMENTATION OR THE USE OR
   OTHER DEALINGS IN THE DOCUMENTATION.
</Para><Para>
   The Adventure Game Interpreter was originally developed by Sierra
   On-Line, Inc. "Sierra On-Line Inc. (TM)" is a registered trademark
   of Sierra On-Line, Inc. Names of the AGI games produced by Sierra
   On-Line, Inc., including, but not limited to, "Leisure Suit Larry
   in the Land of the Lounge Lizards", "Space Quest: The Sarien
   Encounter" and "Space Quest 2: Vohaul's Revenge" are trademarks of
   Sierra On-Line, Inc.
</Para>
   </LegalNotice>

  </BookInfo>

  <Preface>
  <Title/Preface/
   <para>
   </para>
  </Preface>


<chapter id="intro"><title>Introduction</title>
<para>
   AGI (Adventure Game Interpreter) was the first major interpreter used
   by Sierra. With the release of King's Quest 1 in the early 80's, it
   introduced the gaming world to the concept of a 3D graphical adventure
   game, where the player could move a character around the screen,
   behind, in front of and over objects. Other commands could be typed
   in, just like a text adventure. This concept, in various forms, has
   been used many many times since, by Sierra and other companies such as
   LucasArts (http://www.lucasarts.com). It has proved
   very successful and continues to be used today in games such as Larry 7.
</para>

<sect1 id="about"><title>About this document</title>
<para>
   The latest version of this document can be found at
   http://agi.helllabs.org/agispecs/ in
   SGML, HTML, Postscript and plain text formats.

   If you have any questions about the individual sections in this
   document, email the author of that section.
</para><para>
   If you have documented an aspect of the interpreter, or have updated
   your documentation which is already included this document, please
   send it to the current maintainer (claudio@helllabs.org) so that it can be
   added in future versions. Preferred format is DocBook DTD or plain
   text.
</para>
</sect1>

<sect1 id="audience"><title>Audience</title>
<para>
   AGI specs is intended for people writing AGI programs such as
   editors, viewers and interpreters. It is not supposed to be a
   beginners' introduction to AGI, or a LOGIC programming guide for
   those who just want to create games (although it can serve as a
   reference for more advanced LOGIC programmers). If you want to
   learn the LOGIC programming language, we suggest you read the
   logic section of the AGI Studio help file, and the various other
   bits of documentation and tutorials available on-line.
   The programming info contained in this document is mostly from
   <xref linkend="agds"> and uses different syntax and
   terminology for the language and can be confusing if you are using
   AGI Studio for your programming.
</para>
</sect1>


<sect1><title>What's still missing</title>
 <para>
   Although this document has many details about the AGI specs, a few
   pieces of information are still missing:
   <itemizedlist>
    <listitem><para>Savegame file format</para></listitem>
    <listitem><para>Some chunks of the memory organization</para></listitem>
    <listitem><para>Unknown view table entries</para></listitem>
    <listitem><para>Unknown fields in the IIgs sound header</para></listitem>
    <listitem><para>The release date of many AGI games</para></listitem>
    <listitem><para>The purpose of commands 171, 172 and 174</para></listitem>
    <listitem><para>The meaning of bit 0 in the argument byte</para></listitem>
    <listitem><para>The meaning of bytes 0--1 in the VIEW resource
        header</para></listitem>
    <listitem><para>Canonical names of commands 170--181</para></listitem>
    <listitem><para>Canonical variable and flag names</para></listitem>
    <listitem><para>More information about differences of AGI in other
        platforms (Amiga, Apple II, CoCo 3, etc)</para></listitem>
   </itemizedlist>
 </para>
</sect1>

<sect1 id="credits"><title>Acknowledgements</title>

<para>
The following people (and probably more) have contributed to this document:
Peter Kelly (ptrkelly@ozemail.com.au),
Lance Ewing (lance.e@ihug.co.nz),
Alex Simkin (simkin@argussoft.ru),
Vassili Bykov (nest@rtsnet.ru),
Anders M. Olsson (anders.m.olsson@abc.se),
Jeremy Hayes (mikeph@concentric.net),
Joakim Möller (jmoller@algonet.se),
Martin Tillenius (mrtn@rocketmail.com),
Stuart George (entropy@ihug.com.au),
Dark Minister (dark_minister@hotmail.com),
Kevin A. Lee,
Jens Christian Restemeier (jchrr@hrz.uni-bielefeld.de),
Paul Lunga (paul123@freenet.tlh.fl.us),
Ian Schmidt (irsman@iag.net),
XoXus (xoxus@usa.net),
Claudio Matsuoka (claudio@helllabs.org),
Please contact the document maintainer to add more names to this list.
</para>
</sect1>
</chapter>


<chapter id="overview"><title>General AGI overview</title>

<para>
   AGI stands for <emphasis/Adventure Game Interpreter/ and it is the old
   version of Sierra On-Line's 3D adventure interpreter. It was used
   in Donald Duck's Playground, Kings Quest 1--3,
   King's Quest 4 (256K version), Space Quest 1 and 2, Police Quest,
   Leisure Suit Larry in the Land of the Lounge Lizards, Black Cauldron,
   Mixed Up Mother Goose, Gold Rush and Manhunter 1 and 2. There were also a
   number of demos that were written in AGI: the XMAS animated christmas card,
   King's Quest 4 demo, and Sierra demo packs 1--4.
</para>

<sect1><title>Versions of the AGI interpreter</title>
<para>
   There were three main version of the AGI interpreter. The first
   version was the one used with KQ1 and KQ2 when they were originally
   released. The graphics were in CGA but apart from that the games
   looked very much like the later EGA remakes. The second version is the
   one we are most familiar with and was used for the majority of the
   above games. It added support for the 16 colour EGA card but
   still kept the old 160x200 resolution that the original games had. The
   third and final version of the AGI interpreter came out for only a
   short while before the SCI interpreter hit the scene. There were five
   games that I know of which used this version. Sierra obviously noticed
   the increased size of the games and therefore added data compression
   to this version. There are a few differences in the way the data is
   stored other than the compression as well, but the data itself still
   contains exactly the same information. It is therefore possible to
   convert a version 3 game into the version 2 format and vice versa.
</para>
</sect1>

<sect1><title>AGI game files</title>
<para>
   An AGI game package contains the AGI game resource files, usually
   platform-idependent, and the platform-specific interpreter binaries.
   The MS-DOS version is the most popular and best known AGI interpreter;
   there are, however, versions for the Macintosh, Atari, Amiga, Apple IIgs
   and Tandy computers.
</para>
<para>
   The following files are the platform-specific components of the
   Sierra AGI interpreter for MS-DOS:
   <variablelist>
    <varlistentry><term><filename/agi/</term>
     <listitem>
      <para>
      This is the main interpreter file in the MS-DOS version.
      It contains all the routines for the various AGI commands.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/agidata.ovl/</term>
     <listitem>
      <para>
      In MS-DOS, this overlay file contains various
      bits of data for the AGI such as interpreter error messages and jump
      tables for the AGI commands inside the AGI file.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/sierra.com/</term>
     <listitem>
      <para>
      In MS-DOS, this is the loader which loads the
      interpreter file. In some games this will be combined with the
      AGI file to give one executable often called <filename/sierra.exe/
      or the initials of the game.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/*.ovl/</term>
     <listitem>
      <para>
      Apart from <filename/agidata.ovl/ mentioned above,
      most of these files are the device drivers for the various display
      adapters that are supported. They are overlay files which are only
      brought in depending on which display adapter has been selected.
      <filename/ibm_objs.ovl/ and <filename/hgc_objs.ovl/ seem to be more
      to do with the VIEW resources though.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
</para>
<para>
   The following files are the platform-specific components for the
   Apple IIgs interpreter:
   <variablelist>
    <varlistentry><term><filename/*.sys16/</term>
     <listitem>
      <para>
      The AGI interpreter in the Apple IIgs version.
      The name of the executable is the initial of the game (e.g.
      <filename/kq.sys16/ for King's Quest).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/sierrastandard/</term>
     <listitem>
      <para>
      The file containing the sampled instruments
      and sound effects used in the game.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
</para>
<para>
   The following files are platform-independent:
   <variablelist>
    <varlistentry><term><filename/logdir/, <filename/viewdir/, <filename/picdir/, <filename/snddir/</term>
     <listitem>
      <para>
      These directory files give the location of each of LOGIC, PICTURE,
      VIEW, and SOUND data within the VOL files.
      </para>
      <para>
      In version 3 of the interpreter, these files are combined into one
      file with a header which gives the offset of each part.
      The name of this single directory file is <filename/*dir/ where the *
      is the initials of the game (e.g. <filename/kq4dir/, <filename/mh2dir/,
      <filename/grdir/, <filename/bcdir/, <filename/mh1dir/).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/vol.*/</term>
     <listitem>
      <para>
      These files contain the main game data. Whereas the AGI
      interpreter may not change between games, the vol files will always be
      different. They look very much like a virtual device which contain
      many individual files indexed by the directory files.
      </para>
      <para>
      In version 3 games, the VOL files are named after the game with a
      <filename/vol/ suffix (e.g. <filename/kq4vol.0/, <filename/grvol.10/,
      <filename/mh2vol.5/).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/words.tok/</term>
     <listitem>
      <para>
      This file contains a list of all the words that the
      user may type in during the game. The words are partly compressed and
      encrypted as well, so you won't be able to see the words if you
      display the file as you normally would.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry><term><filename/object/</term>
     <listitem>
      <para>
      This file contains a list of all the inventory members
      that the user can find in the game. This file is also encrypted but
      in a different way using the phrase "Avis Durgan". Each object also
      has associated with it a number that gives the starting room for that
      object.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
</para>
</sect1>

<sect1><title>AGI resource files</title>
<para>
   AGI uses four types of resources: LOGIC, PICTURE, VIEW and SOUND.
</para>
<para>
   LOGIC resources contain the LOGIC scripts that contain the AGI
   commands which the interpreter runs. All rooms have a single LOGIC
   script that governs what happens within that room. At the end of a
   LOGIC file is a text section which contains all the messages that are
   specific to the functioning of that particular LOGIC script. These are
   encrypted with the ``Avis Durgan'' string in the case of version 2
   games.
</para>
<para>
   PICTURE resources contain the picture codes which are used to draw
   the full screen pictures that you see for each room. The codes are
   vector based and draw a screen in the manner that the artist
   originally did. There are two screens store in each PICTURE file: the
   visual screen and the priority screen. The priority screen contains
   priority bands and control lines. In version 3 games, this file is not
   compressed with adaptive LZW as the VIEW, LOGIC, and SOUND files are.
   The format is also slightly different for codes 0xF0 and 0xF2 in order
   to slighly compress the data.
</para>
<para>
   VIEW resources contain all the still props (like objects), actors
   (like ogres and labion terror beasts), and animated props (like flags
   blowing in the breeze). All inventory member pictures are a specialized
   type of VIEW which has a text description tagged to the end of the
   file. Views are made up of many loops (animation cycles) that are in
   turn made up of many cels (a single frame of animation).
</para>
<para>
   SOUND resources contain all the musical scores and sound effects
   which on most machines are one voice over the PC speaker but on some
   machines, like the PCjr, will be in three voices. The IIgs version
   of the interpreter recognize PCM sampled sound effects and 16 channel
   wavetable-based MIDI music.
</para>
</sect1>

<sect1><title>What is Ego?</title>
<para>
   Ego is the name given to the player character (e.g. Rosella, Roger,
   Graham). The AGI games have commands which actually use the name ego
   in the command itself (e.g. <function/follow.ego/). The later SCI games
   retain this name.
</para>
</sect1>

<sect1><title>AGI commands</title>
<para>
   The AGI commands are what makes up the AGI programming language if you
   like. Everyones had a muck around with BASIC which is almost always an
   interpreted language. Well, the AGI commands are like the BASIC
   statements in BASIC, or like the procedures and functions in Pascal.
   In both of these languages there are two types of command, those that
   return a value and those that don't. AGI is much the same in that it
   has one group of commands that return boolean values and one group
   which returns nothing. It also has a small subset of keywords (if,
   else, not, else, or, and, goto, return) which aren't AGI commands as
   such. At the last count, there were about 181 procedure type commands
   and about 18 boolean returning function commands (test commands). We
   only know the names of 169 of the procedure type commands because this
   is all Sierra has included in their command list used in debug
   tracing.
</para>
<para>
   Example LOGIC code (from the AGI version of KQ4):
</para>
<para>
<programlisting>
animate.obj (smoke);
ignore.horizon (smoke);
set.view (smoke, v.fish.cabin);
set.loop (smoke, 1);
ignore.blocks (smoke);
position (smoke, 95, 16);
work = 3;
step.time (smoke, work);
cycle.time (smoke, work);
draw (smoke);
</programlisting>
</para>
</sect1>

<sect1><title>Debug modes</title>
<para>
   Testers often need some way to achieve certain things quickly so that
   they can test a certain part of the game. Most AGI games still have
   the debug code that these testers used when the games were being
   developed. Of the thirteen AGI games mentioned above, there are only
   three which I havn't discovered the debug mode in. Most of the games
   activate their debug modes by pushing the
   <keycombo><keycap>ALT</keycap><keycap>D</keycap></keycombo>
   key combination. The other games used a magic phrase to enter the
   debug mode.
</para>
<para>
   <simplelist>
    <member>Gold Rush: type <command>BIRD MAN</command>.
    <member>King's Quest 3: type <command>RATS ASS</command> (in some versions
     <keycombo><keycap>ALT</keycap><keycap>D</keycap></keycombo>
     works instead).
    <member>Police Quest: type <command>STINK BUG</command>.
    <member>Space Quest 2: type <command>BACKSTAGE</command> or
     <command>DBG</command> (type <command>TESTER</command> to
      bring up Roger's screen coordinates).
   </simplelist>
</para>
<para>
   The following are standard debug mode commands:
</para>
<para>
   <simplelist>
    <member><command/TP/: Teleport to another room.
    <member><command/SHOW PRIORITY/: Show the current rooms priority bands and
      control lines.
    <member><command/GET OBJECT/: Get any inventory member.
    <member><command/GIMME GIMME/: Get all inventory members.
    <member><command/SHOW FLAG/: Show one of the 256 flags.
    <member><command/SET FLAG/: Set one of the 256 flags.
    <member><command/RESET FLAG/: Clear one of the 256 flags.
    <member><command/SHOW VAR/: Show one of the 256 variables.
    <member><command/SET VAR/: Change the value of one of the 256 variables.
    <member><command/POSITION/: Change egos position.
    <member><command/SHOW POSITION/: Show egos current screen coordinates.
    <member><command/OBJECT NUMBER/: Gives a list of all the objects and their
	object numbers.
    <member><command/OBJECT ROOM/: Says which room an object is found in.
    <member><command/ROOM/: Says what room number ego is currently in.
    <member><command/SET PRIORITY/: Set the priority of ego.
    <member><command/RELEASE PRIORITY/: Release the last priority that ego was set to.
   </simplelist>
</para>
<para>
   Of all the AGI games, it is unknown whether MH1, MH2 and Mixed Up
   Mother Goose have a debug mode or not. MUMG probably doesn't even
   though its <literal/words.tok/ file has all the debug words contained in it.
   Manhunter 2 has some kind of debug mode which allows you to teleport
   and change variable values because there are text messages in the
   first LOGIC file along these lines. Manhunter: New York probably has
   the same debug mode.
</para>
<para>
   You may be lucky to find a game which allows command tracing. Almost
   all games have this facility taken out. It is possible to get it to
   work on some games if you add certain things to the data. What this
   mode does is to respond to the Scroll-Lock key by displaying a window
   box which you can step through the test commands that are being
   executed. In this case most keys step forward one test command, and
   the <keycap/+/ key steps to the start of the next LOGIC file.
</para>
<para>
   Example:
<programlisting>
     =============================
     0: greatern (17, 0)
                 (0, 0)         :F

</programlisting>
</para>
<para>
   The line of <keycap/=/ characters shows the start of an AGI cycle.
   The number at the start of a line gives the script number that is
   currently being executed. In the case above, the <literal/(0, 0)/ is
   the numeric value of the two parameters above it, i.e. the 17 in the
   above line refers to variable 17, and the 0 below it is the current
   value of variable 17. The <literal/F/ or <literal/T/ characters at
   the end of a line tell us whether the expression evaluated to be
   false or true.
</para><para>
   Notice that when you reach the start of <filename/logic.0/ again, all the
   controlled VIEW objects on the screen are updated. Using this tracing
   mode is a good way to get a feel for what happens which each cycle of
   interpretation.
</para>
</sect1>

<sect1 id="bands"><title>Priority bands and control lines</title>
<para>
   Okay, you've probably all seen those strange screens that you can
   activate by typing <command/SHOW PRIORITY/ in the debug modes discussed
   above. Here's an explanation of what this screen is used for.
</para>

<sect2><title>Priority bands</title>
<para>
   To maintain and enhance the three dimensional quality of the rooms,
   every object is constructed with a priority in relation to other
   objects. The priority is shown by its colour on the priority screen.
   The higher the priority colour, the more priority it has to be drawn.
</para>
<para>
   The screen has about eleven even sized invisible bands
   across the screen called priority bands. When ego walks up and down
   the screen, he or she will move from one priority band into the next
   priority band. The current priority band that ego is in, along with
   the priority screen that you see when you type <command/SHOW PRIORITY/, is
   used to determine which parts of ego to draw and which parts not to
   draw. This is used to give the affect of ego moving behind trees and
   rocks etc.
</para>
<para>
   Although the priority bands are invisible in the finished product, the
   artist must use them like a horizontal grid as he draws the room.
   Considerable effort and time is spent placing houses, bushes, and
   trees so the player remains unaware of the rooms mathematical
   rigidity. It wouldn't so for things to look like they were lined up on
   a checker board.
</para>
<para>
   In AGI games, the priority bands lie roughly in the following y
   ranges:
</para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Priority band</entry>
       <entry>Y range</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry> 4</entry> <entry>    -    </entry>
      </row>
      <row>
       <entry> 5</entry> <entry> 48 - 59 </entry>
      </row>
      <row>
       <entry> 6</entry> <entry> 60 - 71 </entry>
      </row>
      <row>
       <entry> 7</entry> <entry> 72 - 83 </entry>
      </row>
      <row>
       <entry> 8</entry> <entry> 84 - 95 </entry>
      </row>
      <row>
       <entry> 9</entry> <entry> 96 - 107</entry>
      </row>
      <row>
       <entry>10</entry> <entry>108 - 119</entry>
      </row>
      <row>
       <entry>11</entry> <entry>120 - 131</entry>
      </row>
      <row>
       <entry>12</entry> <entry>132 - 143</entry>
      </row>
      <row>
       <entry>13</entry> <entry>144 - 155</entry>
      </row>
      <row>
       <entry>14</entry> <entry>156 - 167</entry>
      </row>
      <row>
       <entry>15</entry> <entry>   168   </entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>
<para>
   The reason that there is no priority 0 to 3 shown above is because
   they don't exist. Priority four has the least priority. It is given to
   the background components. Nothing is ever given a priority of four
   except for the background parts of the picture itself. The colours
   black, blue, green, and cyan are infact used for control lines because
   the control lines and the priority bands are drawn on the same screen
   for AGI games, and this means that there would be a clash if we had
   priority 0 to 3.
</para><para>
   I've checked all the AGI games including those using version 3 and it
   looks as if nothing is ever drawn below 168. Some objects in the
   picture might have a priority of 15. These objects will start from a
   position with a Y component of 168. Ego can never walk below 167 and
   thus never has a priority of 15. SCI games are obviously a bit
   different because they extend the pictures down to the full 200
   pixels.
</para>
</sect2>

<sect2><title>Control lines</title>
<para>
   As the room nears completion, the artist adds control lines that
   determine where Ego can walk. Ego shouldn't walk through a wall or
   tree, for example, but sometimes Ego does. The Sierra staff spend a
   lot of time running Ego all over the rooms looking for places where
   Ego falls off or walks through something Ego shouldn't. Fixing an
   error may involve shifting things around or adding new features to a
   room to cover up a bug. I remember finding a bug in Space Quest 2
   which allowed Roger to walk off into space in the starting room.
</para><para>
   These are the black, blue, green, and cyan lines that
   you see drawn on the priority screen. They control what happens to ego
   when he or she walks past these lines. They might trigger a falling
   script for the edge of a cliff or a drowning script for the edge of a
   lake. There are four types of control lines:
</para><para>
   <itemizedlist>
    <listitem>
     <para>the black control line is a unconditional obstacle;</para>
    </listitem>
    <listitem>
     <para>the blue is a conditional obstacle;</para>
    </listitem>
    <listitem>
     <para>the green is an alarm line;</para>
    </listitem>
    <listitem>
     <para>the cyan is typically used for water (or something that a
      VIEW can be confined to being on).</para>
    </listitem>
   </itemizedlist>
</para>
<para>
   In most games, black and blue appear to be used for obstacle use which
   means that Ego can't walk past that line. This is the main use for
   control lines. Other uses include triggers which active an event. For
   example, control lines are used at the edge of water, or the edge of a
   cliff to tell the interpreter at what point it should execute its
   ``drowning'' or ``falling'' sequence of events. We can all remember the
   nasty trap that the hunter beast on Labion set for us in Space Quest
   II. This is activated when Ego walks past a green control line.
</para>
<para>
   The cyan control line will often be a whole filled area. A VIEW object
   such as a crocodile can be given the <function/object.on.water/ command and
   then told to wander. The interpreter will only allow the crocodile to
   wander over the area that has a control colour of cyan.
</para>

<sect2><title>Control lines and priority information</title>
<para>
   In the AGI interpreter, the priority bands and control lines are drawn
   on the same screen. This can lead to problems when the interpreter
   wants to know the priority of a pixel that has a control line drawn
   over it. The way that the interpreter deals with this is to search
   downwards until it finds a pixel that isn't a control line and it
   assumes that the pixel it is looking at is the same priority as the
   one it found by searching downwards (increasing Y). Usually this will
   be the pixel immediately below but for some pixels this can be as far
   away as twenty pixels or more!! In some games this can cause a
   noticeable visual error if you are aware of it. For example, you could
   walk behind a strip of grass that thinks it is part of the tree below
   it (KQ1, room 20, blue control line beside left hand tree). There are
   also a number of other one pixel visual errors that are virtually
   unnoticeable if you don't know they are there.
</para><para>
<programlisting>
                             _
                            |_| <- priority required for this pixel.
      Search downwards  |   |_| \
      for next pixel    |   |_|  \___ These pixels have all got a control
      with a priority  \|/  |_|  /    line covering their priority info.
                        V   |_| /
                            |_| <- use this pixels priority.
</programlisting>
</para><para>
   It may be possible to draw the control lines on a separate screen
   altogether which would conserve the priority information.
</para>

</sect1>
</chapter>


<chapter id="agi"><title>AGI internals</title>

<sect1 id="intworks"><title>How the interpreter works</title>
<para>
(From the AGDS documentation, translated by Vassili Bykov)
</para><para>
   The AGI interpreter contains:
   <itemizedlist>
    <listitem>
     <para>256 8 bit variables, numbered from 0 to 255;</para>
    </listitem>
    <listitem>
     <para>256 flags, numbered from 0 to 255;</para>
    </listitem>
    <listitem>
     <para>a number of objects controlled by the interpreter, one of which
     (the object 0) may be controlled by the player using the keyboard;</para>
    </listitem>
    <listitem>
     <para>a number of inventory members;</para>
    </listitem>
    <listitem>
     <para>12 40-character string variables).</para>
    </listitem>
   </itemizedlist>
</para><para>
   Some variables (0 - 26) and flags (0 - 15) are reserved by the
   interpreter, all others are available to be used by the programmer.
</para><para>
   The interpreter provides a common variable and flag space for all the
   scripts simultaneously loaded in the memory. The number of objects
   and things is determined by the OBJECT resource.
</para><para>
   The interpreter's actions are described using the commands of its
   language. For example, there are commands to manage objects, load
   and unload resources, etc. These commands will be described in
   detail in <xref linkend="cmdref">.
</para><para>
   Note: Any variable, flag, object, string, word, message, etc. has a
   unique ID number, and numbering of different data types is independent
   (for example, there can be a variable number 5, a string number 5,
   and a flag number 5).
</para>

<sect2><title>Resources - the fundamental AGI data type</title>
<para>
   When we develop a game, we invent the plot, create objects of the
   game, animate them, develop scenery and a dictionary of words for the
   dialogue with the player. To describe all of these, resources are
   used. To create some of the resources, we use utilities included with
   AGDS, in this case the input of the utilities are resources.
   <emphasis>(Sounds weird, but that's literally what it says. --VB)</emphasis>
</para><para>
   Here is a list of all the existing resources. Resources are used to
   represent:
   <itemizedlist>
    <listitem><para>
      colour background drawings (PICTURE resource);
    </para></listitem>
    <listitem><para>
      colour animated images (VIEW resource);
    </para></listitem>
    <listitem><para>
      sound effects (music, noise) (SOUND resource);
    </para></listitem>
    <listitem><para>
      inventory members and other objects (OBJECT resource);
    </para></listitem>
    <listitem><para>
      system dictionary for communicating with the user (WORD resource);
    </para></listitem>
    <listitem><para>
      programs in internal AGI programming language (LOGIC resource).
    </para></listitem>
   </itemizedlist>
</para>
</sect2>

<sect2><title>General principles of the interpreter operation</title>
<para>
   Let us now consider the interpreter algorithm and the purpose of
   reserved variables and flags.
</para><para>
   When interpreter starts, LOGIC resource number 0 is loaded in memory.
   It stays there during the whole play time and determines all the
   interpreter's actions related to the overall control of the game. The
   interpreter works in a loop, i.e. all its actions are described in
   <xref linkend="workcycle"> and the block diagram below.
</para><para>
   In each cycle the interpreter performs the following basic actions:
   <orderedlist>
    <listitem><para>
      time delay;
    </para></listitem>

    <listitem><para>
      clear the keyboard buffer;
    </para></listitem>

    <listitem><para>
      poll the keyboard and the joystick;
    </para></listitem>

    <listitem><para>
      analyse some of the reserved variables and flags (see block diagram);
    </para></listitem>

    <listitem><para>
      for all controllable objects for which <function/animate_obj/,
      <function/start_update/ and <function/draw/ commands were issued,
      directions of motion are recalculated;
    </para></listitem>

    <listitem><para>
      logic resource 0 is executed, as well as any logics it
      calls -- which, in turn, can call other logics. Depending on the
      state of variables and flags analyzed at step 4 the number of
      commands interpreted at stage 4 commands varies from one iteration
      of the cycle to another depending, for example, on a number of
      logic resources to be called in the current situation;
    </para></listitem>

    <listitem><para>
      test if the <function/new_room/ command has been issued;
    </para></listitem>
   </orderedlist>

   then the cycle is repeated.
</para><para>
   All logics (programs and subroutines) simultaneously loaded in memory
   operate on a common set of variables, flags, and strings, each
   identified by a unique for each data type ID number.
</para><para>
   The fact that the interpreter runs in a loop influences the general
   programming principles and style when programming for AGDS. This makes
   programming a little unusual and takes a certain time to get used to.
   For example, many cyclic activities requiring explicit loops in
   ``conventional'' programming languages are executed in the interpreter
   programs by default, provided the program has a proper structure.
</para><para>
   General hints on how to reduce the time to adapt to the interpreter's
   language are given below, using an educational program Thunderstorm
   as an example. However, this does not reduce the usefulness of
   analyzing the game programs of Sierra On-Line, Inc.
</para>
</sect2>

<sect2 id="workcycle"><title>Interpreter work cycle</title>
<para>
<programlisting>
                     +---------------------------+
                     |      1. delay time        |
                     +---------------------------+
                                   |
                                   V
                     +----------------------------+
                     |2. clear the keyboard buffer|
                     +----------------------------+
                                   |
                                   V
                     +---------------------------+
                     |      Flag (2) - > 0       |
                     |      Flag (4) - > 0       |
                     +---------------------------+
                                   |
                                   V
                 +-------------------------------------+
                 | 3. poll keyboard and joystick       |
                 +-------------------------------------+
                                   |
                                   V
                 +-------------------------------------+
                 | If the current mode is              |
                 | - program_control, the direction of |
                 |   Ego motion <-- var(6).            |
                 | - player.control, var (6) --> dir.  |
                 |   of Ego motion.                    |
                 +-------------------------------------+
                                   |
                                   V
    +---------------------------------------------------------------+
    | For all objects for which command animate.obj, start_update   |
    | and draw were carried out, the recalculation of the direction |
    | of movement is performed.                                     |
    +---------------------------------------------------------------+
                                   |
                                   V
    +---------------------------------------------------------------+
    | If the score has changed (var (3)) or the sound has been      |
    | turned on or off (Flag (9)), the status line is updated.      |
    +---------------------------------------------------------------+
                                   |
                                   +---------+
                                             V
                               +--------------------------+
             +---------------->| 4 Logic 0 is executed    |
             |                 +--------------------------+
             |                               |
             |                               V
             |          +--------------------------------------+
             |          | - Dir. of motion of Ego  <-- var (6) |
             |          | - If score (var (3)) or Flag (9)     |
             |          | have changed their values - update   |
             |          | the status and score (on Var (3));   |
             |          | - Var (5) - > 0;                     |
             |          | - Var (4) - > 0;                     |
             |          | - Flag (5) - > 0!!!!                 |
             |          | - Flag (6) - > 0;                    |
             |          | - Flag (12) - > 0.                   |
             |          +--------------------------------------+
 +----------------------------+               |
 | Execute:                   |               V
 | ~~~~~~~~~~~~~~~~~~~~~~~~   |  +------------------------+
 | - stop.update;             |  | Update all controlled  |
 | - unanimate.all;           |  | objects on the screen. |
 | - destroy all logic        |  +------------------------+
 |   resources except         |                   |
 |   for logic 0;             |                   V
 | - player.control;          |            +--------------+
 | - unblock;                 |            | new.room n   |
 | - set_horizon 36;          |            | or           |
 | - var (1) = var (0);       |            | new.room.v n |
 | - var (0) = n | Var(n);    |            | was issued?  |
 | - var (4) = 0;             |            |              |
 | - var (5) = 0;             |            +-------+------+
 | - var (9) = 0;             |<-----------+  Yes  |  No  |
 | - var (16) = number of     |            +-------+--+---+
 | view assoc. w/Ego;         |                       |
 | - Ego coords from var (2); |                       |
 | - var (2) = 0;             |                       |
 | - flag (2) - > 0;          |                       V
 | - flag (5) - > 1!!!!       |               +--------------+
 | - score < - var (3);       |               | Go to step 1 |
 +----------------------------+               +--------------+
</programlisting>
</para>
</sect2>
</sect1>

<sect1 id="vartypes"><title>Variable types</title>
<para>

   There is a number of data types used as AGI command parameters,
   listed below:
</para>

<sect2><title>Variable</title>
<para>
   This is an unsigned eight-bit variable type equivalent of a byte, or
   unsigned char. Its values range from 0 to 255. There are 256 variables
   and in the LOGIC code (listed in <xref linkend="varlist">);
   they are numbered from 0 to 255 and are indentified by their number.
   (The original LOGIC source code that Sierra's programmers wrote would
   have had textual identifiers for these variables, but when the LOGIC
   source was compiled into the LOGIC codes, the original variable names
   were lost. To the interpreter, the variables are known by their index
   into the variable table.)
</para><para>
   Variables are the most commonly used type. They feature in arithmetic
   commands such as addition and multiplication, and a lot of AGI commands
   have a version that has variable paramaters as an alternative to the
   normal constant parameter versions.
</para>

<sect2><title>Flag</title>
<para>
   Flags are the boolean type of the AGI system. Their value can be
   either 1 or 0 (true or false). There are 256 flags that are numbered 0
   to 255. (In the original LOGIC source code, they would have had textual
   identifiers, but in the compiled LOGIC code they are known only by
   their index into the interpreters flag table.)
</para><para>
   Flags are used to indicate when certain things have taken place.
</para>

<sect2><title>String</title>
<para>
   According to another source, there are only 12 strings available. I
   don't know if this is true, but it agrees with the minimum amout of
   space set aside for strings that I have seen in examining memory usage
   during a game. However, the majority of AGI games have enough room for
   exactly 24 strings: AGI interpreter versions 2.089, 2.411, 3.002.107
   and 3.002.149 have room for 12 strings, the remaining versions have
   room for 24 strings.
</para><para>
   Whether the versions that have enough space for 24 strings do infact
   support 24 strings is not known. Strings are 40 characters long which
   includes the zero terminator. String number zero is usually the input
   prompt (e.g. <prompt/">"/ or <prompt/"]"/).
</para>

<sect2><title>Word</title>
<para>
   Words are the words that the user types in. An input sentence is
   composed of a number of words. The important words (e.g. for the
   sentence ``look at the tree'', ``look'' and ``tree'' are important) are
   assigned to the words variables corresponding to their place in the
   sentence once unimportant words and punctuation has been taken out.
   For example, in the earlier example <literal/word(1)/ would be ``look'' and
   <literal/word(2)/ would be ``tree''. Words can be converted to strings.
</para>

<sect2><title>Inventory Item</title>
<para>
   There are a number of AGI commands that refer to inventory members (e.g.
   <function/get/, <function/drop/). One of the arguments to these commands will
   represent an inventory member number. In the original script source text,
   the programmer would have written things like <function/get(dagger)/ but the
   interpreter knows them only as an index into the OBJECT table.
</para>

<sect2><title>Object</title>
<para>
   There can be a bit of confusion between this type and the inventory
   member because of the name of the <filename/object/ file. The
   <filename/object/ file has almost nothing to do with what the
   interpreter generally calls objects. There are a large number of
   AGI commands that deal with objects. For example,
</para><para>
<programlisting>
move.obj
animate.obj
set.view
set.cel
set.loop
draw
</programlisting>
</para><para>
   In fact the interpreter calls its usage of the VIEW resource
   ``objects''. An object is one usage of a VIEW resource. It is
   essentially an entry in the object table (or VIEW table/VIEW list).
   Many objects can use the same VIEW resource for its appearance which
   can be seen in KQ1 and BC with the crocodile filled moats.
</para><para>
   So when an AGI command has an object as a parameter to it, the value
   of the parameter is an index number into a table of objects that the
   interpreter is currently controlling.
</para>

<sect2><title>Message</title>
<para>
   At the end of every LOGIC file is a message section. There need not be
   any messages in it, but it will still exist. Messages in <filename/logic.0/
   are global messages whereas all other messages can only be accessed from
   their own LOGIC code. AGI commands that have messages as parameters
   refer to a message number in their own LOGIC file. I say that those in
   <filename/logic.0/ are global because messages and strings can contain format
   codes one of which is used to display messages from <filename/logic.0/.
</para><para>
   Example:

<programlisting>
print ("Message 34 in logic.0 is %g34.");
</programlisting>

</para><para>
   Therefore messages in <filename/logic.0/ can be displayed by any
   script in this way.
</para>
</sect1>

<sect1 id="varlist"><title>Variables used by the interpreter</title>
<para>
   On interpreter startup all variables are set to 0.

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row> <entry>Variable</entry> <entry>Description</entry> </row>
     </thead>
     <tbody>
      <row> <entry>0</entry> <entry>Current room number (parameter new_room cmd), initially 0.</entry> </row>
      <row> <entry>1</entry> <entry>Previous room number.</entry> </row>
      <row> <entry>2</entry> <entry>Code of the border touched by Ego:
        <simplelist>
         <member>0 - Touched nothing
         <member>1 - Top edge of the screen or the horizon
         <member>2 - Right edge of the screen
         <member>3 - Bottom edge of the screen
         <member>4 - Left edge of the screen
        </simplelist>
       </entry> </row>
      <row> <entry>3</entry> <entry>Current score.</entry> </row>
      <row> <entry>4</entry> <entry>Number of object, other than Ego, that touched the border.</entry> </row>
      <row> <entry>5</entry> <entry>The code of border touched by the object in Var (4).</entry> </row>
      <row> <entry>6</entry> <entry>Direction of Ego's motion.
   <literal>
                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - the object
                    / | \                is motionless
                  /   |   \
                6     |     4
                      5
   </literal>
       </entry> </row>
      <row> <entry>7</entry> <entry>Maximum score.</entry> </row>
      <row> <entry>8</entry> <entry>Number of free 256-byte pages of the interpreter's memory.</entry> </row>
      <row> <entry>9</entry> <entry>If == 0, it is the number of the word in the user message that was</entry> </row>
   not found in the dictionary. <emphasis>(I would assume they mean "if != 0", but
   that's what they say. --VB)</emphasis>
      <row> <entry>10</entry> <entry>Time delay between interpreter cycles in 1/20 second intervals.</entry> </row>
      <row> <entry>11</entry> <entry>Seconds (interpreter's internal clock)</entry> </row>
      <row> <entry>12</entry> <entry>Minutes (interpreter's internal clock)</entry> </row>
      <row> <entry>13</entry> <entry>Hours (interpreter's internal clock)</entry> </row>
      <row> <entry>14</entry> <entry>Days (interpreter's internal clock)</entry> </row>
      <row> <entry>15</entry> <entry>Joystick sensitivity (if Flag (8) = 1).</entry> </row>
      <row> <entry>16</entry> <entry>ID number of the view-resource associated with Ego.</entry> </row>
      <row> <entry>17</entry> <entry>Interpreter error code (if == 0) <emphasis>(Again I would expect this</entry> </row>
	to say ``if != 0''. --VB)</emphasis>
      <row> <entry>18</entry> <entry>Additional information that goes with the error code.</entry> </row>
      <row> <entry>19</entry> <entry>Key pressed on the keyboard.</entry> </row>
      <row> <entry>20</entry> <entry>Computer type. For IBM-PC it is always 0.</entry> </row>
      <row> <entry>21</entry> <entry>If Flag (15) == 0 (command reset 15 was issued) and Var (21) is</entry> </row>
   not equal to 0, the window is automatically closed after 1/2 * Var
   (21) seconds.
      <row> <entry>22</entry> <entry>Sound generator type:
        <simplelist>
         <member>1 - PC
         <member>3 - Tandy
        </simplelist>
       </entry> </row>
      <row> <entry>23</entry> <entry>0:F - sound volume (for Tandy).</entry> </row>
      <row> <entry>24</entry> <entry>This variable stores the maximum number that can be entered</entry> </row>
      in the input line. By default, this variable is set to 41 (29h).
      (information by Dark Minister)
      <row> <entry>25</entry> <entry>ID number of the member selected using status command or 0xFF if ESC</entry> </row>
   was pressed.
      <row> <entry>26</entry> <entry>monitor type
       <simplelist>
         <member>0 - CGA
         <member>2 - HCG
         <member>3 - EGA
       </simplelist>
      </entry> </row>
     </tbody>
    </tgroup>
   </informaltable>
</para>
</sect1>

<sect1 id="flaglist"><title>Flags used by the interpreter</title>
<para>
   On the interpreter startup all flags are set to 0.
</para><para>
   <informaltable>
    <tgroup cols="2">
     <thead>
      <row> <entry>Flag</entry> <entry>Description</entry> </row>
     </thead>
     <tbody>
      <row> <entry>0</entry> <entry>Ego base line is completely on pixels with priority = 3 (water</entry> </row>
   surface).
      <row> <entry>1</entry> <entry>Ego is invisible of the screen (completely obscured by another</entry> </row>
   object).
      <row> <entry>2</entry> <entry>the player has issued a command line.</entry> </row>
      <row> <entry>3</entry> <entry>Ego base line has touched a pixel with priority 2 (signal).</entry> </row>
      <row> <entry>4</entry> <entry><function/said/ command has accepted the user input.</entry> </row>
      <row> <entry>5</entry> <entry>The new room is executed for the first time.</entry> </row>
      <row> <entry>6</entry> <entry><function/restart_game/ command has been executed.</entry> </row>
      <row> <entry>7</entry> <entry>if this flag is 1, writing to the script buffer is blocked.</entry> </row>
      <row> <entry>8</entry> <entry>if 1, Var(15) determines the joystick sensitivity.</entry> </row>
      <row> <entry>9</entry> <entry>sound on/off.</entry> </row>
      <row> <entry>10</entry> <entry>1 turns on the built-in debugger.</entry> </row>
      <row> <entry>11</entry> <entry>Logic 0 is executed for the first time.</entry> </row>
      <row> <entry>12</entry> <entry>`restore_game' command has been executed.</entry> </row>
      <row> <entry>13</entry> <entry>1 allows the `status' command to select members.</entry> </row>
      <row> <entry>14</entry> <entry>1 allows the menu to work.</entry> </row>
      <row> <entry>15</entry> <entry>Determines the output mode of `print' and `print_at' commands
      <simplelist>
       <member>1 - message window is left on the screen
       <member>0 - message window is closed when <keycap/ENTER/ or
         <keycap/ESC/ key are pressed.
         If Var(21) is not 0, the window is closed automatically after 1/2 *
         Var(21) seconds
      </simplelist>
      </entry> </row>
     </tbody>
    </tgroup>
   </informaltable>
</para>
</sect1>

<sect1 id="memory"><title>Memory organization</title>
<para>

   The following information gives a rough guide as to how Sierra's AGI
   interpreter uses its memory. You can view this in operation in MS-DOS
   by using a memory resident program like Game Wizard.
</para><para>
<programlisting>
                    Length of first data area (2 bytes)

                          Game signature (8 bytes)

                           Variables (256 bytes)

                         Flags (256 bits, 32 bytes)

              Timers, blocks, and other special AGI variables

                    Strings (12*40 bytes or 24*40 bytes)

                                  unknown

                         "Press ENTER to quit" etc

                         Script command jump table

                      "Avis Durgan" encryption string

                       Rest of agidata.ovl is in here

                                  unknown

                               words.tok file

                                object file

                             VIEW object table

                                  logic.0

                           Other loaded resources
</programlisting>


</para>
</sect1>

<sect1 id="gameid"><title>Game IDs and loaders</title>
<para>

   Since the data formats for the different AGI interpreter versions are
   mostly identical or easily convertible to each other, we should expect
   to be able to run one games data with anothers interpreter. This
   sounds like a reasonable assumption but when you try it, the
   interpreter rejects the new data. The reason behind this is
   <emphasis>game IDs</emphasis>.
</para><para>
   Every interpreter has got a game ID coded into it and it expects to be
   given data for that game. Somewhere in the initialization code for
   each game is a <function/set.game.id/. When this command is encountered, the
   interpreter checks the given game ID and compares it with its own. If
   they are not the same, it quits immediately. Presumably the reason for
   this was to stop people running games with the wrong interpter
   version, which can cause problems (unless you know what you're doing).
</para>

<sect2><title>How do we get around it?</title>
<para>
   <emphasis>Method 1: The hard way.</emphasis>
</para><para>
   Well, basically we have to find the game ID signature in the AGI
   interpreter file and change it to the ID of the game whose data we
   wish to be executed.
</para><para>
   Here are a few examples of some game ID's and the data following them:

   <simplelist>
    <member>Police Quest: <literal/'P' 'Q' 0x00 'e' 'I' 'D' 'X'/
    <member>Mother Goose: <literal/'M' 'G' 0x00 'e' 'I' 'D' 'X'/
    <member>Manhunter 2: <literal/'M' 'H' '2' 0x00 'I' 'D' 'X'/
    <member>XMAS Demo: <literal/'X' 'M' 'A' 'S' 0x00 'D' 'X'/
    <member>Leisure Suit Larry: <literal/'L' 'L' 'L' 'L' 'L' 0x00 'X'/
   </simplelist>
</para><para>
   The game ID itself is the null terminated string that ends at the 00h.
   The text that follows it is of no significance, it is simply to fill
   in the gap although it is useful when searching for the game ID
   because, as you can see, this text is always <literal/"eIDX"/> (presubably
   from ``gameIDX'' before being overwritten by the actual ID) or a suffix
   of it (i.e. <literal/"IDX"/, <literal/"DX"/, or <literal/"X"/). For most games,
   the game ID is two or three characters which means that you will be able
   to rely on the <literal/"IDX"/ string being there for these games.
</para><para>
   <emphasis>Method 2: The easy way</emphasis>
</para><para>
   Using the above method will allow you to run a different game with an
   interpreter, but you will still only be able to run the game that has
   the specified game ID. There is another way around this, which
   involves patching the logic source. This can be accomplished using
   a program to edit the logics such as AGI Studio (for the Windows platform).
   What you can usually do is look at the top part of logic 0 and find
   out what the initialization logic is (usually around 90--100 -- you
   might have to look at a few logics before you find it).  Then simply
   go to that logic, find the <function/set.game.id/ command, remove it,
   and recompile the logic. Since the command is not used, the
   interpreter will not try and compare it with it's own ID, and it won't
   quit.
</para><para>
   The only drawback to using this method is that the saved games no
   longer have the game ID in their name (so, for example, a savegame
   would be called <filename/sg.1/ instead of <filename/kq2sg.1/),
   but this is not a major hassle.
</para>

<sect2><title>Why can't I find the game ID?</title>
<para>
   This is because a lot of the AGI files themselves are encrypted.
   See <xref linkend="crypt"> for further information.
</para>

<sect2><title>Possibilities</title>
<para>
   What this means is that with a few useful AGI utility programs, it is
   possible to run any set of game data with a compatible AGI
   interpreter. For example, games that use AGI versions 2.915, 2.917,
   and 2.936 should be able to be converted into AGIv3 format and run
   with an AGIv3 interpreter.
</para><para>
   ``Compatible'' as it is used above refers not only to the data
   differences but also to some AGI command descrepencies. There are
   about four AGI commands that have changed the number of arguments
   passed to them as the interpreter developed. This sort of thing is the
   only real obstacle to running data on another interpreter.
</para>
</sect1>

<sect1 id="crypt"><title>Encrypted AGI data</title>
<para>

   Many AGI files are encrypted. This
   was probably to give some protection to their product which was quite
   unique at the time. You can tell the difference between an encrypted
   AGI file and a non-encrypted AGI file by the first two characters. If
   they are ``MZ'' (the MS-DOS executable file header), then it not encrypted.
</para><para>
   The AGI file is decrypted by the loader program. This is usually
   called <filename/sierra.com/ in MS-DOS but can also be named after the game
   (eg. <filename/kq1.com/). In AGI version 1, the loader was called
   <filename/load/.
   If an AGI game doesn't have a loader, then it shouldn't be encrypted.
   If an AGI game does have a loader, it does not necessarily mean that
   the AGI file is encrypted.
</para><para>
   The decryption key was not originally embedded in the loader file. If
   you find a game where the key is embedded in the loader, it is because
   that game has had copy protection removed. There are several utilities
   to do that. Anders M. Olsson's <emphasis>SUP</emphasis> is one of them.
   The CD re-releases have been unprotected by Sierra in exactly the same
   fashion.
</para><para>
   The loader would read the decryption key from track 6 of the disk,
   load the executable file, decrypt and run it. Track 6 had a special
   format that was supposedly impossible to exactly reproduce by a
   standard PC floppy disk controller.
</para><para>
   An interesting note is that when a copy-protected Sierra game asked
   for the original disk one, you could insert disk one from
   <emphasis>any</emphasis> protected Sierra game. The contents of
   track 6 were always the same.
</para><para>
   But even though track 6 was the same, all games didn't use exactly the
   same encryption key. The two bytes in the loader, immediately
   following the string <literal/"keyOfs"/, gave an offset on track 6
   from where the key would be loaded.
</para><para>
   So, if the decryption string consists of 128 `k' characters, it can
   actually mean one of two things: Either the AGI file is not encrypted,
   or the game is still copy-protected.
</para>

<sect2><title>How does the encryption work?</title>
<para>
   The loader contains a 128 byte string called the decryption key.
   Here's the process of decryption:
   <orderedlist>
    <listitem><para>
      The carry bit is zeroed.
    </para></listitem>
    <listitem><para>
      The first 128 bytes of the AGI file are XORed with the decryption key.
    </para></listitem>
    <listitem><para>
      The whole key string is rotated one bit to the right, including
      the carry-bit. (Bit 7 of the first byte is loaded from the carry.
    </para></listitem>
    <listitem><para>
      Bit 0 of the last byte is placed in the carry, where it will
      remain until the next rotation.
    </para></listitem>
    <listitem><para>
      The bit that was bit 0 of the last byte (now in carry) is ORed
      into bit 7 of the first byte.
    </para></listitem>
    <listitem><para>
      The next 128 bytes of the AGI file are XORed with the new key. If
      the end of the AGI file has not been reached, then go back to 3.
    </para></listitem>
   </orderedlist>
</para>

<sect2><title>Where in the loader is the decryption key?</title>
<para>
   The start of a loader will look something like this:
</para><para>
<programlisting>
LOADER v3.0 (c) Copyright Sierra On-Line, Inc. 1987 keyOfs
</programlisting>
</para><para>
   There are two bytes in between the <literal/"keyOfs"/ string and the start of
   the description string. If the decryption key consists of 128 `k'
   characters, then the AGI file is not encrypted (or the game is still
   copy-protected). If it consists of a whole lot of random looking
   characters, then it is encrypted.
</para><para>
   As an aside, the decryption string is followed immediately by the
   stack and is usually marked with a whole string of `s' characters.
   Thus we have `k' for key and `s' for stack. The stack is usually 256
   bytes long.
</para>

<sect2><title>Decrypting the AGI file</title>
<para>
   Decrypting the AGI file is simply a matter of writing a program to
   read the loader to get the decryption string, and then applying the
   process mentioned above to the AGI file. Once this has been done, the
   game ID can be located.
</para>
</sect1>

<sect1 id="parsing"><title>Player input parsing</title>
<para>
From the AGDS documentation, translated by Vassili Bykov.
</para><para>
   Note: This section is an excerpt from the description of the
   <function/said/ command from <xref linkend="cmdref">.
</para><para>
   Here is how the input is matched. After the player types a message and
   presses <keycap/ENTER/, the input line is processed by the interpreter in
   the following way:
   <orderedlist>
    <listitem><para>
      The interpreter removes all punctuation marks.
    </para></listitem>
    <listitem><para>
      All characters are converted to lowercase.
    </para></listitem>
    <listitem><para>
      All sequences of more than one space are replaced with a single
      space.
    </para></listitem>
    <listitem><para>
       Starting with the first word of the input, the interpreter looks
       up the vocabulary, trying to find the longest character sequence
       matching the input line.
    </para></listitem>
   </orderedlist>
</para><para>
   If the search is unsuccessful, <parameter/v9/ is assigned the number
   of the word in the message that failed to match and the processing
   ends. If all the words have been assigned some codes:
</para><para>
   <simplelist>
    <member>The Interpreter removes from the sequence of codes all zeros (that
       means all vocabulary words with zero codes are ignored).
    <member><literal/f2/ (the user has entered an input line) is set to 1
    <member><literal/f4/ (<function/said/ command accepted the user input) is set to 0.
   </simplelist>
</para><para>
   If the sequence of code produced by the interpreter is
</para><para>
   <quote>
   V(1), V(2),...V(m)
   </quote>
</para><para>
   The test is performed as follows:
</para><para>
   <quote>
   If <literal/f2/ == 0 or <literal/f4/ == 1, return FALSE.
   </quote>
</para><para>
   Compare parameters W(i) and codes V(i) as follows:
   <simplelist>
    <member>if W(i) = 1, it matches any V(i);
    <member>if W(i) = 9999, it matches the whole remaining input i.e. the
       codes V(i), V(i+1),...V(m).
   </simplelist>
</para><para>
   Otherwise W(i) should be equal to V(i).
</para><para>
   If all elements match, <literal/f4/ (<function/said/ accepted the
   user input) is set to 1 and the command returns TRUE. Otherwise,
   FALSE is returned.
</para>
</sect1>

<sect1 id="verctrl"><title>AGI interpreter versions</title>
<para>
</para>

<sect2><title>Sorted by Game</title>
<para>
<programlisting>
Game	Ver.	Int	Int. Ver.	Date
------- ------- ------- --------------- ---------
AGID	?.?	AGI	2.915		??/??/??
BC	2.00	AGI	2.439		06/14/87
BC	2.10	AGI	3.002.098	11/10/88
GR	2.01	AGI	3.002.149	12/22/88
KQ1	1.0U	AGI	2.272		Unknown
KQ1	2.0F	AGI	2.425		??/??/87
KQ1	2.0F	AGI	2.917		Unknown
KQ2	2.1	AGI	2.411		Unknown
KQ2	2.2	AGI	2.426		Unknown
KQ2	2.2	AGI	2.917		??/??/87
KQ3	1.01	AGI	2.272		11/08/86
KQ3	2.00	AGI	2.435		05/25/87
KQ3	2.14	AGI	2.936		03/15/88
KQ4	2.0	AGI	3.002.086	07/27/88
KQ4D	?.??	AGI	3.002.102	??/??/??
LSL1	1.00	AGI	2.440		06/01/87
LSL1	1.0	AGI	2.917		06/01/87
MG	?.??	AGI	2.915		Unknown
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
PQ1	2.0G	AGI	2.917		12/03/87
SQ1	1.0X	AGI	2.089		Unknown
SQ1	2.2	AGI	2.426		??/??/??
SQ1	2.2	AGI	2.917		??/??/??
SQ1	2.2	AGI	2.917		??/??/87
SQ2	2.0C	AGI	2.915		??/??/87
SQ2	2.0C	AGI	2.917		Unknown
SQ2	2.0D	AGI	2.936		Unknown
SQ2	2.0F	AGI	2.936		Unknown
XM86	?.??	AGI	2.272		Unknown
</programlisting>
</para>

<sect2><title>Sorted by Int. Ver.</title>
<para>
<programlisting>
Game	Ver.	Int	Int. Ver.	Date
------- ------- ------- --------------- ---------
SQ1	1.0X	AGI	2.089		Unknown
KQ1	1.0U	AGI	2.272		Unknown
KQ3	1.01	AGI	2.272		11/08/86
XM86	?.??	AGI	2.272		Unknown
KQ2	2.1	AGI	2.411		Unknown
KQ1	2.0F	AGI	2.425		??/??/87
KQ2	2.2	AGI	2.426		Unknown
SQ1	2.2	AGI	2.426		??/??/??
KQ3	2.00	AGI	2.435		05/25/87
BC	2.00	AGI	2.439		06/14/87
LSL1	1.00	AGI	2.440		06/01/87
AGID	?.?	AGI	2.915		??/??/??
MG	?.??	AGI	2.915		Unknown
SQ2	2.0C	AGI	2.915		??/??/87
KQ1	2.0F	AGI	2.917		Unknown
KQ2	2.2	AGI	2.917		??/??/87
LSL1	1.0	AGI	2.917		06/01/87
PQ1	2.0G	AGI	2.917		12/03/87
SQ1	2.2	AGI	2.917		??/??/??
SQ1	2.2	AGI	2.917		??/??/87
SQ2	2.0C	AGI	2.917		Unknown
KQ3	2.14	AGI	2.936		03/15/88
SQ2	2.0D	AGI	2.936		Unknown
SQ2	2.0F	AGI	2.936		Unknown
KQ4	2.0	AGI	3.002.086	07/27/88
BC	2.10	AGI	3.002.098	11/10/88
KQ4D	?.??	AGI	3.002.102	??/??/??
MH1	1.22	AGI	3.002.102	08/30/88
MH1	1.22	AGI	3.002.107	08/31/88
GR	2.01	AGI	3.002.149	12/22/88
MH2	3.02B	AGI	3.002.149	07/26/89
MH2	3.03	AGI	3.002.149	08/17/89
</programlisting>
</para>

</sect1>

<sect1 id="verdif"><title>Version differences</title>
<para>

   There are a number of different versions of the AGI interpeter but
   generally the data formats are the same or can easy be converted
   between each other. The following table is a list of AGI interpreter
   versions that I know of:
</para><para>
<programlisting>
     AGI       Interp.  Agidata   Num of   Object file  LZW
   version       size     size    commands   encrypted
   ---------- -------- -------- ---------- ------------ ----
   2.089	34305	  6656	   155		No	No
   2.272	34816	  6656	   161		No	No
   2.411	38400  	  7680	   169		Yes	No
   2.435	38400	  7680	   169		Yes	No
   2.439	38400	  7680	   169		Yes	No
   2.440	38400	  7680	   169		Yes	No
   2.915	39424	  8192	   173		Yes	No
   2.917	39424	  8192	   173		Yes	No
   2.936	39424	  8192	   175		Yes	No
   3.002.086	40866	  8064	   177		Yes	Yes
   3.002.098	40898	  8080	   181		Yes	Yes
   3.002.102	40898	  8080	   181		Yes	Yes
   3.002.107	40962	  8080	   181		Yes	Yes
   3.002.149	40520	  7488	   181		Yes	Yes
</programlisting>
</para><para>
   This table illustrates a number of things:
   <itemizedlist>
    <listitem><para>
      Firstly, as the interpreter version increased, the number of AGI
      commands supported increased with it. The last eleven we do not
      know the names of.
    </para></listitem>

    <listitem><para>
      There are two main AGI versions: AGI v2 and AGI v3.
    </para></listitem>

    <listitem><para>
      The early AGI v2 games did not encrypt the <filename/object/ file
      with the ``Avis Durgan'' string.
    </para></listitem>

    <listitem><para>
      AGI v3 games use adaptive LZW to compress their LOGIC, VIEW, and
      SOUND files.
    </para></listitem>
   </itemizedlist>
</para>

<sect2><title>Command argument number descrepancies</title>
<para>
   There are four commands that have changed the number of arguments that
   are passed to them. All this information is based on observations made
   of the above interpreter versions.
   <itemizedlist>
    <listitem><para>
      The <function/quit/ command had no arguments for version
      2.089 whereas all the others above have one argument.
    </para></listitem>

    <listitem><para>
      The <function/print.at/ and <function/print.at.v/ commands had only three
      arguments for versions 2.089--2.400 and four for the other versions.
    </para></listitem>

    <listitem><para>
      Unknown command number 176 had one argument for version
      3.002.086 but later versions had no arguments for this command.
    </para></listitem>
   </itemizedlist>
</para>

<sect2><title>Number of strings</title>
<para>
   There may be some differences in the number of strings supported by
   some interpreters as well. All interpreters have at least 12 strings.
   Most interpreters have space for 24 strings but I don't know if the
   extra space is used for strings or not.
</para>
</sect1>

</chapter>


<chapter id="logic"><title>The LOGIC language</title>
<sect1 id="syntax"><title>LOGIC syntax</title>
<para>

   This is the ``official'' LOGIC syntax that has been decided on. It is
   not the same syntax as Sierra used. All LOGIC decoders and compilers
   should comply with this syntax, so that programmers can be sure that
   code they produce can be used properly with any program.
</para>

<sect2><title>Action Commands</title>
<para>

   Normal action commands are specified by the command name followed by
   brackets which contain the arguments, separated by commas. A semicolon
   is placed after the brackets. The brackets are required even if there
   are no arguments. The arguments given must have the correct prefix for
   that type of argument as explained later in this document (this is to
   make sure the programmer does not use a var, for example, when they
   think they are using a flag).

<programlisting>
assign.v(v50,0);
program.control();
</programlisting>
</para><para>
   Multiple commands may be placed on the one line:

<programlisting>
reset(f6); reset(f7);
</programlisting>
</para><para>
   Substitutions for the following action commands are available:

<programlisting>
increment(v30);       v30++;
decrement(v30);       v30--;
assignn(v30,4);       v30 = 4;
assignv(v30,v32);     v30 = v32;
addn(v30,4);          v30 = v30 + 4; or v30 += 4;
addv(v30,v32);        v30 = v30 + v32; or v30 += v32;
subn(v30,4);          v30 = v30 - 4; or v30 -= 4;
subv(v30,v32);        v30 = v30 - v32; or v30 -= v32;
mul.n(v30,4);         v30 = v30 * 4; or v30 *= 4;
mul.v(v30,v32);       v30 = v30 * v32; or v30 *= v32;
div.n(v30,4);         v30 = v30 / 4; or v30 /= 4;
div.v(v30,v32);       v30 = v30 / v32; or v30 /= v32;
lindirectn(v30,4);    *v30 = 4;
lindirectv(v30,v32);  *v30 = v32;
rindirect(v30,v32);   v30 = *v32;
</programlisting>
</para>

<sect2><title><literal/if/ structures and test commands</title>
<para>
   An <literal/if/ structure looks like this:
</para><para>
<programlisting>
if (&lt;test commands&gt;) {
    &lt;action commands&gt;
}
</programlisting>
</para><para>
   or like this :
</para><para>
<programlisting>
if (&lt;test commands&gt;) {
    &lt;action commands&gt;
}
else {
    &lt;more action commands&gt;
}
</programlisting>
</para><para>
   Carriage returns are not necessary:
</para><para>
<programlisting>
if (&lt;test commands&gt;) { &lt;action commands&gt; } else { &lt;more action commands&gt; }
</programlisting>
</para><para>
   Test commands are coded like action commands except there is no
   semicolon. They are separated by &amp&amp or || for AND or OR.
</para><para>
<programlisting>
if (isset(f5) &&
    greatern(v5,6)) { ......
</programlisting>
</para><para>
   Again, carriage returns are not necessary within the if statement:
</para><para>
<programlisting>
if (lessn(v5,6) && (greatern(v5,2)) { .......

if (isset(f90) && equalv(v32,v34)
    && greatern(v34,20)) { .......
</programlisting>
</para><para>
   A ! placed in front of a command signifies a NOT.
</para><para>
<programlisting>
if (!isset(f7)) {
  ......
</programlisting>
</para><para>
   Boolean expressions are not necessarily simplified so they must follow
   the rules set down by the file format. If test commands are to be
   ORred together, they must be placed in brackets.
</para><para>
<programlisting>
if ((isset(f1) || isset(f2)) {
  ......

if (isset(f1) && (isset(f2) || isset(f3))) {
  ......

if (isset(1) || (isset(2) && isset(3))) {    is NOT legal
</programlisting>
</para><para>
   Depending on the compiler, simplification of boolean expressions may
   be supported, so the above may not apply in all cases (although if
   these are rules are followed then the logic will work with all
   compilers).
</para><para>
   Substitutions for the following test commands are available:
</para><para>
<programlisting>
equaln(v30,4)         v30 == 4
equalv(v30,v32)       v30 == v32
greatern(v30,4)       v30 > 4
greaterv(v30,v32)     v30 > v32
lessn(v30,4)          v30 < 4
lessv(v30,v32)        v30 < v32
!equaln(v30,4)        v30 != 4
!equalv(v30,v32)      v30 != v32
!greatern(v30,4)      v30 <= 4
!greaterv(v30,v32)    v30 <= v32
!lessn(v30,4)         v30 >= 4
!lessv(v30,v32)       v30 >= v32
</programlisting>
</para><para>
   Also, flags can be tested for by just using the name of the flag:
</para><para>
<programlisting>
if (f6) { .....

if (v7 > 0 && !f6) { .....
</programlisting>
</para>

<sect2><title>Argument types</title>
<para>
   There are 9 different types of arguments that commands use:

   <simplelist>
    <member>Number (no prefix)
    <member>Var (prefix ``v'')
    <member>Flag (prefix ``f'')
    <member>Message (prefix ``m'')
    <member>Object (prefix ``o'')
    <member>Inventory Item (prefix ``i'')
    <member>String (prefix ``s'')
    <member>Word (prefix ``w'')
    <member>Controller (prefix ``c'')
   </simplelist>
</para><para>
   The <function/said/ test command uses its own special arguments
   which will be described later.
</para><para>
   Each of these types of arguments is given by the prefix and then a
   number from 0--255, e.g. v5, f6, m27, o2.
</para><para>
   The word type is words that the player has typed in, not words that
   are stored in the <literal/words.tok/ file. Strings are the temporary string
   variables stored in memory, not to be confused with messages (that are
   stored in the LOGIC resources). Controllers are menu members and keys.
</para><para>
   Compilers can enforce type checking, so that the programmer must use
   the correct prefix for an argument so that they know they are using
   the right type. Decoders should display arguments with the right type.
</para><para>
<programlisting>
move.obj(so4,80,120,2,f66);
if (obj.in.box(so2,30,60,120,40)) { .....
</programlisting>
</para><para>
   A complete list of the commands and their argument types is available
   as part of AGI Specs.
</para><para>
   Messages and inventory members may be given in either numerical text
   format:
</para><para>
<programlisting>
print("He's not here.");
print(m12);
if (has("Jetpack")) { .....
if (has(io9)) { .....
</programlisting>
</para><para>
   Messages can also be split over multiple lines:
</para><para>
<programlisting>
print("This message is split "
      "over multiple lines.");
</programlisting>
</para><para>
   Quote marks must be used around messages and object names. This is
   important because some messages or object names may contain brackets
   or commas, which could confuse the compiler. This is also the case for
   the <literal/said/ command which will be described shortly.
</para><para>
<programlisting>
if (has("Buckazoid(s)")) { .....        // no ambiguity here about where
                                        // the argument ends
</programlisting>

</para><para>
   The <literal/said/ test command uses different parameters to all the other
   commands. Where as the others use 8 bit arguments (0--255), <literal/said/ takes
   16 bit arguments (0--65535). Also, the number of arguments in a <literal/said/
   command can vary. The numbers given in the arguments are the word
   group numbers from the <literal/words.tok/ file.
</para><para>

<programlisting>
if (said(4,80)) { .....
</programlisting>
</para><para>
   Words can also be given in place of the numbers:
</para><para>
<programlisting>
if (said("look")) { .....
if (said("open","door")) { .....
</programlisting>
</para><para>
   Quote marks must also be used around the words.
</para>

<sect2><title>Labels and the goto command</title>
<para>
   Labels are given like this:

<programlisting>
Label1:
</programlisting>

   The label name can contain letters, numbers, and the characters "_"
   and ".". No spaces are allowed.

   The <literal/goto/ command takes one parameter, the name of a label.

<programlisting>
goto(Label1);
</programlisting>
</para>

<sect2><title>Comments</title>
<para>
   There are three ways that comments can be used.

<programlisting>
// Rest of line is ignored
[  Rest of line is ignored
/* Text between these are ignored */
</programlisting>

   The /*...*/ can be nested:

<programlisting>
/* comment start
  print("Hello");    // won't be run
  /*                 // a new comment start (will be ignored!)
    v32 = 15;        // won't be run
  */                 // uncomments the most inner comment
  print("Hey!");     // won't be run, still inside comments
*/                   // uncomments
</programlisting>
</para>

<sect2><title>Defines</title>
<para>
   To give vars, flags etc. proper names the <literal/#define/ command is used.
   The name of the define is given followed by the define value:

<programlisting>
#define ego o0
#define room_descr "This is a large hall with tall pillars down each side."
</programlisting>

   Then the define name can be used in place of the define value:

<programlisting>
draw(ego);
print(room_descr);
</programlisting>

   Define names can only be used in arguments of commands (including
   <literal/goto/s and the <literal/v0 == 3/ type syntax), although some compilers
   may allow you to use them anywhere.

   Defines must be defined in the file before they are used.

   The define name can contain letters, numbers, and the characters <literal/'_'/
   and <literal/./. No spaces are allowed.
</para>

<sect2><title>Including files</title>
<para>
   You can include another file in your logic source code by using the
   <literal/#include/ command:

<programlisting>
#include "file.txt"
</programlisting>

   When the compiler encounters the above line, it will replace it with
   the contents of <literal/file.txt/.

   It is a good idea to have all the defines that you need for multiple
   logics in an <literal/#include/ file, so if you need to change the define value
   you only have to do it once (although you will need to recompile all
   logics that use that define).
</para>

<sect2><title>More on messages</title>
<para>
   In some cases you may want to assign a specific number to a message so
   you can refer to it in other places. This is done by using the
   <literal/#message/ command, followed by the number of the message then the
   message itself:

<programlisting>
#message 4 "You can't do that now."
</programlisting>

   Then you can give the message number as the parameter in commands:

<programlisting>
print(m4);
</programlisting>

   Or embed the message in commands as normal and the number you assigned
   to it before will be used:

<programlisting>
print("You can't do that now.");
</programlisting>

   <literal/#message/ can be used anywhere in the file, so you do not have to set
   the message before you use it.
</para>

<sect2><title>The return command</title>
<para>
   The return command is just a normal action command (number 0), with no
   arguments. This must be the last command in every logic.
</para>

</sect1>

<sect1 id="cmdref"><title>Reference of the LOGIC commands</title>
<para>
From the AGDS documentation translated by Vassili Bykov,
</para>

<sect2><title>Arithmetic commands</title>
<para>
   Commands that operate on variables:
   <variablelist>
    <varlistentry>
      <term><function id="increment">increment(n)</function></term>
      <listitem><para>
       The value of the variable <parameter/n/ is incremented by one,
       i.e. <parameter/vn/ = <parameter/vn/+1. If the value is already
       255, it is left unchanged.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="decrement">decrement(n)</function></term>
      <listitem><para>
       The value of the variable <parameter/vn/ is decremented by one,
       i.e. <parameter/vn/ = <parameter/vn/-1. If the value is 0, it
       is left unchanged.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="assign">assign(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is assigned the value m, i.e.
       <parameter/vn/ = <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="assignv">assignv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is assigned the value of <parameter/vm/,
       i.e. <parameter/vn/ = <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="addn">addn(n,m)</function>, <function id="addv">addv(n,m)</function></term>
      <listitem><para>
       The value of variable <parameter/vn/ is incremented by <parameter/m/
       (<parameter/vm/), i.e. <parameter/vn/ = <parameter/vn/ + <parameter/m/
       (<parameter/vm/).
      </para><para>
       If the value is greater than 255 the result wraps over 0
       (so 250 + 10 == 4).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="subn">subn(n,m)</function>, <function id="subv">subv(n,m)</function></term>
      <listitem><para>
       The value of <parameter/vn/ is decremented by <parameter/m/
       (<parameter/vm/), i.e. <parameter/vn/ = <parameter/vn/ - <parameter/m/
       (<parameter/vm/).
       If the value is lesser than 0 the result wraps (so 1 - 2 == 255).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="lindirectn">lindirectn(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vi/ where <emphasis/i/ is the value of
       <parameter/vn/ is assigned a value <parameter/m/, i.e.
       Var(<parameter/vn/) = <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="lindirectv">lindirectv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vi/ where <emphasis/i/ is the value of
       <parameter/vn/ is assigned the value of <parameter/vm/, i.e.
       Var(<parameter/vn/) = <parameter/vm/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="rindirect">rindirect(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is assigned the value of <parameter/vi/
       where <emphasis/i/ is the value of <parameter/vm/, i.e.
       <parameter/vn/ = Var(<parameter/vm/).
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>muln(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is multiplied by <parameter/m/, i.e.
       <parameter/vn/ = <parameter/vn/ * <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>mulv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is multiplied by the value of <parameter/vm/,
       i.e. <parameter/vn/ = <parameter/vn/ * <parameter/vm/.
      </para><para>
       <emphasis>(What happens on overflow? --VB)</emphasis>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>divn(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is divided by <parameter/m/, i.e.
       <parameter/vn/ = <parameter/vn/ / <parameter/m/.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function>divv(n,m)</function></term>
      <listitem><para>
       Variable <parameter/vn/ is divided by the value of <parameter/vm/,
       i.e. <parameter/vn/ = <parameter/vn/ / <parameter/vm/.
      </para><para>
       <emphasis>(What happens on division by 0? --VB)</emphasis>
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="random">random(n,m,k)</function></term>
      <listitem><para>
       Variable <parameter/vk/ is assigned a random value in the range
       between <parameter/n/ and <parameter/m/.
       Now let us consider the commands changing flag values. Remember that a
       flag can only have a value 0 or 1.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set">set(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/n/ is set to 1.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="set.v">set.v(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/i/, where <emphasis/i/ is the value of
       <parameter/vn/, is set to 1. i.e.  flag(<parameter/vn/) = 1.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="reset">reset(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/n/ is set to 0.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="reset.v">reset.v(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/i/, where <emphasis/i/ is the value of
       <parameter/vn/, is set to 0, i.e. flag(<parameter/vn/) = 0.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="toggle">toggle(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/n/ toggles its value.
      </para></listitem>
    </varlistentry>

    <varlistentry>
      <term><function id="toggle.v">toggle.v(n)</function></term>
      <listitem><para>
       <literal/f/<emphasis/i/, where <emphasis/i/ is the value of
       <parameter/vn/, i.e. flag(<parameter/vn/), toggles is value.
      </para></listitem>
    </varlistentry>
   </variablelist>
</para>

<sect2><title>Commands to load and unload resources</title>
<para>
   Commands in this chapter load (into the interpreter's memory) and
   unload (discard, thus freeing interpreter's memory) LOGIC, PICTURE,
   VIEW, and SOUND resources. Always remember that the internal memory of
   the interpreter is 64K. This restriction is rarely a problem, but do
   not forget about it.

   When the internal memory is full, the program has to be broken into
   parts which are loaded and unloaded as the story unfolds in the given
   room, or PICTURE, VIEW, and SOUND resources have to be manipulated
   using the commands below.

   Remember that when a resource is unloaded, all resources loaded after
   it <emphasis>are also automatically unloaded</emphasis>!

   <variablelist>
   <function id="load.logic">load.logic(n)</function>
   Load into memory the LOGIC resource number <emphasis/n/, i.e. Logic(n)

   <function>load.logic.v(n)</function>
   Load into memory the LOGIC resource number <emphasis/i/, where <emphasis/i/ is the value of
   <parameter/vn/, i.e. Logic(<parameter/vn/)

<function id="load.pic">load.pic(n)</function>
   Loads into memory the PICTURE resource number <emphasis/i/, where <emphasis/i/ is the value
   of <parameter/vn/, i.e. Picture(<parameter/vn/)

   <emphasis>(This may be a mistake in the original: I would expect this command to
   be <literal/load.pic.v/, while <literal/load.pic(n)/ would load resource number
   <emphasis/n/. --VB)</emphasis>

   <emphasis>(<literal/load.pic.v/ may be a more appropriate name for it, but the name
   above is what they gave it. There is no equivalent command that takes a
   number rather than a variable. --LE)</emphasis>

<function id="load.view">load.view(n)</function>
   Loads into memory the VIEW resource number <emphasis/n/, i.e. View(n).

<function id="load.view.v">load.view.v(n)</function>
   Loads into memory the VIEW resource number <emphasis/i/, where <emphasis/i/ is the value of
   <parameter/vn/, i.e. View(<parameter/vn/)

<function id="load.sound">load.sound(n)</function>
   Loads into memory the SOUND resource number <emphasis/n/, i.e. Sound(n).

   <emphasis>(Note that there is no <literal/load.sound.v/ listed. I wonder if this is a
   mistake or there really is no way to load a sound with indirection
   (unlikely, I think) --VB)</emphasis>

   <emphasis>(There really is no way of loading a sound with indirection. The
   command doesn't exist. --LE)</emphasis>

<function id="discard.pic">discard.pic(n)</function>
   Unloads PICTURE resource number <emphasis/i/, where <emphasis/i/ is the value of <parameter/vn/.

<function id="discard.view">discard.view(n)</function>
   Unload VIEW resource number <emphasis/n/, i.e. View(<emphasis/n/).

<function id="discard.view.v">discard.view.v(n)</function>
   Unloads VIEW resource number <emphasis/i/ where <emphasis/i/ is the value of
   <parameter/vn/, i.e.  View(<parameter/vn/).

   <emphasis>(And what about <literal/discard.logic/, <literal/discard.logic.v/,
   <literal/discard.sound/, and <literal/discard.sound.v/? --VB)</emphasis>

   <emphasis>(There must be some other way that those commands are removed from
   memory, because the commands you mention above don't exist. --LE)</emphasis>
   </variablelist>
</para>

<sect2><title>Program control commands</title>
<para>
   new.room command is one of the most powerful commands of the
   interpreter.

   It is used to change algorithms of the object behaviour, props, etc.
   Automatic change of Ego coordinates imitates moving into a room
   adjacent to the edge of the initial one. <parameter>(Sounds awkward but that's
   what it says. --VB)</parameter>

   The format of the command:

   <variablelist>
<function id="new.room" id="new.room.v">new.room(n), new.room.v(n)</function>

   These commands do the following:

   <orderedlist>
    <listitem><para>
     Commands <function><ulink name="stop.update"/stop.update/</function>
     and <function/unanimate/ are issued to all objects;
    </para></listitem>

    <listitem><para>
     All resources except Logic(0) are discarded;
    </para></listitem>

    <listitem><para>
     Command <function><ulink name="player.control"/player.control/</function>
     is issued;
    </para></listitem>

    <listitem><para>
     <function><ulink name="unblock"/unblock/</function> command is issued;
    </para></listitem>

    <listitem><para>
     <function/set.horizon(36)/ command is issued;
    </para></listitem>

    <listitem><para>
     <function/v1/ is assigned the value of <literal/v0/;
     <literal/v0/ is assigned <parameter/n/ (or the value of <parameter/vn/
     when the command is
     <literal><ulink name="new.room.v"/new.room.v/</literal>);
    </para></listitem>

    <listitem><para>
     <literal/v4/ is assigned 0;
    </para></listitem>

    <listitem><para>
     <literal/v5/ is assigned 0;
    </para></listitem>

    <listitem><para>
     <literal/v16/ is assigned the ID number of the VIEW resource that was
     associated with Ego (the player character).
    </para></listitem>

    <listitem><para>
     Logic(i) resource is loaded where <parameter/i/ is the value of
     <literal/v0/ !
    </para></listitem>

    <listitem><para>
     Set Ego coordinates according to <literal/v2/:
       <simplelist>
        <member>if Ego touched the bottom edge, put it on the horizon;
        <member>if Ego touched the top edge, put it on the bottom edge of the
          screen;
        <member>if Ego touched the right edge, put it at the left and vice
          versa.
       </simplelist>
    </para></listitem>

    <listitem><para>
     <literal/v2/ is assigned 0 (meaning Ego has not touched any edges).
    </para></listitem>

    <listitem><para>
     <literal/f5/ is set to 1 (meaning in the first interpreter cycle after
     the new_room command all initialization parts of all logics loaded
     and called from the initialization part of the new room's logic
     will be called. In the subsequent cycle <literal/f5/ is reset to 0
     (see <xref linkend="workcycle" name="Interpreter work cycle"> and
     the source of the ``Thunderstorm''. This is very important!).
    </para></listitem>

    <listitem><para>
     Clear keyboard input buffer and return to the main AGI loop.
    </para></listitem>
   </orderedlist>
   </variablelist>
</para>

<sect2><title>Subroutine call commands</title>
<para>
   <variablelist>
<function id="call">call(n), call.v(n)</function>
   LOGIC resource number <parameter/n/ (or number <parameter/i/ where i the value of <parameter/vn/) is
   executed as a subroutine. If the logic with the given ID is not loaded
   in memory, it is temporarily loaded and discarded after returning from
   the call (this takes extra time). <literal><ulink name="call"/call/</literal> does not change any
   variables or flags.

<function id="return">return</function>
   This command returns control to the interpreter if it is executed in
   Logic(0), or to the command following the call command which called
   the current logic.

   <function>jump &lt;label></function>

   This command unconditionally transfers control to a command starting
   after label <literal/label/ within the same logic.

<function id="set.scan.start">set.scan.start(), reset.scan.start()</function>
   Normally, when a logic is called using call command, execution begins
   at the first instruction. <literal><ulink name="set.scan.start"/set.scan.start/</literal> command sets the entry point
   at the command following it, while <literal><ulink name="reset.scan.start"/reset.scan.start/</literal> returns the entry
   point to the beginning.
   </variablelist>
</para>

<sect2><title>Object control commands</title>
<para>
   The interpreter controls the movement of objects in the screen
   automatically checking the following conditions:

   <orderedlist>
    <listitem><para>
      If an object priority is 0 it cannot cross an unconditional barrier
      (pixels with priority 0).
    </para></listitem>

    <listitem><para>
      If an object priority is 15 and a command <function/ignore.block/ has not
      been given to it, it cannot cross a conditional barrier (pixels with
      priority 1) and leave the block set using the
      <function><ulink name="block"/block/</function> command.
    </para></listitem>

    <listitem><para>
      If an object has not been given
      <function><ulink name="ignore.horizon"/ignore.horizon/</function>
      command, it cannot move above the horizon set using the 
      <function><ulink name="set.horizon"/set.horizon/</function> command.
    </para></listitem>

    <listitem><para>
      An object should follow the conditions set using
      <function><ulink name="object.on.water"/object.on.water/</function>
      and <function><ulink name="object.on.land"/object.on.land/</function>
      commands (see below).
    </para></listitem>
   </orderedlist>

   Object number 0 is called Ego. It is different from others in that the
   player may move it around using the keyboard.
</para>

<sect3><title>Object description commands</title>
<para>
   <variablelist>
<function id="animate.obj">animate.obj(n)</function>
   Object number <parameter/n/ is included in the list of object controlled by the
   interpreter. <parameter>Objects not included in that list are considered
   inexistent!</parameter>

<function id="unanimate.all">unanimate.all()</function>
   All objects are removed from the control list and are considered
   inexistent.

<function id="set.view">set.view(n,m), set.view.v(n,m)</function>
   Object <parameter/n/ is associated with a VIEW resource number <parameter/m/ (or pointed to by
   <parameter/vm/), which may be an image of the object.

<function id="set.loop">set.loop(n,m), set.loop.v(n,m)</function>
   Chooses a loop m (or <parameter/vm/) in the VIEW resource associated with the
   object <parameter/n/.

<function id="fix.loop">fix.loop(n)</function>
   Turns off automatic choice of loop number for the object number <parameter/n/.

<function id="release.loop">release.loop(n)</function>
   Turns on automatic choice of loop number depending on the direction of
   motion of the object <parameter/n/.
   <verb>
                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - object stands still
                    / | \
                  /   |   \
                6     |     4
                      5
   </verb>
   Automatic choice of the loop is done according to the table:

   <simplelist>
    <member>for objects with fewer than 4 but more than 1 loops:
<programlisting>
Direction  0  1  2  3  4  5  6  7  8
  Loop     x  x  0  0  0  x  1  1  1
</programlisting>

    <member>for objects with more than 4 loops:
<programlisting>
Direction  0  1  2  3  4  5  6  7  8
  Loop     x  3  0  0  0  2  1  1  1
</programlisting>
   </simplelist>
   <literal/x/ means that the current loop number is retained.

<function id="set.cel">set.cel(n,m), set.cel.v(n,m)</function>
   Selects a cel <parameter/m/ in the current loop of the object <parameter/n/.

<function id="last.cel">last.cel(n,m)</function>
   The number of the last cel of the current loop of the object <parameter/n/ is
   stored in <parameter/vm/.

<function id="current.cel">current.cel(n,m)</function>
   The number of the current cel of the object <parameter/n/ is stored in <parameter/vm/.

<function id="current.loop">current.loop(n,m)</function>
   The number of the current loop of the object <parameter/n/ is stored in
   <parameter/vm/.

<function id="current.view">current.view(n,m)</function>
   The number of the current VIEW resource associated with the object <parameter/n/
   is stored in <parameter/vm/.

<function id="set.priority">set.priority(n,m), set.priority.v(n,m)</function>
   Set priority of the view of the object <parameter/n/ to <parameter/m/ (or <parameter/vm/).

<function id="release.priority">release.priority(n)</function>
   Turns on the automatic priority choice for the object <parameter/n/.
   The priority is set depending on the vertical coordinate of the object.
   This way, as an object moves down it approaches the viewer.
   See section <xref linkend="bands" name="Priority bands and control lines">
   for a table of y coordinates and the associated priorities.

<function id="get.priority">get.priority(n,m)</function>
   The value of the current priority of the object <parameter/n/ is
   stored in <parameter/vm/.

<function id="position">position(n,x,y), position.v(n,x,y)</function>

   Coordinates of the object <parameter/n/, not yet displayed on the
   screen, are set to <parameter/x/ and <parameter/y/ (or <parameter/vx/
   and <parameter/vy/).

<function id="draw">draw(n)</function>
   Object <parameter/n/ is shown on the screen. The image uses the
   values of the loop and the cel in the VIEW resource associated with
   the object <parameter/n/ (see
   <function><ulink name="set.view"/set.view"/</function>), as well as
   the priority and coordinates of the object. If a command
   <function><ulink name="start.cycling"/start.cycling/</function> is also
   issued, a looped animation for object <parameter/n/ is shown until
   stopped (for example, with
   <function><ulink name="stop.cycling"/stop.cycling/</function>).

<function id="erase">erase(n)</function>
   Object <parameter/n/ is erased from the screen.

<function id="get.posn">get.posn(n,x,y)</function>
   Coordinates of the object <parameter/n/ are stored in <parameter/vx/
   and <parameter/vy/. Coordinates of the object are coordinates of the
   base point (bottom left corner) of cels of the VIEW resource
   associated with the object.

   The interpreter automatically plays the animation (a loop in the VIEW
   resource) associated with the object, starting at the specified cel.
   The following commands control this process.

<function id="start.cycling">start.cycling(n)</function>
   Enables automatic change of cels in a chosen (using
   <function><ulink name="set.loop"/set.loop/</function>) loop of
   a VIEW resource associated with the object <parameter/n/ (using
   <function><ulink name="set.view"/set.view/</function>).

<function id="stop.cycling">stop.cycling(n)</function>
   Disables automatic change of cels in a chosen (using
   <function><ulink name="set.loop"/set.loop"/</function>) loop of
   a VIEW resource associated with the object <parameter/n/ (using
   <function><ulink name="set.view"/set.view/</function>).

<function id="normal.cycle">normal.cycle(n)</function>
   Cels of the loop associated with the object <parameter/n/ follow in
   a normal order: 0, 1, 2, ..., <parameter/k/-1, 0, 1, 2, ...

<function id="reverse.cycle">reverse.cycle(n)</function>
   Cels of the loop associated with the object <parameter/n/ follow a reverse
   order: <parameter/k/-1, <parameter/k/-2, ..., 1, 0, <parameter/k/-1,
   <parameter/k/-2, ..., 1, 0, ...

<function id="end.of.loop">end.of.loop(n,m)</function>
   Plays the loop associated with the object <parameter/n/ once, from the current cel
   to the last. When finished, <literal/f/<parameter/m/ is set to 1.

<function id="reverse.loop">reverse.loop(n,m)</function>
   Plays the loop associated with the object <parameter/n/ once in a reverse order,
   from the current cel to the first. When finished, <literal/f/<parameter/m/ is set to 1.

<function id="cycle.time">cycle.time(n,m)</function>
   <parameter/vm/ sets the time in interpreter cycles between cel changes for the
   object n. When <parameter/vm/ = 1 cels are changed every cycle.
   </variablelist>
</para>

<sect3><title>Object motion control commands</title>
<para>
   The following commands can be given to the object included in the
   interpreter control list with <literal><ulink name="animate.obj"/animate.obj/</literal>:

   <variablelist>
<function id="set.horizon">set.horizon(n)</function>
   Set the horizon to y = <parameter/n/.

<function id="ignore.horizon">ignore.horizon(n)</function>
   Object <parameter/n/ moves regardless of the horizon position.

<function id="observe.horizon">observe.horizon(n)</function>
   Object <parameter/n/ cannot move above the horizon.

<function id="block">block(x1,y1,x2,y2)</function>

   Sets a rectangular area (block).
<programlisting>
(x1, y1)
   +----------------+
   |                |
   |                |
   |                |
   +----------------+
                 (x2, y2)
</programlisting>

<function id="unblock">unblock()</function>
   Cancels previously set block.

<function id="ignore.blocks">ignore.blocks(n)</function>
   Object <parameter/n/ moves ignoring conditional barriers (pixels with priority 1)
   and a block set with the <function><ulink name="block"/block/</function> command.

<function id="observe.blocks">observe.blocks(n)</function>
   Object <parameter/n/ may not cross conditional barriers or leave the block.

<function id="ignore.objs">ignore.objs(n)</function>
   Object <parameter/n/ moves regardless of positions of other objects.

<function id="observe.objs">observe.objs(n)</function>
   Object <parameter/n/ treats other objects as obstacles.

<function id="player.control">player.control()</function>
   The player is allowed to control Ego (object number 0) using the
   keyboard or the joystick.

<function id="program.control">program.control()</function>
   The player is not allowed to control object 0 (Ego).

<function id="stop.motion">stop.motion(n)</function>
   Motion of object <parameter/n/ is stopped. If <parameter/n/ == 0, <literal><ulink name="program.control"/program.control/</literal> is
   automatically executed.

<function id="start.motion">start.motion(n)</function>
   Motion of object <parameter/n/ is started. If <parameter/n/ == 0 (Ego), <literal><ulink name="player.control/player.control/</literal>
   automatically executed.

<function id="step.size">step.size(n,m)</function>
   <parameter/vn/ determines the number of pixels the object <parameter/n/ moves
   each step. <parameter>(The actual value in pixels is the step size / 4! --CM)</parameter>

<function id="step.time">step.time(n,m)</function>
   <parameter/vn/ determines the speed of object <parameter/n/ motion: delay in the
   interpreter cycles between consecutive steps. If <parameter/vm/ = 1, step
   occurs on every cycle.

<function id="move.obj">move.obj(n,x,y,s,m), move.obj.v(n,x,y,s,m)</function>
   Object <parameter/n/ is told to move to the point <parameter/(x,y)/ (or <parameter/vx/, <parameter/vy/) by s
   pixels every step. When the destination is reached, <literal/f/<parameter/m/ is set to
   1. If <parameter/n/ == 0 (Ego), <literal><ulink name="#program.control"/program.control/</literal> is executed automatically.

<function id="follow.ego">follow.ego(n,s,m)</function>
   Object <parameter/n/ is told to chase object 0 (Ego) by <parameter/s/ pixels every step.
   When Ego and object coordinates become equal, <literal/f/<parameter/m/ is set to 1.

<function id="wander">wander(n)</function>
   Object <parameter/n/ randomly changes the direction of its motion (wanders). If
   <parameter/n/ == 0 (Ego), <literal><ulink name="#program.control"/program.control/</literal> is issued automatically.

<function id="normal.motion">normal.motion(n)</function>
   Special object motion mode is canceled. The object continues to move
   in the direction it was moving in at the time the command was issued.

<function id="set.dir">set.dir(n,m)</function>
   Object <parameter/n/ is told to move in the direction <parameter/vm/.
   <verb>
                      1
                8     |     2
                  \   |   /
                    \ | /
              7 ------------- 3      0 - stop
                    / | \
                  /   |   \
                6     |     4
                      5
   </verb>
<function id="get.dir">get.dir(n,m)</function>
   Direction of object <parameter/n/ motion is stored in <parameter/vm/.

<function id="object.on.water">object.on.water(n)</function>
   Object <parameter/n/ is allowed to be only in the area where its base line is
   completely on pixels with priority 3 (water surface).

<function id="object.on.land">object.on.land(n)</function>
   Object <parameter/n/ is not allowed to touch pixels of water surface (priority 3).

<function id="object.on.anything">object.on.anything(n)</function>
   Motion restrictions previously set on the object <parameter/n/ with commands
   <literal><ulink name="#object.on.water"/object.on.water/</literal> or <literal/object.on.land/ are cancelled.

<function id="reposition">reposition(n,dx,dy)</function>
   Object <parameter/n/ jumps from its current location into the location with
   coordinates (<parameter/x/ + <parameter/vdx/, <parameter/y/ + <parameter/vdy/).

   <parameter>(Shouldn't there be reposition and reposition.v? --VB)</parameter>

   <parameter>(There should be, but they don't exist. --LE)</parameter>

<function id="reposition.to">reposition.to(n,x,y), reposition.to.v(n,x,y)</function>
   Similar to the preceding command, but the object is moved to the point
   <parameter/x/, <parameter/y/ (<parameter/vx/,<parameter/vy/).

<function id="stop.update">stop.update(n)</function>
   Object <parameter/n/ is removed from the list of objects updated by the
   interpreter on each step. The object stays on the screen unchanged.

<function id="start.update">start.update(n)</function>
   Object <parameter/n/ is redrawn on each interpreter step.

<function id="force.update">force.update(n)</function>
   Object <parameter/n/ is redrawn immediately, without waiting for the end of the
   interpreter cycle.

<function id="distance">distance(n,m,d)</function>
   If both objects <parameter/n/ and <parameter/m/ are on the screen, then

   <parameter/vd/ = abs(x(n) - x(m)) + abs(y(n) - y(m)),

   otherwise <parameter/vd/ = 255.
   </variablelist>
</para>

<sect3><title>Inventory member management commands</title>
<para>
   OBJECT resources, stored in a separate file <literal/object/, are most often
   used to represent inventory members. An member is a structure which
   consists of a one-byte field called room and a string of text, the
   member name.

   If the room field of an member is 255, the member belongs to the player.
   Otherwise the member is considered to be in the room with the
   corresponding ID number.

   <variablelist>
<function id="get">get(n), get.v(n)</function>
   Stores 255 in room field of an object <parameter/n/, which means that
   the player owns it.

<function id="drop">drop(n)</function>
   Stores 0 in the room field of object <parameter/n/.

<function id="put">put(n,m), put.v(n,m)</function>
   Stores the value <parameter/m/ (or <parameter/vm/) in the room field
   of the object <parameter/n/.

<function id="get.room.v">get.room.v(n,m)</function>
   Stores the value of the room field of object <parameter/vn/ in <parameter/vm/.

<function id="status">status()</function>
   The screen is switched to text mode; the top line displays ``You are
   carrying:'', then the names of the object with room field equal to 255
   are listed. If there are no such objects, the word ``nothing'' is
   displayed.

   If <literal/f13/ is set (allow member selection), a highlight appears which
   allows the player to select an member name. When <literal/ENTER/ is pressed, the
   selected object number is stored in <literal/v25/. When <literal/ESC/ is pressed, 255
   is stored in <literal/v25/.
   </variablelist>
</para>

<sect2><title>Picture resource management commands</title>
<para>
   The following commands operate on PICTURE resources,
   prepared using PM editor and loaded in the interpreter memory using
   <literal><ulink name="#load.pic"/load.pic/</literal>:

   <variablelist>
<function id="draw.pic">draw.pic(n)</function>
   A PICTURE resource number <parameter/i/, where <parameter/i/ is the value of <parameter/vn/ is
   executed. As the result, the background picture is created in the
   internal buffer of the interpreter. Before execution, the buffer is
   cleared, i.e. all pixels are set to colour 15 and priority 4.

<function id="overlay.pic">overlay.pic(n)</function>
   Just like the above, only the internal buffer is not cleared before
   drawing. Picture(<parameter/vn/) is drawn over the existing picture.

<function id="add.to.pic">add.to.pic(a,b,c,d,e,f,g), add.to.pic.v(a,b,c,d,e,f,g)</function>

   A picture of a VIEW resource is added to the background as its
   component. Typically, this is used to add small complicated details
   which would require too many PICTURE resource commands to draw.

   Parameters are:
   <simplelist>
    <member><parameter/a/ (<parameter/va/): number of the VIEW resource;
    <member><parameter/b/ (<parameter/vb/): loop number;
    <member><parameter/c/ (<parameter/vc/): cel number;
    <member><parameter/d/ (<parameter/vd/): x coordinate;
    <member><parameter/e/ (<parameter/ve/): y coordinate;
    <member><parameter/f/ (<parameter/vf/): priority;
    <member><parameter/g/ (<parameter/vg/): margin.
   </simplelist>

   If margin is 0, 1, 2, or 3, the base of the cel is surrounded with a
   rectangle of the corresponding priority. If margin > 4, this extra
   margin is not shown.

<function id="show.pic">show.pic()</function>
   Shows internal buffer on the screen.

   <emphasis>ATTENTION!</emphasis>
   Please use the following sequence of commands when loading PICTURE
   resources in the interpreter memory:

<programlisting>
load.pic(n);
draw.pic(n);
discard.pic(n);
...
show.pic();
</programlisting>

   Any other order may crash the interpreter without any diagnostic
   messages.
   </variablelist>
</para>

<sect2><title>Sound resource management commands</title>
<para>
   <variablelist>
<function id="sound">sound(n,m)</function>
   Starts playback of the SOUND resource number n. When finished, <literal/f/<parameter/m/
   is set to 1.

<function id="stop.sound">stop.sound()</function>
   Stops the playback.
   </variablelist>
</para>

<sect2><title>Text management commands</title>
<para>
   <variablelist>
<function id="prevent.input">prevent.input()</function>
   Prevents the user from entering anything using the keyboard.

<function id="accept.input">accept.input()</function>
   Allows the user to enter text using the keyboard.

<function id="print">print(n), print.v(n)</function>
   Opens a text window in the centre of the screen, where a message
   number <parameter/n/ (or <parameter/vn/) from the messages field of the current LOGIC
   resource is displayed. Output mode is determined by <literal/f15/ (see flag
   description).
   The message is a NULL-terminated string of text. In addition to
   letters, digits, and other symbols, the string may contain:

   <simplelist>
    <member>Newline character (0x0A);
    <member>Format element:
     <simplelist>
      <member><literal/%v&lt;decimal number>/: at this place the output will include a
       decimal value of variable with the given number.
      <member><literal/%m &lt;number>/: the text of the message with the given number is
       inserted at this place.
      <member><literal/%0 &lt;number>/: the name of the member with the given number is
       inserted at this place.
      <member><literal/%w &lt;number>/: a vocabulary word with the given number is
       inserted at this place.
      <member><literal/%s &lt;number>/: a string variable with the given number is
       inserted at this place.
      <member><literal/%g &lt;number>/: a message with this number from message field of
       Logic(0) is inserted at this place.
     </simplelist>
   </simplelist>

   For <literal/%v/, you can add a vertical line and a number of characters
   the output should take. In this case leading zeros are not suppressed
   in the output.

   Example: <literal/%v34|2/

   When you write your messages, remember that the interpreter wraps
   the text between the lines as needed when the message is displayed.

<function id="display">display(r,c,n), display.v(r,c,n)</function>
   Prints a message number <parameter/n/ (<parameter/vn/) in the row <parameter/r/
   (<parameter/vr/), starting with the column <parameter/c/ (<parameter/vc/).
   No window is created, so it is up to the programmer to erase the
   output when it is no longer needed.

<function id="print.at" id="print.at.v">print.at(n,x,y,l), print.at.v(n,x,y,l)</function>

   Analogous to <literal><ulink name="#print"/print/</literal> but the programmer can specify the window location.
   <parameter/x/, <parameter/y/, and <parameter/l/ are constants specifying coordinates of the
   top left corner of the window and its width in character cells of a 40x25
   screen.

<function id="version">version()</function>
   Prints interpreter version in the centre of the screen.

<function id="text.screen">text.screen()</function>
   The screen switches to the text mode 40x25.

<function id="graphics">graphics()</function>
   The screen returns to the graphics mode. The picture on the screen is
   restored.

<function id="set.cursor.char">set.cursor.char(n)</function>
   First byte of the message <parameter/n/ is used as a text mode cursor.

<function id="set.text.attribute">set.text.attribute(fg,bg)</function>

   Sets foreground and background colours for <literal><ulink name="#display"/display/</literal>, <literal/get.num/ and
   <literal><ulink name="#get.string"/get.string/</literal> commands.

<function id="clear.lines">clear.lines(n,m,c)</function>

   Clears text lines from <parameter/n/ to <parameter/m/ using colour <parameter/c/.

<function id="clear.text.rect">clear.text.rect(x1,y1,x2,y2,c)</function>

   Clears a rectangular area with top left corner coordinates <parameter/(x1,y1)/ and
   bottom right coordinates <parameter/(x2,y2)/ using colour <parameter/c/.

<function id="status.line.on">status.line.on()</function>
   Shows the status line containing the current score and sound status
   (on/off).

<function id="status.line.off">status.line.off()</function>
   Removes the status line.
   </variablelist>
</para>

<sect2><title>String management commands</title>
<para>
   <variablelist>
<function id="set.string">set.string(n,m)</function>
   Stores message number <parameter/m/ in the string variable <parameter/n/.

<function id="word.to.string">word.to.string(n,m)</function>
   Word number <parameter/m/ of the user input is stored in <literal/s/<parameter/n/.

<function id="get.string">get.string(n,m,x,y,l)</function>

   User input is stored in <literal/s/<parameter/n/. <parameter/m/ is the number of the
   message used as the prompt. <parameter/x/, <parameter/y/ and <parameter/l/ are input
   position and maximum string length.

<function id="parse">parse(n)</function>
   Parses <literal/s/<parameter/n/ as if it was entered by the player.

<function id="get.num">get.num(n,m)</function>
   Enters a number from the keyboard into <parameter/vm/. Message <parameter/n/ is
   used as the prompt.
   </variablelist>
</para>

<sect2><title>Initialization commands</title>
<para>
   <variablelist>
<function id="set.key">set.key(s,c)</function>

   Set interpreter's special key.  <parameter/c/ is the key code (decimal number
   from 0 to 255) and <parameter/s/ (if the key is a regular, or <literal/CTRL/+key pair).
   the ASCII code (for example, <literal/TAB/ is 0x0009).
   If the key is a function key or <literal/ALT/+key pair,
   the corresponding IBM-PC keyboard scan code is in the high byte of
   <parameter/s/. For example, the scan code of <literal/F1/ is 0x3B00, <literal/ALT/+<literal/Z/
   is 0x2C00.

   <parameter>Does ``key code'' mean the key scan code, or the ASCII code of the
   character? Is the IBM-PC scan code valid in other platforms as well?
   -- CM</parameter>

<function id="set.game.id">set.game.id(n)</function>
   Message n is scanned by the interpreter and compared with its internal
   identifier. On mismatch, the program exits. For the AGDS interpreter the
   identifier is ``TQ''. See also section <xref linkend="gameid" name="Game IDs">.

<function id="script.size">script.size(n)</function>

   Sets the size of script table in bytes. Script table stores codes of
   some interpreter commands. It is needed by the interpreter to
   correctly reload resources when <literal/restore_game/ is executed.

<function id="trace.info">trace.info(n,m,l)</function>
   Sets the built-in debugger parameters.
   <parameter/n/ is the number of LOGIC resource with command names, and
   <parameter/m/ and <parameter/l/ are the first line and height of the debugger window.

<function id="trace.on">trace.on()</function>
   Turns on the debugger. In general, the debugger is turned on with
   <literal/SCROLL LOCK/ key when the command name table is loaded even if this
   command does not occur in the program.

<function id="log">log(n)</function>
   This is a debugging command. It writes a log message in the format
<programlisting>
Room <current room> Input line <current input line> ... message ...
</programlisting>
   where the message is given by number <parameter/n/. Output is sent to a file.

   <parameter>(Are these debugging commands valid only for AGDS, or they work
   in AGI as well? --CM)</parameter>
   </variablelist>
</para>

<sect2><title>Menu management commands</title>
<para>
   Creating your program, you can offer the player a choice using a
   system of menus. These may be short one-line questions (menu header)
   with several answers (menu elements), or a prompt to change some of
   the system parameters, for example, object movement speed. Let us
   consider these commands.

   <variablelist>
<function id="set.menu">set.menu(n)</function>
   Message <parameter/n/ is used as the header of the menu elements which follow.

<function id="set.menu.member">set.menu.member(n,c)</function>

   Message <literal/n/ is used as a menu element, where <parameter/c/ is this
   element's code (a number between 0 and 255).

<function id="submit.menu">submit.menu()</function>
   Ends menu creation.

<function id="enable.member">enable.member(c), disable.member(c)</function>
   Enables or disables a menu member with the code <parameter/c/.
   <verb>
                              +-------- heading
                              v
                          +-----------------------------+
                          | File                        |
                          +------------+----------------+
               Menu   --->| Save       |
               Element    |------------|
                          | Restore    |
                          |------------|
                          |XXXXXXXXXXXX|&lt;---- menu element disabled
                          |------------|      using disable.member
                          | Quit       |
                          +------------+
   </verb>

<function id="menu.input">menu.input()</function>
   If <literal/f14/ is set, a menu system is shown on the screen, allowing the
   user to choose an member. Whether an member with the code c has been
   chosen can be tested using a command <literal/controller(c)/, where <parameter/c/ is
   the code assigned to the menu member.
   </variablelist>
</para>

<sect2><title>Logical commands</title>

<sect3><title>Test commands</title>
<para>
   The result of test command can be either TRUE or FALSE.

   <variablelist>
<function id="equaln">equaln(n,m)</function>
   TRUE if <parameter/vn/ = <parameter/m/.

<function id="equalv">equalv(n,m)</function>
   true if <parameter/vn/ = <parameter/vm/.

<function id="lessn">lessn(n,m)</function>
   TRUE if <parameter/vn/ &lt; <parameter/m/.

<function id="lessv">lessv(n,m)</function>
   TRUE if <parameter/vn/ &lt; <parameter/vm/.

<function id="greatern">greatern(n,m)</function>
   TRUE if <parameter/vn/ > <parameter/m/.

<function id="greaterv">greaterv(n,m)</function>
   TRUE if <parameter/vn/ > <parameter/vm/.

<function id="isset">isset(n)</function>
   TRUE if <literal/f/<parameter/n/ is set.

   <function>isset.v(n)</function>
   TRUE if Flag(<parameter/vn/) is set.

<function id="has">has(n)</function>
   TRUE if the room field of member <parameter/n/ is 255, i.e. the member belongs to the
   player.

<function id="obj.in.room">obj.in.room(n,m)</function>
   TRUE if room field of the object <parameter/n/ is <parameter/vm/.

<function id="posn">posn(n,x1,y1,x2,y2)</function>
   TRUE if the coordinates of the base point of the cel which is the
   current image of object <parameter/n/ satisfies the equations
   <parameter/x1/ &lt;= <parameter/x/ &lt;= <parameter/x2/ and <parameter/y1/ &lt;= <parameter/y/ &lt;= <parameter/y2/.

<function id="obj.in.box">obj.in.box(n,x1,y1,x2,y2)</function>

   TRUE if the base of the object <parameter/n/ is completely within the rectangle
   specified using its top left <parameter/(x1,y1)/ and bottom right <parameter/(x2,y2)/
   corners.
<programlisting>
(x1, y1)
   +----------------+
   |                |
   |                |
   |                |
   +----------------+
                  (x2, y2)
</programlisting>

   <function>center.position(n,x1,y1,x2,y2)</function>
   TRUE of the center of the base line of the object <parameter/n/ is inside the
   rectangle specified as its top left and bottom right corners.

   <function>right.position(n,x1,y1,x2,y2)</function>
   TRUE of the right side of the base line of the object <parameter/n/ is inside the
   rectangle specified as its top left and bottom right corners.

<function id="have.key">have.key()</function>
   TRUE if the user has pressed any key on the keyboard. Used to create
   cycles to wait until any key is pressed.

<function id="compare.strings">compare.strings(s1,s2)</function>
   TRUE if <literal/s1/ == <literal/s2/.

<function id="said">said(n,W(i))</function>
   where <parameter/i/ = 1, ..., <parameter/n/.

   See section <xref linkend="parsing" name="Player input parsing">.

<function id="controller">controller(n)</function>
   TRUE if the event with code <parameter/n/ has occurred:
   <simplelist>
    <member>a key with the code <parameter/n/ was pressed (set using <literal/set_key/);
    <member>menu member with code <parameter/n/ was selected in command <literal/menu_input/.
   </simplelist>
   </variablelist>
</para>

<sect2><title>Other commands</title>
<para>
   <variablelist>
<function id="configure.screen">configure.screen(a,b,c)</function>
   Sets position of lines on the screen, where <parameter/a/ = 1 (the minimum line
   number for print), <parameter/b/ is the user input line and <parameter/c/ is the status
   line.

   <parameter>(Sounds confuse --CM)</parameter>

<function id="obj.status.v">obj.status.v(n)</function>
   Prints a message for the object <parameter/vn/ in the format

<programlisting>
Obj <n> x: <pos> y: <pos> pri: <priority> stepsize: <step size>.
</programlisting>

<function id="show.mem">show.mem()</function>
   Displays a report of the interpreter memory status.

<function id="show.pri.screen">show.pri.screen()</function>
   Shows priorities of the screen pixels. Priority n is shown as color
   number <parameter/n/ (see color setting commands in I.1.2.1.1).

<function id="show.obj">show.obj(n)</function>
   Show cel 0 of loop 0 of the VIEW resource <parameter/n/ in the bottom center of
   the screen. In the center of the screen, a message associated with the
   VIEW resource is printed.

   <parameter>(That's what they say but I suspect they mean OBJECT n, not VIEW
   resource. --VB)</parameter>

   <parameter>(Actually, in this case the argument does refer to the VIEW resource.
   This is because the VIEW in question isn't meant to be a controlled
   object but instead is simply the picture and textual description of
   the an inventory member. --LE)</parameter>

<function id="shake.screen">shake.screen(n)</function>
   The screen shakes <parameter/n/ times.

<function id="echo.line">echo.line()</function>
   The last line entered by the user is displayed in the input line.

<function id="cancel.line">cancel.line()</function>
   Input line is cleared.

<function id="close.window">close.window()</function>
   If there is a text window on the screen, it is removed.

<function id="open.dialogue">open.dialogue, close.dialogue()</function>
   Enables and disables <literal><ulink name="#get.string"/get.string/</literal> and <literal/get.num/ commands if
   <literal><ulink name="#prevent.input"/prevent.input/</literal> has been issued.

<function id="restart.game">restart.game()</function>
   Restarts the game from the very beginning.

<function id="save.game">save.game, restore.game()</function>
   These command save and restore the current state of the game into disk
   files.

<function id="pause">pause()</function>
   Stops the interpreter until any key is pressed.

<function id="quit">quit(n)</function>
   Exits the interpreter. If <parameter/n/ = 1, quits immediately.
   If <parameter/n/ = 0, asks ``Press ENTER to quit. Press ESC to continue.''

<function id="init.joy">init.joy()</function>
   Initialize joystick.

<function id="toggle.monitor">toggle.monitor()</function>
   Switch RGB monitor into the graphics mode.

   <function>upper.left()</function>
   Usually the crossing by an object of various areas and lines is
   tracked by the base point (bottom right corner) of its cel. After this
   command, top left corner is used as such a point.
   </variablelist>
</para>

<sect2><title>Other commands</title>
<para>
<parameter>Described by <ulink name="mailto:dark_minister@hotmail.com"/Dark Minister/ (Last update: 13 October 1998).</parameter>

   <variablelist>
<function id="unknown170">unknown170(n)</function>
   This command modifies the behavior of the commands
   <ulink name="#restore.game"/restore.game()/ and
   <ulink name="#save.game"/save.game()/.

   After calling <function/unknown170(n)/,
   where <parameter/n/ is a string number (ie: if <parameter/n/ == 2 then <literal/s2/)
   <ulink name="restore.game"/restore.game()/ will automatically
   (without any prompt) restore a savegame with the name stored in
   string number <parameter/n/ and <ulink name="save.game/name="save.game()"/
   will automatically save a savegame with the name of string number <parameter/n/.

   Note: make sure that at least one savegame is present when you call
   <ulink name="#restore.game"/restore.game()/ or
   <ulink name="#save.game"/save.game()/ (that is, when saving a
   game too).

   Example:
<programlisting>
set.string(s1,"test");
unknown170(1);
</programlisting>
   will automatically load the savegame named ``test''.

<function id="unknown173">unknown173(n)</function>
   This command changes the way that ego is controlled.
   After calling <literal/unknown173()/, Ego will only move when a direction key
   is maintained pressed. If the key is released, ego will stop walking.
   See also command <ulink name="#unknown181"/unknown181()/.

<function id="unknown177">unknown177(n)</function>
   This command control the access to the menu. <literal/unknown177(0)/ will
   disable access to the menu, even if flag 14 (<literal/menu_enabled/) is set.
   Calling <literal/unknown177()/ with a value greater than 0 seem to do nothing
   else than enabling access to the menu.

<function id="unknown181">unknown181(n)</function>
   This command restablishes the default control of Ego.
   It is normally used after a call to
   <ulink name="#unknown173"/unknown173()/.
   </variablelist>

   Note: Be aware that commands 175, 176, 178, 179 and 180 of the last
   version of AGI (ver 3.002.149) do absolutely nothing.
</para>

</sect1>


<sect1 id="kq4code"><title>Discussion of sample LOGIC code from KQ4</title>
<para>
<emphasis>
(Last updated: 31 August 1997).
</emphasis>

   Some of you may know that ``The Official Book of King's Quest'' included
   three small fragments of AGI code for room 7 in the AGI version of
   KQ4. These fragments are given below along with the same fragments
   taken from the game itself. There are a few differences which is to be
   expected but generally the code is very similar. These examples show
   how the coder wrote the code and what it now looks like in the final
   product. I've included a few comments where some interesting
   observations can be seen.
</para>

<sect2><title>Animating the smoke</title>
<para>
From the book:
<programlisting>
animate.obj( smoke);
ignore.horizon( smoke);
set.view( smoke, v.fish.cabin);
set.loop( smoke, 1);
ignore.blocks( smoke);
position( smoke, 95, 16);
work = 3;
step.time( smoke, work);
cycle.time( smoke, work);
draw( smoke);
</programlisting>

From the game:
<programlisting>
animate.obj(7);
ignore.horizon(7);
set.view(7, 114);
set.loop(7, 1);
ignore.objs(7);                [ These two lines have been added.
set.priority(7, 5);            [
ignore.blocks(7);
position(7, 95, 16);
assignn(152, 3);               [ Equivalent to 'work = 3;'
step.time(7, 152);
cycle.time(7, 152);
draw(7);
</programlisting>
</para>

<sect2><title>Opening the door</title>
<para>
From the book:
<programlisting>
if (said( open, door)) {     [ must be close enough
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      if ( door.open) {
        print("The door is already open. . .
      }
      else {
        set( game.control);
        set.priority( ego, 11);
        start.update( door);
        end.of.loop( door, door.done);
      }
    }
    else {
      print("You can't -- it's locked...
    }
  }
  else {
    set( notCloseEnough);
  }
}
</programlisting>

From the game:
<programlisting>
if (said(OPEN, DOOR||DOORS||DOORWAY||DOORWAYS)) {
  if (posn(0, 86, 120, 106, 133)) {
    if (!isset(38)) {
      if (isset(231)) {
        print("The door is already open.");
      }
      else {
        set(36);
        prevent.input();
        start.update(5);
        assignn(152, 3);
        cycle.time(5, 152);
        end.of.loop(5, 232);
        sound(70, 154);
      }
    }
    else {
      print("You can't.  It's locked and you
             don't have the key.");
    }
  }
  else {
    set(113);
  }
}
</programlisting>
</para>

<sect2><title>Unlocking the door</title>
<para>
From the book:
<programlisting>
if (said( unlock, door)) {     [must be close enough
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      print("The door is already unlocked. . .
    }
    else {
      printf("You can't, it's locked. . .
    }
  }
  else {
    set( notCloseEnough);
  }
}
</programlisting>

From the game:
<programlisting>
if (said(UNLATCH||UNLOCK, DOOR||DOORS||DOORWAY||DOORWAYS)) {
  if (posn(0, 86, 120, 106, 133)) {
    if (!isset(38)) {
      print("The door is already unlocked.");
    }
    else {
      print("You can't.  It's locked and you
             don't have the key.");
    }
  }
  else {
    set(113);
  }
}
</programlisting>
</para>

<sect2><title>Knocking on the door</title>
<para>
From the book:
<programlisting>
if ((said( knock, at, door) || said( knock) ||
     said( knock, on, door) || said( knock, door)) {
  if (posn( ego, 86, 120, 106, 133)) {
    if (!night) {
      print("You knock on the door. . .
             a woman says. . .
    }
    else {
      printf("You knock on the. . .
              a man calls out. . .
    }
  }
  else {
    set( notCloseEnough);
  }
}
</programlisting>

From the game:
<programlisting>
if (said(BANG||KNOCK||RAP||TAP) ||
    said(BANG||KNOCK||RAP||TAP, DOOR||DOORS||DOORWAY||DOORWAYS)) {
  if (posn(0, 86, 120, 106, 133)) {
    if (!isset(38)) {
      print("You assertively knock on the shanty
             door.  A woman's voice answers, "Jest come on in!"");
    }
    else {
      print("You assertively knock on the shanty
             door.  From inside, a man's voice calls out, "D'ya know
             what TIME it is?!  GO AWAY!!"");
    }
  }
  else {
    set(113);
  }
}
</programlisting>
</para>

<sect2><title>Fall rocks</title>
<para>
From the book:
<programlisting>
if (hit.special) {
  if ((rf2 || rf3 || rf4)) {
    reset(hit.special);
    get.posn(ego, priorx, priory);
    position.f(dude, priorx, priory);
    ignore.blocks(dude);
    set( game.control);
    set.view( dude, v.ego.land);
    if ((ego.dir == 3 || ego.dir == 4)) {
      set.loop( dude, 2);
    }
    else {
      set.loop( dude, 3);
    }
    fix.loop(dude);
    work = 3;
    step.size( dude, work);
    work = 3;
    cycle.time( dude, work);
    start.cycling(dude);
    erase(ego);
    draw(dude);
    if (rf3) {
      work6 = 0;
      move.obj.f( dude, tempx, tempy, work6, fall.done);
    }
    if (rf4) {
      work6 = 0;
      move.obj.f( dude, tempx, tempy, work6, fall.done);
    }
    if (rf2) {
      if (priory < 125) {
        set.priority( dude, 9);
        tempy=132;
        work6=0;
        move.obj.f( dude, ego,x, tempy, work6, fall.done);
      }
      else {
        set.priority(dude, 15);
        tempy = 156;
        work6 = 0;
        move.obj.f( dude, ego.x, tempy, work6, fall.done);
      }
    }
  }
}
</programlisting>

From the game:
<programlisting>
if (isset(3)) {     [ hit.special
  if (isset(222) || isset(223) || isset(224)) {     [ rf2, rf3, rf4
    reset(3);
    sound(51, 154);
    get.posn(0, 134, 135);
    position.v(12, 134, 135);
    ignore.blocks(12);
    set(36);
    prevent.input();
    set.view(12, 11);
    if (equaln(6, 3) || equaln(6, 4)) {
      set.loop(12, 2);
    }
    else {
      set.loop(12, 3);
    }
    fix.loop(12);
    assignn(152, 3);
    step.size(12, 152);
    assignn(152, 3);
    cycle.time(12, 152);
    start.cycling(12);
    erase(0);
    draw(12);
    if (isset(223)) {
      assignn(158, 0);
      move.obj.v(12, 107, 108, 158, 226);
    }
    if (isset(224)) {
      assignn(158, 0);
      move.obj.v(12, 107, 108, 158, 226);
      set.priority(12, 14);
    }
    if (isset(222)) {
      if (lessn(135, 125)) {
        set.priority(12, 9);
        assignn(108, 132);
        assignn(158, 0);
        move.obj.v(12, 33, 108, 158, 226);
      }
      else {
        set.priority(12, 14);
        assignn(108, 158);
        assignn(158, 0);
        move.obj.v(12, 33, 108, 158, 226);
      }
    }
  }
}
</programlisting>
</para>

</sect1>


<chapter id="formats"><title>Formats of the resource files</title>

<sect1 id="dirfmt"><title>Directory files</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 31 August 1997).
</emphasis>

   All AGI games have either one directory file, or more commonly, four.
   AGI version 2 games will have the files <literal/logdir/, <literal/picdir/,
   <literal/viewdir/, and <literal/snddir/. Games that use version 3 of the AGI
   interpreter will have a single file called <literal/*dir/ where the star
   is the initials of the game (e.g. BC, GR, MH2, MH1, KQ4). This single
   file is basically the four version 2 files joined together except that
   it has an 8 byte header giving the position of each directory within
   the single file.

   The directory files give the location of the data types within the VOL
   files. The type of directory determines the type of data. For example,
   the <literal/logdir/ gives the locations of the LOGIC files. For a brief
   introduction to the different data types, see section
   <xref linkend="overview" name="General AGI overview">.

   Note: In this description and elsewhere in documents written by me,
   the AGI data called LOGIC, PICTURE, VIEW, and SOUND data are referred
   to by me as files even though they are part of a single VOL file. I
   think of the VOL file as sort of a virtual storage device in itself
   that holds many files. Some documents call the files contains in VOL
   files ``resources''.
</para>

<sect2><title>Version 2 directories</title>
<para>
   Each directory file is of the same format. They contain a finite
   number of three byte entries, no more than 256. The size will vary
   depending on the number of files of the type that the directory file
   is pointing to. Dividing the filesize by three gives the maximum file
   number of that type of data file. Each entry is of the following
   format:

<programlisting>
    Byte 1           Byte 2           Byte 3
7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0  7 6 5 4 3 2 1 0
V V V V P P P P  P P P P P P P P  P P P P P P P P
</programlisting>

   where V = VOL number and P = position (offset into VOL file).

   The entry number itself gives the number of the data file that it is
   pointing to. For example, if the following three byte entry is entry
   number 45 in the SOUND directory file,

<programlisting>
12 3D FE
</programlisting>

   then <literal/sound.45/ is located at position 0x23DFE in the <literal/vol.1/ file.
   The first entry number is entry 0.

   If the three bytes contain the value 0xFFFFFF, then the resource does
   not exist.
</para>

<sect2><title>Version 3 directories</title>
<para>
   In the case of version 3 of the AGI interpreter, the <literal/logdir/,
   <literal/picdir/, <literal/viewdir/, and <literal/snddir/ files are concatenated together
   in that order with an eight byte header giving the starting offset of
   each directory.

   Header

<programlisting>
Byte 0 1 2 3 4 5 6 7
     L L P P V V S S
</programlisting>

   where L = offset of <literal/logdir/, P = offset of <literal/picdir/, V = offset
   of <literal/viewdir/ and S = offset of <literal/snddir/.

   Each offset is two bytes in length where the first byte is the low
   byte and the second byte is the high byte as is the case in the whole
   AGI system. For example, the first two bytes will always be 0x0800
   since the header is a fixed size of eight bytes.

   The format of each of the individual directory sections then follows
   as above for AGI v2.

</para>
</sect1>

<sect1 id="volfmt"><title>Format of Vol files (version 2)</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 31 August 1997).
</emphasis>

   Vol files are the main data files for AGI games. They contain four
   types of data: LOGIC, PICTURE, VIEW, and SOUND data. A Vol file is a
   collection of a large number of these "resource" files which can be in
   any order. The directory files determine the start of each resource.

   The start of every resource file has a five byte header.

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Signature (0x12--0x34)
  2   Vol number that the resource is contained in
 3-4  Length of the resource taken from after the header
----- -----------------------------------------------------------
</programlisting>

   The data after the header depends on the type of resource file. These
   formats are documented elsewhere.
</para>
</sect1>

<sect1 id="v3fmt"><title>Version 3 resource storage</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 27 January 1997).
</emphasis>

   AGIv3 stores resources in a slightly different way from AGIv2. The
   first significant difference is in the length of the resource header
   which is now seven bytes.

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Signature (0x12--0x34)
  2   Vol number that the resource is contained in
 3-4  Uncompressed resource size (LO-HI)
 5-6  Compressed resource size (LO-HI)
----- -----------------------------------------------------------
</programlisting>

   Instead of one resource size as in AGIv2, there are now two sizes.
   Most of the resources in AGIv3 games are compressed with a form of
   LZW. Some of them are not though. The interpreter determines whether
   the resource is compressed by comparing the values of the two sizes
   given in the header information. If they are equal, then it knows that
   the resource is stored uncompressed. However, if the sizes do not
   match, this does not mean that the file is compressed with LZW. If the
   file is a PICTURE file, then it is stored with its own limited form of
   compression. This is why the top bit of the third byte in the header
   is used to tell the interpreter that the resource is a PICTURE file,
   otherwise it would think that the resource was compressed with LZW.

   As far as I can tell, none of the PICTUREs are compressed with LZW.
   This may well be possible though. It could also be possible for the
   PICTURE to be totally uncompressed (i.e. it wouldn't use the PICTURE
   compression method), but I haven't seen any examples of either of the
   above two cases.
</para>

<sect2><title>LZW compression</title>
<para>
   The compression used with version 3 games is an adaptive form of LZW.
   The LZW algorithm is not explained here, but it basically compresses
   data by representing previous strings by single codes. When these
   strings are encountered again, the code can be stored instead. The
   following information states how the AGIv3 algorithm differs from the
   standard LZW algorithm. There are plenty of places on the net where
   you can find a description of the LZW algorithm if you are not
   familiar with it.
</para><para>
   AGIv3 uses an adaptive form of LZW that starts by using 9 bit codes
   and when the code space is full, it progresses on to 10 bits and so
   on. As with normal LZW, codes 0-255 represent the standard ASCII
   characters. The next two codes have a special meaning:
</para><para>
   <simplelist>
    <member>256 is used as a start over code. The table is cleared, the number
   of bits set back to 9, and the process begins again with the next code
   being 258.
    <member>257 tells the interpreter that it has reached the end of the
   resource.
   </simplelist>
</para><para>
   Code 256 seems to be the first code stored in all compressed
   resources. This is probably just to make sure everything is
   initialized for beginning the compression process. As was mentioned
   above, the first code used for the LZW table itself is code 258. From
   there it stores pairs of prefix codes and appended characters for each
   table entry until it reaches code 512 at which stage it switches to
   storing the codes using 10 bits and then 11 and so on. It appears that
   it will never get to 12 bits because code 256 always seems to turn up
   just before it needs to switch up to 12 bits, i.e. when code 2048 is
   required. Carl Muckenhoupt's decrypt routine for SCI games specifically
   prevents it from switching to 12 bits anyway. Whether there is ever a
   case where code 256 does not intervene, it has not yet been
   determined.
</para><para>
   Note: I should point out that Carl and myself both arrived at the
   above algorithm independently which confirms that the compression used
   in the early SCI games was identical to that used in AGIv3.
</para>

<sect2><title>Picture compression</title>
<para>
   Pictures in AGI version 3 use a simple form of compression to shrink
   their size my a tiny amount. It was obviously recognised by the
   interpreter coders that four bits were being wasted for picture codes
   0xF0 and 0xF2. These are the two codes that change the visual and the
   priority colour respectively. Since there are only 16 colours, there
   need not be a whole byte set aside for storing the colour. All the
   picture compression does is store these colours in 4 bits rather than 8.
</para><para>
   Example:
</para><para>
<programlisting>
Original picture codes: F0 06 F8 12 45 F0 07 F2 05 F8 14 67 ...
Compressed picture code: F0 6F 81 24 5F 07 F2 5F 81 46 7 ...
</programlisting>
</para>

</sect1>

<sect1 id="rescode"><title>Sample code</title>
<para>
   The following examples are available in the <ulink name="http://agi.helllabs.org/agispecs/"/distribution package/:

   <simplelist>
    <member><literal><ulink name="examples/files/agifiles.c"/agifiles.c/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: routines to handle loading of resources
    <member><literal><ulink name="examples/files/agifiles.h"/agifiles.h/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: header file for <literal/agifiles.c/
    <member><literal><ulink name="examples/files/general.h"/general.h/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: general definitions
    <member><literal><ulink name="examples/files/volx2.c"/volx2.c/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz" name="Lance Ewing">, <ulink name="mailto:jmoller@algonet.se" name="Joakim Möller"> and <ulink name="mailto:mrtn@rocketmail.com"/Martin Tillenius/: program to extract
      resources from AGI version 2 games (UNIX version available in
      the <ulink name="http://agi.helllabs.org/#utils/"/AGI Utils/ package).
    <member><literal><ulink name="examples/files/xv3.pas"/xv3.pas/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: program to extract resources from AGI version 3 games
      (UNIX version available in the <ulink name="http://agi.helllabs.org/#utils/"/AGI Utils/ package).
    <member><literal><ulink name="examples/files/agiver.pas"/agiver.pas/</literal>
      by <ulink name="mailto:mikeph@concentric.net"/Jeremy Hayes/: displays version number of game and interpreter
   </simplelist>
</para>

</sect1>
</chapter>



<chapter id="logicres"><title>LOGIC resources</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 27 January 1997).
</emphasis>
</para>

<sect1 id="logicfmt"><title>Introduction</title>
<para>
   At the heart of Sierra's Adventure Game Interpreter is the LOGIC file.
   These files contain the code that makes up the game. Each room has a
   logic script that goes with it. This logic script governs what can
   take place in that room. Here is an example of what the programmer
   writes when a game is being created.
</para><para>
   Example 0: KQ4. Room 7.
</para><para>
<programlisting>
if (said( open, door))       [ must be close enough
{
   if (posn( ego, 86, 120, 106, 133))
   {
      if (!night)
      {
         if ( door.open)
         {
            print("The door is already open");
         }
         else
         {
            set( game.control);
            set.priority( ego, 11);
            start.update( door);
            end.of.loop( door, door.done);
         }
      }
      else
      {
         print("You can't -- it's locked");
      }
   }
   else
   {
      set( notCloseEnough);
   }
}
</programlisting>

</para><para>
   The logic script is not stored like this in the game files though.
   Instead each AGI command is stored as a bytecode and the resulting data
   doesn't look much like the above example at all. This document will
   try to explain each component of a logic script the way it is stored
   in the actual game data.

</para>
</sect1>

<sect1 id="cmdlist"><title>Command list and argument types</title>
<para>
<emphasis>
Written by <ulink name="mailto:ptrkelly@ozemail.com.au"/Peter Kelly/
(Last updated: 3 March 1998).
</emphasis>

   This is a list of all AGI commands and their argument types. The
   function and name of some of these is not yet known. Check out
   <literal/agicommands.pas/ in section ``Sample code'' for a Delphi/Pascal
   unit containing this information.
</para>

<sect2><title>Text commands</title>
<para>
<programlisting>
 #  Name              No.  arg1 arg2 arg3 arg4 arg5 arg6 arg7
01 equaln              2   var  num
02 equalv              2   var  var
03 lessn               2   var  num
04 lessv               2   var  var
05 greatern            2   var  num
06 greaterv            2   var  var
07 isset               1   flag
08 issetv              1   var
09 has                 1   Iobj
0A obj.in.room         2   Iobj var
0B posn                5   Sobj num  num  num  num
0C controller          1   ctr
0D have.key            0
0E said                -  ...
0F compare.strings     2   str  str
10 obj.in.box          5   Sobj num  num  num  num
11 center.posn         5   Sobj num  num  num  num
12 right.posn          5   Sobj num  num  num  num
</programlisting>
</para>

<sect2><title>Action commands</title>
<para>
<programlisting>
 #  Name              No.  arg1 arg2 arg3 arg4 arg5 arg6 arg7
00 return              0
01 increment           1   var
02 decrement           1   var
03 assignn             2   var  num
04 assignv             2   var  var
05 addn                2   var  num
06 addv                2   var  var
07 subn                2   var  num
08 subv                2   var  var
09 lindirectv          2   var  var
0A rindirect           2   var  var
0B lindirectn          2   var  num
0C set                 1   flag
0D reset               1   flag
0E toggle              1   flag
0F set.v               1   var
10 reset.v             1   var
11 toggle.v            1   var
12 new.room            1   num
13 new.room.v          1   var
14 load.logics         1   num
15 load.logics.v       1   var
16 call                1   num
17 call.v              1   var
18 load.pic            1   var
19 draw.pic            1   var
1A show.pic            0
1B discard.pic         1   var
1C overlay.pic         1   var
1D show.pri.screen     0
1E load.view           1   num
1F load.view.v         1   var
20 discard.view        1   num
21 animate.obj         1   Sobj
22 unanimate.all       0
23 draw                1   Sobj
24 erase               1   Sobj
25 position            3   Sobj num  num
26 position.v          3   Sobj var  var
27 get.posn            3   Sobj var  var
28 reposition          3   Sobj var  var
29 set.view            2   Sobj num
02 set.view.v          2   Sobj var
02 set.loop            2   Sobj num
02 set.loop.v          2   Sobj var
02 fix.loop            1   Sobj
02 release.loop        1   Sobj
02 set.cel             2   Sobj num
1E set.cel.v           2   Sobj var
1F last.cel            2   Sobj var
20 current.cel         2   Sobj var
21 current.loop        2   Sobj var
22 current.view        2   Sobj var
23 number.of.loops     2   Sobj var
24 set.priority        2   Sobj num
25 set.priority.v      2   Sobj var
26 release.priority    1   Sobj
27 get.priority        2   Sobj var
03 stop.update         1   Sobj
03 start.update        1   Sobj
03 force.update        1   Sobj
03 ignore.horizon      1   Sobj
03 observe.horizon     1   Sobj
03 set.horizon         1   num
28 object.on.water     1   Sobj
29 object.on.land      1   Sobj
2A object.on.anything  1   Sobj
2B ignore.objs         1   Sobj
2C observe.objs        1   Sobj
2D distance            3   Sobj Sobj
2E stop.cycling        1   Sobj
2F start.cycling       1   Sobj
30 normal.cycle        1   Sobj
31 end.of.loop         2   Sobj flag
04 reverse.cycle       1   Sobj
04 reverse.loop        2   Sobj flag
04 cycle.time          2   Sobj var
04 stop.motion         1   Sobj
04 start.motion        1   Sobj
04 step.size           2   Sobj var
32 step.time           2   Sobj var
33 move.obj            5   Sobj num
34 move.obj.v          5   Sobj var
35 follow.ego          3   Sobj num
36 wander              1   Sobj
37 normal.motion       1   Sobj
38 set.dir             2   Sobj var
39 get.dir             2   Sobj var
3A ignore.blocks       1   Sobj
3B observe.blocks      1   Sobj
05 block               4   num  num
5B unblock             0
05 get                 1   Iobj
05 get.v               1   var
05 drop                1   Iobj
05 put                 2   Iobj
3C put.v               2   var  var
3D get.room.v          2   var  var
3E load.sound          1   num
3F sound               2   num  flag
64 stop.sound          0
41 print               1   msg
42 print.v             1   var
43 display             3   num  num
44 display.v           3   var  var
45 clear.lines         3   num  num
6A text.screen         0
6B graphics            0
06 set.cursor.char     1   msg
06 set.text.attribute  2   num  num
06 shake.screen        1   num
06 configure.screen    3   num  num
70 status.line.on      0
71 status.line.off     0
48 set.string          2   strinmessa
49 get.string          5   strinmessa
4A word.to.string      2   word strin
4B parse               1   strin
4C get.num             2   messavar
77 prevent.input       0
78 accept.input        0
4F set.key             3   num  num
07 add.to.pic          7   num  num
07 add.to.pic.v        7   var  var
7C status              0
7D save.game           0
7E restore.game        0
7F init.disk           0
80 restart.game        0
51 show.obj            1   num
52 random              3   num  num
83 program.control     0
84 player.control      0
55 obj.status.v        1   var
56 quit                1   num
87 show.mem            0
88 pause               0
89 echo.line           0
8A cancel.line         0
8B init.joy            0
8C toggle.monitor      0
8D version             0
08 script.size         1   num
08 set.game.id         1   messa
5A log                 1   messa
91 set.scan.start      0
92 reset.scan.start    0
5D reposition.to       3   Sobj num
5E reposition.to.v     3   Sobj var
95 trace.on            0
60 trace.info          3   num  num
61 print.at            4   messanum
62 print.at.v          4   messavar
63 discard.view.v      1   var
09 clear.text.rect     5   num  num
9B set.upper.left      2   ???  ???
09 set.menu            1   messa
09 set.menu.member       2   messacntrl
9E submit.menu         0
09 enable.member         1   cntrl
00 disable.member        1   cntrl
A1 menu.input          0
00 show.obj.v          1   var
A3 open.dialogue       0
A4 close.dialogue      0
00 mul.n               2   var  num
00 mul.v               2   var  var
00 div.n               2   var  num
00 div.v               2   var  var
A9 close.window        0
AA unknown170          1   ???
AB unknown171          0
AC unknown172          0
AD unknown173          0
AE unknown174          1   ???
AF unknown175          1   ???
B0 unknown176          0   (1 arg for AGI version 3.002.086)
B1 unknown177          1   ???
B2 unknown178          0
B3 unknown179          4   ???  ???  ???  ???
B4 unknown180          2   ???  ???
B5 unknown181          0
</programlisting>
</para>
</sect1>

<sect1><title>LOGIC resource format</title>
<sect2><title>The header</title>
<para>
   The header of each logic script is seven bytes in length for games
   before 1988. After this date compression seems to have been introduced
   and the header was subsequently altered. This compression will be
   discussed at a later stage.

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  0x1234: signature for the start of a file in the VOL block
  2   Vol file number
 3-4  Length of the logic script
 5-6  Offset of logic code end and text begin
----- -----------------------------------------------------------
</programlisting>

   All text that can be printed to the screen from within a logic script
   is stored in an encrypted form at the end of the logic script.

   Example 1: KQ1. Room 2.

<programlisting>
 12 34    Signature
 01       vol.1
 5F 06    Length = 0x065F
 BA 02    Text start = 0x02BA
</programlisting>
</para>

<sect2><title>The LOGIC codes</title>
<para>
   The logic code section starts immediately after the header and
   continues until the start of the text section has been reached. There
   are three sets of codes used in a logic script. Most codes will have
   between one and seven arguments inclusive. This is discussed later on.
   The first set of codes is the AGI commands themselves and they have
   the range:

<programlisting>
0x00 - 0xB5    AGI commands. (eg. animate.obj)
</programlisting>

   The value 181 (0xB5) may well be different for each game. Sierra will
   have added more commands to their set as they went along. The value
   above is for Manhunter 2 which is one of the last AGI games made. The
   second set of codes is as follows:

<programlisting>
   FF      if
   FE      else (or goto)
   FD      not (!)
   FC      or (||)
</programlisting>

   At present these are the only high value codes encountered. The <literal/if/
   and <literal/or/ codes are more like brackets, ie. the code will be at the
   start and the end of the section of codes that it refers to. The
   following example will illustrate this:

   Example 2: KQ1. Room 2.
<programlisting>
   FF      'if' conditions start.
   07      07 = isset
   05      05 = flag 5
   FF      'if' conditions close.
</programlisting>

   The above translates to:

<programlisting>
if (isset(5))
</programlisting>

   which tests whether flag number 5 is set. The 0xFF effectively switches
   the interpreter into a condition checking mode which leads us to the
   next set of codes which I call the condition codes:

<programlisting>
0x00 - 0x12    Condition codes.
</programlisting>

   The <literal/isset/ condition code was introduced in example 2 above. When the
   interpreter encounters a 0xFF it will then interpret the following code
   values as being in the condition code range until it encounters the
   next 0xFF which switches it back into normal AGI command mode. The two
   bytes immediately following the second 0xFF determine how many bytes
   this <literal/if/ statement lasts for before the <literal/if/ is ended. When the
   second 0xFF is encountered the interpreter, be it us or the machine,
   does three things:
   <enum>
    <listitem><para>Reads in the following two bytes.
    <listitem><para>Opens a bracket.
    <listitem><para>Switches to AGI command mode.
   </enum>

   Example 3: KQ1. Room 2.
<programlisting>
FF 07 05 FF    if (isset(5))
84 00          {			[ For 0x0084 bytes.
18 00              load.pic(0);
19 00              draw.pic(0);
1B 00              discard.pic(0);
...		   ...
               }			[ Closed. 0x0084 bytes counted.
</programlisting>

   Of course, the code inside the brackets is only executed if the <literal/if/
   condition is met.
</para>

<sect2><title>The <literal/else/ command and more on brackets</title>
<para>
   The else statement will always continue after an <literal/if/ bracket block.
   This next feature is important and has caused a number of hassles in
   the past. When an <literal/else/ statement follows an <literal/if/, then the bracket
   distance given after the <literal/if/ statement <emphasis>will be three bytes
   longer</emphasis> (this is a consequence of the way the interpreter handles
   <literal/if/ and <literal/else/ codes which is discussed later).

   Here's an example:
<programlisting>
if (isset(231)) {                          FF 07 E7 FF 05 00
    printf("The door is already open.");   65 0F
}
else {                                     FE 11 00
    set(36);                               0C 24
    prevent.input();                       77
    start.update(5);                       3B 05
    assignn(152, 3);                       03 98 03
    cycle.time(5, 152);                    4C 05 98
    end.of.loop(5, 232);                   49 05 E8
    sound(70, 154);                        63 46 9A
}
</programlisting>

   Usually you would expect the bracket distance to be 0x0002 but in the
   above case it is clearly 0x0005 which illustrates the difference
   between a straight <literal/if/ statement and an <literal/if..else/ structure. The
   situation is the same for nested <literal/if..else/ structures.

   The <literal/else/ statements themselves are a lot like <literal/if/ statements
   except that they're test condition is given after the 0xFE code but is
   instead the inverse of the condition given by the above <literal/if/
   statement. Only the bracket distance is given after the 0xFE code and
   then the AGI command clock that the <literal/else/ statement encompasses.
</para>

<sect2><title>Test conditions</title>
<para>
   Conditions can be one of the following types:
<programlisting>
FF 07 05 FF                         One condition tested, ie. isset(5)
FF FD 07 05 FF                      One condition NOTed, ie. !isset(5)
FF 07 05 07 06 FF                   Multiple conditions, ANDed.
FF FC 07 05 07 06 FC FF             Multiple conditions ORed.
FF FC 07 06 07 06 FC FD 07 08 FF    Combination.
</programlisting>
   These conditions translate to:
<programlisting>
if (isset(5))
if (!isset(5))
if (isset(5) && isset(6))
if (isset(5) || isset(6))
if ((isset(5) || isset(6)) && !isset(7))
</programlisting>

   If multiple boolean expressions are grouped together, then there
   respective values are ANDed together. If multiple boolean expressions
   are grouped together and then surrounded by a pair of 0xFC codes, then
   their values are ORed together.

   The 0xFD code only applies to the following condition code whose
   boolean value it inverts.
</para>

<sect2><title>Arguments</title>
<para>
   You may well be asking how the interpreter knows how many arguments
   each code has and what type of argument each argument is. This
   information is stored in a file called <literal/agidata.ovl/ (MS-DOS version).
   Inside this file there is a table which contains four bytes for each
   AGI command and condition code. These four bytes are interpreted as
   follows:

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Pointer to the machine code implementation contained in the
      file agi
  2   Number of arguments
  3   The type of arguments
----- -----------------------------------------------------------
</programlisting>

   The type of arguments value is interpreted as follows:

<programlisting>
Bit        7     6     5     4     3     2     1       0
command( arg1, arg2, arg3, arg4, arg5, arg6, arg7); (unknown)
</programlisting>

   If the bit is set, argument is interpreted as a variable; otherwise
   the argument is interpreted as a number. It is unknown what bit 0 does
   since no AGI command or AGI condition code has more than seven arguments.

   Examples:
   <simplelist>
    <member>0x80 Says that the commands first argument is a variable.
    <member>0x60 Says that the second and third arguments are variable numbers.
   </simplelist>
</para>


<sect2><title>The text section</title>
<para>
   The text section of a logic script contains all the strings that can
   be displayed by that logic script. These strings are encrypted by
   xoring every eleven bytes with the string "Avis Durgan".

   Example 4: KQ1. Room 2.
<programlisting>
if (said(look, alligators))
{
    print("The alligators are swimming in the moat.");
}
</programlisting>

   In the above example, the print statement is represented as:

<programlisting>
65 08
</programlisting>

   The 0x08 is the number given to the string and corresponds to its
   position in the list of strings at the end of the logic script.

   The format of the text section is as follows:
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Number of messages
 1-2  Pointer to end of messages
 3-4  A list of offsets which point to each of the messages. The
      first offset naturally enough points to the start of the
      textual data
 ...
  ?   Start of the text data. From this point the messages are
      encrypted with Avis Durgan (in their unencrypted form, each
      message is separated by a 0x00 value)
----- -----------------------------------------------------------
</programlisting>
</para>

<sect2><title>Machine code implementation</title>
<para>
   The machine code for each AGI statement is found in the AGI file. This
   is the AGI interpreter itself. The data in the <literal/agidata.ovl/ file is
   used to find the start of the implementation for an AGI statement.
   Below are a couple of examples:

   Example 5: MH2. equaln.
<programlisting>
;equaln   (eg.   if (work = 3)   )
0D71 AC            LODSB                       ;get variable number
0D72 32FF          XOR     BH,BH
0D74 8AD8          MOV     BL,AL
0D76 AC            LODSB                       ;get test number
0D77 3A870900      CMP     AL,[BX+0009]        ;test if var = number
0D7B B000          MOV     AL,00               ;return 0 if not equal
0D7D 7502          JNZ     0D81
0D7F FEC0          INC     AL                  ;return 1 if equal
0D81 C3            RET
</programlisting>

   Example 6: MH2. equalv.
<programlisting>
;equalv  (eg.   if (work = maxwork)   )
0D82 AC            LODSB                       ;get first var number
0D83 32FF          XOR     BH,BH               ;clear bh
0D85 8AD8          MOV     BL,AL               ;BX = variable number
0D87 8AA70900      MOV     AH,[BX+0009]        ;get first var value
0D8B AC            LODSB                       ;get second var number
0D8C 8AD8          MOV     BL,AL
0D8E 32C0          XOR     AL,AL               ;return 0 if not equal
0D90 3AA70900      CMP     AH,[BX+0009]        ;compare variables
0D94 7502          JNZ     0D98
0D96 FEC0          INC     AL                  ;return 1 if equal
0D98 C3            RET
</programlisting>

   These two examples show the difference between how numbers and
   variables are dealt with. In the case of a variable, the variables
   number is used as an index into the table of variable values to get
   the value which is being tested. It appears that the variable table is
   at offset 0x0009 in the data segment.
</para>

<sect2><title>How the interpreter handles LOGIC code</title>
<para>
   Now that you know a bit about what the actual code looks like once it
   has been converted into the LOGIC game data, we will now look at how
   these codes are interpreted by the interpreter. The following 8086
   assembly language code is the actual code from the MS-DOS version of
   Manhunter: San Francisco. There are some calls
   to routines which aren't displayed. Take my word for it that they do
   what the comment says. For those of you who can't follow whats going
   on, I'll explain the interpretation in steps after the code block.

<programlisting>
;Decoding a LOGIC file.
1E6C:2EF2 56            PUSH  SI
1E6C:2EF3 57            PUSH  DI
1E6C:2EF4 55            PUSH  BP
1E6C:2EF5 8BEC          MOV   BP,SP
1E6C:2EF7 83EC02        SUB   SP,+02
1E6C:2EFA 8B7608        MOV   SI,[BP+08]    ;SI -> start of LOGIC script.
1E6C:2EFD 8B7406        MOV   SI,[SI+06]    ;Skip first 6 bytes (header).
1E6C:2F00 AC            LODSB               ;Get next byte in LOGIC file.
1E6C:2F01 84C0          TEST  AL,AL         ;Is code a zero?
1E6C:2F03 7414          JZ    2F19          ;If so, jump to exit.
1E6C:2F05 3CFF          CMP   AL,FF         ;If an opening 'if' code is found
1E6C:2F07 7419          JZ    2F22          ;jump to 'if' handler.
1E6C:2F09 3CFE          CMP   AL,FE         ;If an 'else' has not been found
1E6C:2F0B 7505          JNZ   2F12          ;jump over else/branch.
1E6C:2F0D AD            LODSW               ;Get word (bracket distance)
1E6C:2F0E 03F0          ADD   SI,AX         ;Add to SI. Skip else code.
1E6C:2F10 EBEE          JMP   2F00          ;Go back to get next byte.
1E6C:2F12 E8A8D6        CALL  05BD          ;Execute AGI command.
1E6C:2F15 85F6          TEST  SI,SI         ;
1E6C:2F17 75E8          JNZ   2F01          ;Jump back to top.
1E6C:2F19 8BC6          MOV   AX,SI
1E6C:2F1B 83C402        ADD   SP,+02
1E6C:2F1E 5D            POP   BP
1E6C:2F1F 5F            POP   DI
1E6C:2F20 5E            POP   SI
1E6C:2F21 C3            RET

;Handler for 'if' statement.
;BH determines if its in an OR bracket (BH=1 means OR).
;BL determines the nature of the evalutation (BL=1 means NOT)
1E6C:2F22 33DB          XOR   BX,BX
1E6C:2F24 AC            LODSB               ;Get next byte
1E6C:2F25 3CFC          CMP   AL,FC         ;If less than 0xFC, then
1E6C:2F27 721C          JB    2F45          ;jump to normal processing.
1E6C:2F29 7508          JNZ   2F33          ;If greater, jump to 'if' close.
1E6C:2F2B 84FF          TEST  BH,BH         ;(Could BH be the evaluation reg?
1E6C:2F2D 7551          JNZ   2F80          ;or whether its the second FC?
1E6C:2F2F FEC7          INC   BH            ;
1E6C:2F31 EBF1          JMP   2F24          ;Go back to get next byte.

1E6C:2F33 3CFF          CMP   AL,FF         ;Is the code for an 'if' close?
1E6C:2F35 7505          JNZ   2F3C          ;If not, jump to 'not' test.
1E6C:2F37 83C602        ADD   SI,+02        ;
1E6C:2F3A EBC4          JMP   2F00          ;
1E6C:2F3C 3CFD          CMP   AL,FD         ;Is the code for a 'not'?
1E6C:2F3E 7505          JNZ   2F45          ;If not, jump to test command.
1E6C:2F40 80F301        XOR   BL,01         ;
1E6C:2F43 EBDF          JMP   2F24          ;Go back to get next byte.
1E6C:2F45 53            PUSH  BX            ;BX = test conditions??
1E6C:2F46 E8E8DD        CALL  0D31          ;Evaluate separate test command.
1E6C:2F49 5B            POP   BX            ;
1E6C:2F4A 32C3          XOR   AL,BL         ;Toggle the result for NOT.
1E6C:2F4C B300          MOV   BL,00         ;
1E6C:2F4E 7506          JNZ   2F56          ;If true jump to 2F56.
1E6C:2F50 84FF          TEST  BH,BH         ;If BH=0 then not in OR and
1E6C:2F52 742C          JZ    2F80          ;test is truely false.
1E6C:2F54 EBCE          JMP   2F24          ;Otherwise evaluate next OR.
1E6C:2F56 84FF          TEST  BH,BH         ;Are we in OR mode?
1E6C:2F58 7424          JZ    2F7E          ;If not, continue with testing.
1E6C:2F5A 32FF          XOR   BH,BH         ;If so, then we will skip the
1E6C:2F5C 32E4          XOR   AH,AH         ;rest of the tests in the OR
1E6C:2F5E AC            LODSB               ;bracket since the first is true.
1E6C:2F5F 3CFC          CMP   AL,FC         ;OR: Waiting for closing OR.
1E6C:2F61 741B          JZ    2F7E          ;If OR found, then continue testing.
1E6C:2F63 77F9          JA    2F5E          ;
1E6C:2F65 3C0E          CMP   AL,0E         ;If 'said' then goto said handler
1E6C:2F67 7507          JNZ   2F70          ;else goto normal handler
1E6C:2F69 AC            LODSB               ;Work out number of words in said
1E6C:2F6A D1E0          SHL   AX,1          ;and jump over them.
1E6C:2F6C 03F0          ADD   SI,AX         ;
1E6C:2F6E EBEE          JMP   2F5E          ;
1E6C:2F70 8BF8          MOV   DI,AX         ;Jumps over arguments.
1E6C:2F72 D1E7          SHL   DI,1          ;
1E6C:2F74 D1E7          SHL   DI,1          ;
1E6C:2F76 8A856407      MOV   AL,[DI+0764]  ;Load up the number of arguments
1E6C:2F7A 03F0          ADD   SI,AX         ;Add to the execution pointer
1E6C:2F7C EBE0          JMP   2F5E          ;
1E6C:2F7E EBA4          JMP   2F24

;Test is false.
;This routine basically skips over the rest of the codes until it finds the
;closing 0xFF at which point it will load the following two bytes and add
;them to the execution pointer SI.
1E6C:2F80 32FF          XOR   BH,BH
1E6C:2F82 32E4          XOR   AH,AH
1E6C:2F84 AC            LODSB               ;
1E6C:2F85 3CFF          CMP   AL,FF         ;If the closing 0XFF is found,
1E6C:2F87 741D          JZ    2FA6          ;jump 2FA6.
1E6C:2F89 3CFC          CMP   AL,FC         ;If greater than FC,
1E6C:2F8B 73F7          JNB   2F84          ;get next byte.
1E6C:2F8D 3C0E          CMP   AL,0E         ;If 'said' then goto said handler
1E6C:2F8F 7507          JNZ   2F98          ;else goto normal handler.
1E6C:2F91 AC            LODSB               ;Work out number of words in said
1E6C:2F92 D1E0          SHL   AX,1          ;and jump over them.
1E6C:2F94 03F0          ADD   SI,AX
1E6C:2F96 EBEC          JMP   2F84
1E6C:2F98 8AD8          MOV   BL,AL         ;Jump over arguments.
1E6C:2F9A D1E3          SHL   BX,1
1E6C:2F9C D1E3          SHL   BX,1
1E6C:2F9E 8A876407      MOV   AL,[BX+0764]  ;Load up the number of arguments.
1E6C:2FA2 03F0          ADD   SI,AX         ;Add to the execution pointer.
1E6C:2FA4 EBDE          JMP   2F84
1E6C:2FA6 AD            LODSW
1E6C:2FA7 03F0          ADD   SI,AX         ;Skip over if (includes 3 else byte
s)
1E6C:2FA9 E954FF        JMP   2F00
</programlisting>

   <emphasis/Situation 1./ Okay, every LOGIC file starts in normal AGI command
   execution mode. In this routine, if the code is below 0xFC, then it is
   presumed to be an AGI command. It will then call the main command
   execution routine which will jump to the relevant routine for the
   specific command using the jump table stored in <literal/agidata.ovl/. The
   command is performed and it returns to the main execution routine
   where it loops back to the top and deals with the next code in the
   LOGIC file.

   <emphasis/Situation 2./ If the code is an 0xFF code, then if jumps to the <literal/if/
   statement handler. In this routine is basically assesses whether the
   whole test condition evaluates to true or to false. It does this by
   treating each test separately and calling the relevant test command
   routines using the jump table in the <literal/agidata.ovl/ file. Each test
   command routine will return a value in <literal/AL/ which says whether it is
   true or not. Depending on the NOTs and ORs, the whole expression is
   evaluated. If at any stage during the evaluation the routine decides
   that the expression will be false, it exits to another routine which
   skips the rest of the <literal/if/ statement and then adds the two byte word
   following the closing 0xFF code to the execution pointer. This usually
   has the affect of jumping over the <literal/if/ block of code. If the
   <literal/if/ handler gets to the ending 0xFF then it knows the expression
   is true simply because it hasn't exited out of the routine yet. At this
   stage it jumps over the two bytes following the closing 0xFF and then
   goes back to executing straight AGI commands.

   <emphasis/Situation 3./ If in the normal execution of AGI commands, the code 0xFE
   is encountered, a very simple action takes place. The two bytes which
   follow form a 16-bit twos complement value which is added to execution
   pointer. This is all it does. Previously we said that the 0xFE code
   stood for the <literal/else/ statement which is in actual fact correct for
   over 90% of the time, but the small number of other occurrences are
   best described as <literal/goto/ statements. If you're confused by this, the
   following example will probably explain things.

   Example:
<programlisting>
if (said( open, door)) {
    [ first block of AGI statements
}
else {
    [ second block of AGI statements
}
</programlisting>

   The above example is how the original coder would have written the AGI
   code. If we now look at the following example, it is not hard to see
   that it would achieve the same thing.

<programlisting>
if (!said( open, door)) goto label1;
    [ first block of AGI statements
    goto label2:

label1:
    [ second block of AGI statements

label2:
</programlisting>

   This is exactly how all <literal/if/s and <literal/else/s are implemented in the LOGIC
   code. The <literal/if/ statement is a conditional branch where the branch is
   taken if the condition is not met, while the <literal/else/ statement is a
   nonconditional jump. If a 0xFE code appears in the middle of some AGI
   code and wasn't actually originally coded as an <literal/else/, then it was
   most likely a <literal/goto/ statement.
</para>

<sect2><title>The <literal/said/ test command</title>
<para>
   The above assembly language code does raise a very important point.
   The <literal/said/ command can have a variable number of arguments. Its
   code is 0x0E, and the byte following this byte gives the number of
   two byte words that follow as parameters.

   Examples:

<programlisting>
if (said(marble))                          FF 0E 01 1E 01 FF
if (said( open, door))                     FF 0E 02 37 02 73 00 FF
</programlisting>

   In the above examples, the values 0x011E, 0x0237, and 0x0073 are just
   random word numbers that could stand for the words given.
</para>

<sect2><title>Inner loops</title>
<para>
   At first I almost totally discarded the existence of loops in the AGI
   code because it seemed to me that execution of the LOGIC file
   continually looped. Loop code like ``while'', ``do..while'', and ``for''
   statements wouldn't be needed because you could just use a variable to
   increment with each pass and an <literal/if/ statement to test the value of
   the variable and take action if it was withing the desired range.

   Example:
<programlisting>
if (greatern(30, 45) && lessn(30, 55)) {
    print("You're in the hot zone!);
    increment(30);
}
</programlisting>

   I have found evidence of this sort of thing taking place which means
   that they must loop over continuously. I don't know whether this is
   something that the interpreter does itself or whether it is part of
   the AGI code, e.g. at the end of one LOGIC file it calls another which
   then calls the first one again. With the existence of the conditional
   branching and unconditional branching nature of the <literal/if/ and <literal/else/
   statement, it is easy to see that some of the structures such as
   ``do..while'' can infact be coded into LOGIC code.

   Example:

<programlisting>
FF FD 0D FF 03 00 FE F7 FF

do {
} while (!havekey);
</programlisting>

   The above translation is a simple one which is taken from SQ2. The
   value 0xFFF7 is the twos complement notation for -9 which is the exact
   branching value to take the execution back to the start of the <literal/if/
   statement. If the above example had AGI code between the 0x00 and the
   0xFE, then there would be code within the brackets of the ``do..while''
   structure. I don't know whether the original AGI coders used these
   statements or used <literal/goto/ statements to achieve the same result.
</para>

<sect2><title>New information on LOGIC interpretation</title>
<para>
   It has now come to light that <literal/logic.0/ is run over and over again with
   each interpretation cycle. The other LOGICs that have been loaded will
   only get executed if <literal/logic.0/ calls them directly or indirectly (i.e.
   LOGICs called from <literal/logic.0/ can call other LOGICs and so on).

   I have also become aware that code 0x00 can basically be thought of
   as the command <literal/return/. If <literal/logic.0/ calls another logic, the
   execution will return to <literal/LOGIC.0/ when the 0x00 code is encountered.

   It is also possible to set the entry point for a LOGIC file. The
   <literal/set.scan.start/ command makes the entry point of the LOGIC file being
   executed equal to the position of the command following
   <literal/set.scan.start/. This means that the next time the LOGIC file is
   executed, execution begins at that point. The <literal/reset.scan.start/
   command sets the entry point back to the start of the LOGIC.
</para>


<sect1 id="logiccode"><title>Sample code</title>
<para>
   The following examples are available in the <ulink name="http://agi.helllabs.org/agispecs/"/distribution package/:

   <simplelist>
    <member><literal><ulink name="examples/logic/logic.c"/logic.c/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: loads LOGIC resources into LOGICFile structure
    <member><literal><ulink name="examples/logic/logic.h"/logic.h/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: header file for <literal/logic.c/
    <member><literal><ulink name="examples/files/agifiles.c"/agifiles.c/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: routines to handle loading of resources
    <member><literal><ulink name="examples/files/agifiles.h"/agifiles.h/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: header file for <literal/agifiles.c/
    <member><literal><ulink name="examples/logic/agicommands.pas"/agicommands.pas/</literal>
      by <ulink name="mailto:ptrkelly@ozemail.com.au"/Peter Kelly/: Delphi/Pascal unit with a list of all commands and
      argument types
   </simplelist>
</para>
</sect1>

</chapter>


<chapter id="picture"><title>PICTURE resources</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz" name="Lance Ewing">, with additions/modifications by <ulink name="mailto:claudio@helllabs.org"/Claudio Matsuoka/
based on the AGDS documentation translated by <ulink name="mailto:nest@rtsnet.ru"/Vassili Bykov/
(Last updated: 22 May 1999).
</emphasis>
</para>

<sect1 id="picintro"><title>Introduction</title>
<para>
   PICTURE is usually used for background pictures and other full
   screen images. Pictures in AGI and early SCI games are not stored as a
   complete picture. Instead they're constructed and stored as
   coordinates and vectors. Vectors give the instructions for drawing a
   picture and they have the advantage of taking less space than would a
   bit image of a complete picture.

   Pictures are drawn using nine different drawing actions. These actions
   are given values from 0xF0 to 0xFA and are defined as follows:

   <simplelist>
    <member>0xF0: Change picture colour and enable picture draw.
    <member>0xF1: Disable picture draw.
    <member>0xF2: Change priority colour and enable priority draw.
    <member>0xF3: Disable priority draw.
    <member>0xF4: Draw a Y corner.
    <member>0xF5: Draw an X corner.
    <member>0xF6: Absolute line (long lines).
    <member>0xF7: Relative line (short lines).
    <member>0xF8: Fill.
    <member>0xF9: Change pen size and style.
    <member>0xFA: Plot with pen.
    <member>0xFB--0xFE: Unused in most AGI games.
   </simplelist>

   Note: SQ2 appears to be the only AGI version 2 game that uses 0xF9 and
   0xFA. The AGI interpreters before this game will most likely not
   support these two drawing actions.

   In the following detailed descriptions of each action, the word
   ``picture'' refers to the screen that is seen by the player when they
   play the AGI screen. The word ``priority'' refers to the screen that is
   held in memory and contains control information invisible to the
   player. As a picture is drawn, both screens are updated depending on
   whether drawing is enabled from each screen.
</para>
</sect1>

<sect1 id="picfmt"><title>PICTURE resource format</title>
<para>
   The PICTURE data can be processed byte by byte. Whenever a value of
   0xF0 or greater is encountered, the action is changed to the one given
   and then all the bytes between this code and the next action code are
   arguments to this action. Half of the actions have a set number of
   arguments, the other half can have an unlimited number of arguments.
   The special code 0xFF says that the end of the picture data has been
   reached. All other values are used by the various drawing actions to
   tell them what to draw and will always be less than 0xF0.
</para>

<sect2><title>Color palette</title>
<para>
   The following colors are used in AGI. RGB is given in 6 bit values.
   <programlisting>
Code  Color             R    G    B
----- ---------------- ---- ---- ----
  0   black            0x00 0x00 0x00
  1   blue             0x00 0x00 0x2A
  2   green            0x00 0x2A 0x00
  3   cyan             0x00 0x2A 0x2A
  4   red              0x2A 0x00 0x00
  5   magenta          0x2A 0x00 0x2A
  6   brown            0x2A 0x15 0x00
  7   light grey       0x2A 0x2A 0x2A
  8   dark drey        0x15 0x15 0x15
  9   light blue       0x15 0x15 0x3F
 10   light green      0x15 0x3F 0x15
 11   light cyan       0x15 0x3F 0x3F
 12   light red        0x3F 0x15 0x15
 13   light magenta    0x3F 0x15 0x3F
 14   yellow           0x3F 0x3F 0x15
 15   white            0x3F 0x3F 0x3F
   </programlisting>
</para>

<sect2><title>General actions</title>
<para>
   <variablelist>
   <varlistentry/0xF0: Change picture colour and enable picture draw/

   <emphasis/Function:/ Changes the current drawing colour for the picture
   screen to that given by the one and only argument, and enables subsequent
   actions to draw to the picture screen.

   Initially all pixels of the background are white and have priority 4.
   After this command is executed, all the subsequent graphic commands
   draw using the colour set by the command.

   <emphasis/Example:/ <literal/F0 0D/ changes picture screen drawing colour to
   light magenta and enables drawing to the picture screen.

   <varlistentry/0xF1: Disable picture draw/

   <emphasis/Function:/ Disables drawing to the picture screen. This is done
   whenever there is something which only needs to be drawn on the
   priority screen such as the control lines. There are no arguments for
   this action.

   <varlistentry/0xF2: Change priority colour and enable priority draw/

   <emphasis/Function:/ Changes the current drawing colour for the priority screen
   to that given by the one and only argument, and enables subsequent
   actions to draw to the priority screen.

   <emphasis/Example:/ <literal/F0 04/ changes priority screen drawing colour to
   red and enables drawing to the priority screen.

   <varlistentry/0xF3: Disable priority draw/

   <emphasis/Function:/ Disables drawing to the priority screen. This is done
   whenever there is something which only needs to be drawn on the
   picture screen such as the finer details of the picture. There are no
   arguments for this action.
   </variablelist>
</para>

<sect2><title>The corner action</title>
<para>
   I call the following two actions the ``corner actions'' because they do
   not draw diagonal lines at all but instead alternate from horizontal
   line to vertical line (or vice versa) giving rise to a series of right
   angled corners.
<programlisting>
       _________
      |         |    B__
      |         |_____  |
      |               |_|
      A
</programlisting>
   The above diagram shows the type of pattern created. If A were the
   starting coordinate, then it would be called a Y corner. This is
   because the Y or vertical component is changed first. If B were the
   starting coordinate, then it would be called an X corner. This is
   because the X or horizontal component is changed first.

   <variablelist>
   <varlistentry/0xF4: Draw a Y corner/

   <emphasis/Function:/ The first two arguments for this action are the
   coordinates of the starting position on the screen in the order x and
   then y. The remaining arguments are in the order y1, x1, y2, x2, ...

   Note that the y component is the first to be changed and also note
   that this action does not necessarily end on either component, it just
   ends when the next byte of 0xF0 or above is encountered. A line is
   drawn after each byte is processed.

   <emphasis/Example:/ <literal/F4 16 16 18 12 16 F?/
<programlisting>
 (0x12, 0x16)     (0x16, 0x16)
             E   S                  S = Start
             X   X                  E = End
             XXXXX                  X = normal piXel
 (0x12, 0x18)     (0x16, 0x18)
</programlisting>

   <varlistentry/0xF5: Draw an X corner/

   <emphasis/Function:/ The first two arguments for this action are the
   coordinates of the starting position on the screen in the order x and
   then y. The remaining arguments are in the order x1, y1, x2, y2, ...

   Note that the x component is the first to be changed and also note
   that this action does not necessarily end on either component, it just
   ends when the next byte of 0xF0 or above is encountered. A line is
   drawn after each byte is processed.

   <emphasis/Example:/ <literal/F5 16 16 18 12 16 F?/
<programlisting>
  (0x16, 0x12)   (0x18, 0x12)
              EXX
                X            S = Start
                X            E = End
                X            X = normal piXel
              SXX
  (0x16, 0x16)   (0x18, 0x16)
</programlisting>

   <varlistentry/0xF6: Absolute line/

   <emphasis/Function:/ Draws lines between points. The first two arguments
   are the starting coordinates. The remaining arguments are in groups of two
   which give the coordinates of the next location to draw a line to.
   There can be any number of arguments but there should always be an
   even number.

   <emphasis/Example:/ <literal/F6 30 50 34 51 38 53 F?/

   This sequence draws a line from (48, 80) to (52, 81), and a line from
   (52, 81) to (56, 83).

   <varlistentry/0xF7: Relative line/

   <emphasis/Function:/ Draw short relative lines. By relative we mean that
   the data gives displacements which are relative from the current location.
   The first argument gives the standard starting coordinates. All the
   arguments which follow these first two are of the following format:

<programlisting>
+---+-----------+---+-----------+
| S |   Xdisp   | S |   Ydisp   |
+---+---+---+---+---+---+---+---+
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+---+---+---+---+---+---+---+---+
</programlisting>

   This gives a displacement range of between -7 and +7 for both the X
   and the Y direction.

   <emphasis/Example:/ <literal/F7 10 10 22 40 06 CC F?/

<programlisting>
              S
               +              S = Start
                X+++X         X = End of each line
                    +         + = pixels in each line
                E   +         E = End
                 +  +
                  + +         Remember that CC = (x-4, y-4).
                   ++
                    X
</programlisting>

   <varlistentry/0xF8: Fill/

   <emphasis/Function:/ Flood fill from the locations given. Arguments are
   given in groups of two bytes which give the coordinates of the location to
   start the fill at. If picture drawing is enabled then it flood fills
   from that location on the picture screen to all pixels locations that
   it can reach which are white in colour. The boundary is given by any
   pixels which are not white.

   If priority drawing is enabled, and picture drawing is not enabled,
   then it flood fills from that location on the priority screen to all
   pixels that it can reach which are red in colour. The boundary in this
   case is given by any pixels which are not red.

   If both picture drawing and priority drawing are enabled, then a flood
   fill naturally enough takes place on both screens. In this case there
   is a difference in the way the fill takes place in the priority
   screen. The difference is that it not only looks for its own boundary,
   but also stops if it reaches a boundary that exists in the picture
   screen but does not necessarily exist in the priority screen.
   </variablelist>
</para>

<sect2><title>Brush style</title>
<para>
   Drawing actions 0xF9 and 0xFA deal with plotting patterns. Most
   drawing programs have options to change the size, and style of the pen
   or brush. The style covers different shapes and textures. AGI PICTURES
   provide these tools as well.

   <variablelist>
   <varlistentry/0xF9: Change pen size and style/

   <emphasis/Function:/ Change the characteristics of the pattern plotted by drawing
   action 0xFA. If bit 5 is not set, then the pattern is a solid shape.
   If bit 5 is set, then the pattern is like a splatter. Bit 4 selects
   whether the brush is a circle or a rectangle. Bits 0-2 give the size
   of the shape which will be a value from 0 to 7. These characteristics
   appear to only affect drawing action 0xFA.

   The default brush is a solid circle or rectangle of size 0, which
   should be used until an 0xF9 action is encountered.
<programlisting>
           ___ ___ ___ ___ ___ ___ ___ ___
          | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
          |___|___|___|___|___|___|___|___|
                    |   |       |___|___|
 0 = Solid _________|   |           |
 1 = Splatter           |           |______ Pen size
                        |
 0 = Circle ____________|
 1 = Rectangle

   RECTANGLE SIZES
 X XX XXX XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX         size+1
 0 X* XXX XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX       _____________
   XX X*X XXXX XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
   1  XXX XX*X XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
      XXX XXXX XX*XX XXXXXX XXXXXXX XXXXXXXX      |             |
       2  XXXX XXXXX XXX*XX XXXXXXX XXXXXXXX      |             | (size*2)+1
          XXXX XXXXX XXXXXX XXX*XXX XXXXXXXX      |             |
           3   XXXXX XXXXXX XXXXXXX XXXX*XXX      |             |
               XXXXX XXXXXX XXXXXXX XXXXXXXX      |             |
                 4   XXXXXX XXXXXXX XXXXXXXX      |             |
                     XXXXXX XXXXXXX XXXXXXXX      |             |
  WHERE                5    XXXXXXX XXXXXXXX      |_____________|
                            XXXXXXX XXXXXXXX
    X = agi pixels             6    XXXXXXXX         IN GENERAL
    * = coordinates given           XXXXXXXX
        for plot                       7

   CIRCLE SIZES
 X XX  X   XX    X     XX     XXX      XX            size+1
 0 X* XXX  XX   XXX   XXXX   XXXXX    XXXX         _____________
   XX X*X XXXX XXXXX  XXXX   XXXXX   XXXXXX       |             |
   1  XXX XX*X XXXXX  XXXX   XXXXX   XXXXXX       |             |
       X  XXXX XX*XX XXXXXX XXXXXXX  XXXXXX       |             |
       2   XX  XXXXX XXX*XX XXXXXXX XXXXXXXX      |             | (size*2)+1
           XX  XXXXX XXXXXX XXX*XXX XXXXXXXX      |             |
           3    XXX   XXXX  XXXXXXX XXXX*XXX      |             |
                 X    XXXX  XXXXXXX XXXXXXXX      |             |
                 4    XXXX   XXXXX  XXXXXXXX      |             |
                       XX    XXXXX   XXXXXX       |             |
  WHERE                5     XXXXX   XXXXXX       |_____________|
                              XXX    XXXXXX
    X = agi pixels             6      XXXX           IN GENERAL
    * = coordinates given              XX
        for plot                       7
</programlisting>

   To implement this you will need to store bitmaps for each of these of
   these circles.

   <varlistentry/0xFA: Plot with pen/

   <emphasis/Function:/ Plots points with the pen defined with drawing action 0xF9.
   If the pen style is set to solid, then the arguments are just a list
   of coordinates to be plotted. If the pen style is set to splatter
   brush (texture), then the arguments are in groups of three with the
   first argument giving the texture number and the other two giving the
   coordinates. The texture number determines in what way the pixels will
   splatter within the defined shape. Bits 1-7 seem to give the actual
   texture number. Bit 0 does not do anything. This means that there are
   120 different pixel splatter bitmaps (values 0xF0 and above can not be
   used as they are treated as drawing actions). There is actually only
   32 bytes of texture data which means that most of the splatter bitmaps
   overlap.
   </variablelist>
</para>

<sect2><title>Texture data</title>
<para>
   All of the data needed for the 128 texture patterns is included in the
   following 32 bytes (256 bits):

<programlisting>
0x20, 0x94, 0x02, 0x24, 0x90, 0x82, 0xa4, 0xa2,
0x82, 0x09, 0x0a, 0x22, 0x12, 0x10, 0x42, 0x14,
0x91, 0x4a, 0x91, 0x11, 0x08, 0x12, 0x25, 0x10,
0x22, 0xa8, 0x14, 0x24, 0x00, 0x50, 0x24, 0x04
</programlisting>

   The only difference between each texture pattern is its starting
   position within this table. The following table gives the starting bit
   position in the above table for each texture pattern number given as
   the first argument of each pen plot:
<programlisting>
0x00, 0x18, 0x30, 0xc4, 0xdc, 0x65, 0xeb, 0x48,
0x60, 0xbd, 0x89, 0x04, 0x0a, 0xf4, 0x7d, 0x6d,
0x85, 0xb0, 0x8e, 0x95, 0x1f, 0x22, 0x0d, 0xdf,
0x2a, 0x78, 0xd5, 0x73, 0x1c, 0xb4, 0x40, 0xa1,
0xb9, 0x3c, 0xca, 0x58, 0x92, 0x34, 0xcc, 0xce,
0xd7, 0x42, 0x90, 0x0f, 0x8b, 0x7f, 0x32, 0xed,
0x5c, 0x9d, 0xc8, 0x99, 0xad, 0x4e, 0x56, 0xa6,
0xf7, 0x68, 0xb7, 0x25, 0x82, 0x37, 0x3a, 0x51,
0x69, 0x26, 0x38, 0x52, 0x9e, 0x9a, 0x4f, 0xa7,
0x43, 0x10, 0x80, 0xee, 0x3d, 0x59, 0x35, 0xcf,
0x79, 0x74, 0xb5, 0xa2, 0xb1, 0x96, 0x23, 0xe0,
0xbe, 0x05, 0xf5, 0x6e, 0x19, 0xc5, 0x66, 0x49,
0xf0, 0xd1, 0x54, 0xa9, 0x70, 0x4b, 0xa4, 0xe2,
0xe6, 0xe5, 0xab, 0xe4, 0xd2, 0xaa, 0x4c, 0xe3,
0x06, 0x6f, 0xc6, 0x4a, 0x75, 0xa3, 0x97, 0xe1
</programlisting>

   Important note: When drawing the brush, if the bit position in the
   texture data (first table above) reaches 255, it should loop round to
   0, instead of looping at 256 as you would normally expect. This may be
   because of a bug in the picture drawing code in the interpreter. If
   you loop at 256 then some of the patterns will not be correct.

   When a texture pattern is drawn in the shape of a circle, the texture
   pattern 'fills' the shape of the circle. This diagram will explain
   what I mean:
<programlisting>
   X.XX          X.
   X.X.          XX
   ....         X.X.
   .X.X         ....
   X...         .X.X
   ..X.          X.
   XXXX          ..

 Rectangle     Circle
</programlisting>

   The corner pixels of the circle which aren't part of the circle are
   totally ignored. The circle isn't just a cut out of the equivalent
   rectangle. A bit hard to explain. Look at the source of Showpic for
   more info.
</para>
</sect1>

<sect1 id="picimpl"><title>Implementation</title>
<para>
   Writing code to interpret the picture data in order to draw the
   picture on the screen is easier said than done. It turns out that you
   have to have a line drawing algorithm which exactly matches the one
   that Sierra uses. A pixel out of place can mean that a fill overflows
   or doesn't work at all.

   You will also have to write your own fill routine because not many of
   the standard fill routines can stop at a multicoloured boundary. You
   are also dealing with two screens both of which will probably be
   stored in memory somewhere rather than the screen.

   The picture screen has a starting state of being completely white. The
   priority screen has starting state of being completely red. It is
   important that you set all pixels in each screen to the relevant
   background colour else you won't get the right result.
</para>

<sect2><title>General guidelines</title>
<para>
   The screen mode used by the AGI games is the 320x200x16 standard EGA
   mode. However, all graphics is designed to be shown on a 160x200x16
   mode. This was apparently the resolution that the original PCjr
   interpreter used. They stuck with it when they started supporting EGA
   and thus have a situation where each AGI pixel has a width of two
   normal 320x200 pixels.
</para>

<sect2><title>Line drawing</title>
<para>
   This routine is relatively straight forward and I suggest that you
   look at it and try to understand it or you'll be having headaches
   trying to get you're routines acting like the Sierra ones. Basically
   it draws a line from (x1, y1) to (x2, y2) using a function called pset
   to draw a single pixel. The function <literal/round()/ is what makes it act like
   the Sierra. Essentially when it comes down to a 50:50 decision about
   where to put a pixel, the direction in which the line is being drawn
   is taken into account. I've only noticed one pixel out of place in all
   the screens I've tried Showpic on which makes me believe its probably
   not a fault in this algorithm, but somewhere else in the code.

   Note that <ulink name="http://homepages.ihug.com.au/~entropy/agi/"/Sarien/ (see section
   <xref linkend="otheragi" name="Other interpreters">)
   use a different line drawing algorithm written by Joshua Neal and <ulink name="mailto:entropy@ihug.com.au"/Stuart George/.
<programlisting>
int round(float aNumber, float dirn)
{
   if (dirn < 0)
      return ((aNumber - floor(aNumber) <= 0.501) ?
	floor(aNumber) : ceil(aNumber));
   return ((aNumber - floor(aNumber) < 0.499) ?
	floor(aNumber) : ceil(aNumber));
}

void drawline(word x1, word y1, word x2, word y2)
{
   int height, width;
   float x, y, addX, addY;

   height = (y2 - y1);
   width = (x2 - x1);
   addX = (height==0? height:(float)width/abs(height));
   addY = (width==0? width:(float)height/abs(width));

   if (abs(width) > abs(height)) {
      y = y1;
      addX = (width == 0? 0 : (width/abs(width)));
      for (x=x1; x!=x2; x+=addX) {
         pset(round(x, addX), round(y, addY));
         y+=addY;
      }
      pset(x2,y2);
   }
   else {
      x = x1;
      addY = (height == 0? 0 : (height/abs(height)));
      for (y=y1; y!=y2; y+=addY) {
         pset(round(x, addX), round(y, addY));
         x+=addX;
      }
      pset(x2,y2);
   }
}
</programlisting>

</para>

<sect2><title>Flood filling</title>
<para>
   I have discovered that using a queue in a flood fill routine works
   quite well. It is also the easiest method to understand as far as I'm
   concerned. I just thought about what needed to be done and this method
   took shape.

   Basically you start at a particular location. If its the desired
   background colour (white or red depending on the screen), then set
   that pixel. You then check the pixels immediately up, left, down, and
   right to see if they are of the desired background colour. If they
   are, store them in the queue. You then retrieve the first pixel
   position from the queue and repeat the above steps.
</para>
</sect1>

<sect1><title>Using higher resolution modes</title>
<para>
   I've often wondered if it would be possible to show PICTUREs in a
   higher resolution, for example, 640x400. Since the data is stored as
   vectors, it should be possible to multiply all the x components by
   four and all the y components by two and then draw the lines. This
   would give less blocky pictures. There would be a number of problems
   to overcome. Firstly, the fill action (or tool) may cause problems
   because pixels could be in the wrong places. There will also be a need
   to draw end pixels of a line with a width of four so that there are no
   holes for the flood fill to flow out of.
</para>
</sect1>

<sect1><title>Sierra's picture editor</title>
<para>
   The picture editor that Sierra used back in the vector picture days
   was much like a CAD program. I've seen a few photos of it in ``The
   Official Book of King's Quest''. It has a status bar at the top which
   gives the current tool being used (Line, Fill, etc), the current X and
   Y locations, and four others which I explain below.

   Status bar examples:
<programlisting>
Tool:Line V:8 P:A C:o X=249 Y=89 Pri:5
Tool:Fill V:B P:0 C:B X=96 Y=99 Pri:6
Tool:Line V:A P:o C:o X=199 Y=55 Pri:2
</programlisting>

   <literal/o/ = off (or disabled)

   <literal/Pri/ looks like it could be giving the current priority band that the
   cursor location is in. The above status lines are for the SCI Picture
   Editor. I ran these values past SQ3 and the values given for <literal/Pri/ are
   indeed the values of the priority band at the locations given.

   I think that <literal/V/, <literal/P/, and <literal/C/ refer to the colours being used
   on the three different screens (the SCI games have a separate screen for
   the control lines rather than having both the priority bands and control
   lines on the same screen. This is why there were three screens and not
   the two that we are used to in AGI games). This would mean that
   <literal/V/ = Visual, <literal/P/ = Priority and <literal/C/ = Control.

   In an AGI Picture Editor, there would only be the Visual screen and
   the Priority screen. The picture editor would obviously be able to
   switch between the two screens. I've also noticed that the early
   vector based SCI picture editor supports a feature which removes solid
   colours (Fills) with a single keystroke and I presume another
   keystroke puts them back. When the fills have been removed, they are
   represented as a tiny cross. Apparently removing the solid colours
   makes it easier to add small details like flowers.
</para>
</sect1>

<sect1 id="piccode"><title>Sample code</title>
<para>
   The following examples are available in the <ulink name="http://agi.helllabs.org/agispecs/"/distribution package/:

   <simplelist>
    <member><literal><ulink name="examples/picture/picv3-v2.c"/picv3-v2.c/</literal>
       by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: converts version 3 pictures to version 2 pictures
    <member><literal><ulink name="examples/picture/showpic.c"/showpic.c/</literal>
       by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: displays pictures
   </simplelist>
</para>
</sect1>

</chapter>


<chapter id="view"><title>VIEW resources</title>
<para>
<emphasis>
Written by <ulink name="mailto:ptrkelly@ozemail.com.au" name="Peter Kelly">, with modifications by <ulink name="mailto:claudio@helllabs.org"/Claudio Matsuoka/
(Last updated: 22 May 1999).
</emphasis>
</para>

<sect1><title>Introduction</title>
<para>
   VIEW resources contain some of the graphics for the game. Unlike the
   picture resources which are full-screen background images, view
   resources are smaller <emphasis/sprites/ used in the game, such as animations
   and objects. They are also stored as bitmaps, whereas pictures are
   stored in vector format.

   Each view resource consists of one or more <emphasis/loops/. Each loop in the
   resource consists of one or more <emphasis/cels/ (frames). Thus several
   animations can be stored in one view, or a view can just be used for a
   single image. The maximum number of loops supported by the interpreter
   is 255 (0-254) and the maximum number of cels in each is 255 (0-254).

   Note: Except when noted otherwise, 16 bit data is stored in little endian
   format (i.e. the value has the least significant byte stored first, and
   the most significant byte stored second). Most word values in AGI are
   stored like this, but not all.
</para>

<sect1><title>VIEW resource format</title>

<sect2><title>View header (7+ bytes)</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Unknown (always seems to be either 1 or 2)
  1   Unknown (always seems to be 1)
  2   Number of loops
 3-4  Position of description (more on this later)
      Both bytes are 0 if there is no description
 5-6  Position of first loop
 7-8  Position of second loop (if any)
 9-10 Position of third loop (if any)
 ...  ...
----- -----------------------------------------------------------
   </programlisting>

   Note: Two of these loop references CAN point to the same place. This
   is done when you want to use mirroring (more on this later).
</para>

<sect2><title>Loop header (3+ bytes)</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Number of cels in this loop
 1-2  Position of first cel, relative to start of loop
 3-4  Position of second cel (if any), relative to start of loop
 5-6  Position of third cel (if any), relative to start of loop
----- -----------------------------------------------------------
   </programlisting>
</para>

<sect2><title>Cel header (3 bytes)</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Width of cel (remember that AGI pixels are 2 normal EGA
      pixels wide so a cel of width 12 is actually 24 pixels
      wide on screen)
  1   Height of cel
  2   Transparency and cel mirroring
----- -----------------------------------------------------------
   </programlisting>

   The first four bits of this byte tell the interpreter how to handle
   the mirroring of this cel (explained later).

   The last four bits represent the transparent color. When the cel is
   drawn on the screen, any pixels of this color will show through to the
   background.

   All cels have a transparent color, so if you want an opaque cel then
   you must set the transparent color to one that is not used in the cel.
</para>

<sect2><title>Cel data</title>
<para>
   The actual image data for each cel is stored using RLE (run length
   encoding) compression. This means that instead of having one byte for
   each single pixel (or 1/2 byte as you would use for 16 colors), each
   byte specifies how many pixels there are to be in a row and what
   colour they are. I will refer to these groups of pixels as ``chunks''.

   This method of compression is not very efficient if there is a lot of
   single pixels in the image (e.g. a view showing static on a TV
   screen), but in most cases it does save a fair amount of space.

   Each line (not to be confused with a chunk) in the cel consists of
   several bytes of pixel data, then a 0 to end the line. Each byte of
   pixel data represents one chunk. The first four bits determine the
   colour, and the last four bits determine the number of pixels in the
   chunk.

   Example: <literal/AX BY CZ 00/

   This line will have:
   <simplelist>
    <member>X pixels of colour A (<literal/AX/)
    <member>Y pixels of colour B (<literal/BY/)
    <member>Z pixels of colour C (<literal/CZ/)
    <member>(then that will be the end of the line) (<literal/00/)
   </simplelist>

   If the color of the last chunk on the line is the transparent color,
   there is no need to store this. For example, if C was the transparent
   color in the above example, you could just write <literal/AX BY 00/. This also
   saves some space.
</para>

<sect2><title>Mirroring</title>
<para>
   Mirroring is when you have one loop where all the cels are a mirror
   image of the corresponding cels in another loop. Although you could do
   this manually by drawing one loop and then copying and pasting all the
   cels to another loop and flipping them horizontally, AGI views provide
   the ability to have this done automatically -- you can draw one loop,
   and have another loop which is set as a mirror of this loop. Thus,
   when you change one loop you change the other. This is useful if you
   have an animation of a character walking left and right -- you just
   draw the right-walking animation and have another loop a mirror of
   this which will have the left-walking animation. Another advantage of
   cel mirroring is to save space -- it doesn't make much difference these
   days, but back when AGI was written the games were designed to run on
   256K systems which meant that memory had to be used as efficiently as
   possible.
</para>
<para>
   Mirroring is done by having both loops share the same cel data -- you
   saw above that you can have two loop references pointing to the same
   place. The first four bits of the 3rd byte in the header of each cel
   tell the interpreter what is mirrored:

   <programlisting>
 Bit  Meaning
----- -----------------------------------------------------------
  0   Specify whether or not this cel is mirrored.
 1-3  Specify the number of the loop (from 0-7) which is NOT
      mirrored
----- -----------------------------------------------------------
   </programlisting>

   When the interpreter goes to display a loop, it looks at the bit 0 and
   sees if it is mirrored or not. If it is, then it checks the loop
   number -- if this is NOT the same as the current loop, then it flips
   the cel before displaying it.
</para>

<para>
   If you have a cel that is mirrored, you need to ensure that the number
   of bytes the cel takes up in the resource is greater than or equal to
   the number of bytes that the flipped version of the cel would take up.
   The reason for this is that the interpreter loads the view resource
   into memory and works with that for displaying cels, rather than
   decoding it and storing it in memory as a non-compressed bitmap. I
   assume that it doesn't even bother ``decoding'' it as such -- it probably
   just draws the chunks of color on the screen as they are. When it has
   to display the flipped version of a cel, instead of storing the
   flipped cel somewhere else in memory, it flips the version that is
   there. So in memory you have the view resource that was read from the
   file, except that some of the cels have been changed. This is why
   there is mirroring information stored in each cel -- the interpreter
   has to know what cels have been changed. When it flips a cel, it
   changes the loop number in the 3rd byte of the cel header to the
   number of the loop it is currently displaying the cel for. So when it
   looks at this number the next time for a different loop, it will see
   that the cel is not the right way round for that loop and mirror it
   again.
</para>

<para>
   This process seems very inefficient to me. I don't know why it doesn't
   just draw the chunks of color on the screen back to front. But since
   it does it this way we have to make sure that there is enough room for
   the flipped cel.
</para>

<para>
   It seems that not all versions of the interpreter require this,
   however -- I was working with version 2.917 when I was testing this
   out, but I noticed that versoin 2.440 did not require this. I will
   attempt to try this with all different interpreters and provide a list
   of which ones use this in a future version of this document. But it is
   best to put these bytes in just in case, as the views will still work
   regardless.
</para>

<sect2><title>Description</title>
<para>
   All the views in the game that are used as close-ups of inventory
   members have a description. When a player ``examines'' these (in some
   games you can select ``see object'' from the menu), they will see the
   first cel of the first loop of this view and the description of the
   object they are examining. This is brought up using the <literal/show.obj/
   command.
</para>

<para>
   The description is stored in plain text, and terminated by a null
   character. Lines are separated by an 0x0A.
</para>

<sect1><title>VIEW table</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 31 August 1997).
</emphasis>

   Firstly we should note that there is a difference between a VIEW and a
   VIEW object. A VIEW is a collection of animated sequences that are
   stored in a VOL file. When a view is loaded into memory, it is then
   connected to one or more VIEW table entries (see below) that store
   information on what the interpreter calls objects (don't confuse this
   with inventory members). An object is an animated sprite that is
   currently being controlled by the interpreter. With each
   interpretation cycle, the state of each object in the VIEW table is
   updated and, if required, updated on the screen. It is therefore
   possible to have five or more hungry crocodiles swimming in a moat
   each which have there own VIEW table entries, all of which point to
   the same VIEW data.

   View objects appear to have the following properties:

   <simplelist>
    <member>x position
    <member>y position
    <member>current view
    <member>current loop
    <member>current cel
    <member>priority
    <member>cycle time (1/n gives the fraction of the maximum speed)
    <member>step time (1/n gives the fraction of the maximum speed)
    <member>x size (in pixels)
    <member>y size (in pixels)
    <member>step size
    <member>direction
    <member>number of loops
    <member>number of cels
   </simplelist>

   There are probably other properties that aren't listed here which they
   also possess. In an object oriented environment such as SCI, these
   properties are stored as instance variables (or selectors) as part of
   the object. Since AGI isn't object oriented, we would expect to find
   some sort of VIEW table stored in memory which holds theses properties
   within it. In SQ2 this VIEW table consisted of 43 byte entries. Most
   commands that deal with VIEW objects will make adjustments to the data
   in the entry for the relevant object.
</para>

<sect2><title>View table entry</title>
<para>
   <programlisting>
Byte  Meaning
----- -----------------------------------------------------------
00-01 step.time (stored twice)
  02  ??
03-04 x position
05-06 y position
  07  current view
08-09 pointer to start of view data.
  0A  current loop
  0B  number of loops
0C-0D pointer to start of loop data
  0E  current cel
  0F  number of cels
10-11 pointer to start of cel data
12-13 pointer to start of cel data (same as above)
14-15 ??
16-17 copy of x position
18-19 copy of y position
1A-1B x size
1C-1D y size
  1E  step size
1F-20 cycle time (stored twice)
  21  direction (heading)
      0 = stationary, 1 = north, 2 = north/east, 3 = east,
      4 = south/east, 5 = south, 6 = south/west, 7 = west,
      8 = north/west
  22  0 = normal.motion, 1 = wander, 2 = follow.ego, 3 = move.obj
  23  0 = normal.cycle, 1 = end.of.loop, 2 = reverse.loop,
      3 = reverse.cycle
  24  priority
25-26 View flags (see below)
----- -----------------------------------------------------------
   </programlisting>

View flags:

   <programlisting>
 Bit  Meaning
----- -----------------------------------------------------------
   0  ??
   1  0 = observe blocks, 1 = ignore blocks
   2  0 = priority released, 1 = fixed priority
   3  0 = observe horizon, 1 = ignore horizon
   4  ??
   5  0 = stop cycling, 1 = cycling.
   6  ??
   7  ??
   8  1 = view on water
   9  0 = observe objects, 1 = ignore objects
  10  ??
  11  1 = view on land
  12  ??
  13  0 = loop released, 1 = loop fixed
  14  ??
  15  ??
  27  ?? (storage for some view related command parameters)
  28  ?? (storage for some view related command parameters)
  29  ?? (storage for some view related command parameters)
  2A  ?? (storage for some view related command parameters)
----- -----------------------------------------------------------
   </programlisting>

   Note: The above format structure is simply the way in which Sierra's
   AGI interpreter stores information about VIEW objects. In attempting
   to write an AGI interpreter, you would not have to restrict yourself
   to this format, just as long as you store this information in some
   manner that the interpreter can have access to.
</para>
</sect1>

<sect1><title>VIEW test commands</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 31 August 1997).
</emphasis>

   There are four LOGIC test commands that are to do with VIEWS. These are:
   <programlisting>
obj.in.box()
posn()
right.posn()
centre.posn()
   </programlisting>

   All of these commands are for testing whether a VIEW object is within
   a given rectangle on the screen. All of them take the same parameters
   and apart from a slight change in each case, they do exactly the same
   thing and even share about 95% of their code. The general form is the
   following:
   <programlisting>
command(VIEW object num, left, top, right, bottom)
   </programlisting>

   A VIEW has a position stored in its VIEW table entry that says where
   abouts on the screen the view object is at the present time. The
   problem with this position is saying which pixel is the position pixel
   for an object that takes up usually over a hundred pixels. Okay, you
   might say that most views are actors or props that sit on the ground
   and therefore the bottom row of pixels will give you a y position.
   This is a good argument, but now you need to say which of these pixels
   in the bottom row is the actual position. Sierra must have faced this
   problem or they wouldn't have provided four commands for achieving
   essentially the same thing.

   By default the position hot spot in a VIEW is the bottom left pixel.
   <programlisting>
.........
.........
.........
.........          X = position hot spot.
.........
.........
X........
   </programlisting>

   This is the location that gets stored in the VIEW object table. The
   difference between the test commands given above is how they adjust
   the x position before testing it against the rectangle border lines.
   <literal/posn/ Leaves the x position as it is (left side). <literal/right.posn/ adds
   (xsize-1) to the x position giving the right side. <literal/center.posn/ adds
   (xsize/2) to the x position giving the centre. <literal/obj.in.box/ tests both
   the left and right sides which essentially tests whether the whole
   bottom row of pixels is in the ``box''.

   The test is TRUE if
   <programlisting>
(X1 >= left) && (y >= top) && (X2 <= right) && (y <= bottom).
   </programlisting>

</para>
</sect1>

<sect1 id="viewcode"><title>Sample code</title>
<para>
   The following examples are available in the <ulink name="http://agi.helllabs.org/agispecs/"/distribution package/:

   <simplelist>
    <member><literal><ulink name="examples/view/viewview.pas"/viewview.pas/</literal>
      by <ulink name="mailto:ptrkelly@ozemail.com.au"/Peter Kelly/: unit from AGIhack that displays VIEWs
   </simplelist>
</chapter>


<chapter id="res_sound"><title>SOUND resources</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz" name="Lance Ewing">, with additions/modifications by <ulink name="mailto:claudio@helllabs.org" name="Claudio Matsuoka">, <ulink name="mailto:paul123@freenet.tlh.fl.us"/Paul Lunga/
and <ulink name="mailto:irsman@iag.net"/Ian Schmidt/
(Last updated: 22 May 1999).
</emphasis>
</para>

<sect1><title>Introduction</title>
<para>
   Most people who think of AGI games remember that they played their
   music and sounds over the PC speaker. What they may not know is that
   all sounds in the MS-DOS, Tandy and Macintosh versions are composed of
   four parts, one which is the melody, two which are accompaniment, and
   the final one being noise. The IBM PC can only play one note at a time
   so all AGI games for the PC play the melody by itself. The Apple IIgs
   version has much more sophisticated sound: 16 channel wavetable based
   MIDI songs for the soundtracks, and digitally sampled PCM sound effects.

   According to Donald B. Trivette, author of ``The Official Book of King's
   Quest'', a year before the IBM PCjr was announced IBM asked Sierra to
   create a game that would show off the new computers color graphics
   capabilities. IBM supplied the company with a prototype Junior, and
   Roberta set to work designing a new type of adventure game. The game
   produced was called King's Quest. This is important because the IBM
   PCjr had a different method of sound generation than the IBM
   compatibles of today. The sound data was stored to make it easy to
   send to the Juniors sound generators. This format appears to have
   remained right through the AGI games up until 1989--90 when SCI took
   over even though the PCjr had long since been surpassed by the 286,
   and 386.
</para>

<sect1><title>Sound in the IBM PCjr</title>
<para>
   The best known source of sound in the Junior is the TI SN76496A sound
   generator chip. This source has four separate sound voices. Three of
   these are tone generators and the fourth is a noise source. All four
   voices have an independent volume control, providing an evenly
   graduated set of 15 volume levels, plus a zero volume (off). Each of
   the three pure voices has an independently selected frequency. The
   noise voice has three preselected frequencies and a fourth option,
   which borrows the frequency of the third pure voice. The data stored
   in the AGI games is designed to be sent to these four voices.
</para>

<sect2><title>The tone generation</title>
<para>
   A tone is produced on a voice by passing the sound chip a 3-bit
   register address and then a 10-bit frequency divisor. The register
   address specifies which voice the tone will be produced on. This is
   done through port 192 on the IBM PCjr by sending it 2 bytes in the
   following format:
<programlisting>
First Byte
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Identifies first byte (command byte)
.  R0 R1 R2 .  .  .  .      Register number in T1 chip (0, 2, 4).
.  .  .  .  F6 F7 F8 F9     4 of 10-bits in frequency count.

Second Byte
7  6  5  4  3  2  1  0

0  .  .  .  .  .  .  .      Identifies second byte (completing byte)
.  X  .  .  .  .  .  .      Unused, ignored.
.  .  F0 F1 F2 F3 F4 F5     6 of 10-bits in frequency count.

Register Addresses:
R0      R1      R2

 0       0       0          Holds voice 1 frequency number.
 0       1       0          Holds voice 2 frequency number.
 1       0       0          Holds voice 3 frequency number.
</programlisting>

   The actual frequency produced is the 10-bit frequency divisor given by
   F0 to F9 divided into 1/32 of the system clock frequency (3.579 MHz)
   which turns out to be 111,860 Hz. Keeping all this in mind, the
   following is the formula for calculating the frequency:
<programlisting>
f = 111860 / (((Byte2 & 0x3F) << 4) + (Byte1 & 0x0F))
</programlisting>

   Note: The order of the bytes are reversed for AGI sound data.
</para>

<sect2><title>Attenuation</title>
<para>
   Each voice in the T1 sound chip has an independent sound-level
   control, which is calculated in terms of decibels of attenuation, or
   softening. There are four bits uses to control the volume. These bits,
   labeled A0 through A3, can be set independently or added together to
   produce sixteen volume levels as shown below.
<programlisting>
A0 A1 A2 A3        Value        Attenuation (decibels)

 .  .  .  1          1                    2
 .  .  1  .          2                    4
 .  1  .  .          4                    8
 1  .  .  .          8                   16
 1  1  1  1                           Volume off
</programlisting>

   When a bit is set on, the sound is attenuated (reduced) by a specific
   amount: either 2, 4, 8, or 16 decibels. When all four bits are set on,
   the sound is turned completely off. When all four bits are off, the
   sound is at
   its fullest volume.

   The attenuation is set by sending a byte of the following format to
   the T1 sound chip:
<programlisting>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Identifies first byte (command byte)
.  R0 R1 R2 .  .  .  .      Register number in T1 chip (1, 3, 5, or 7).
.  .  .  .  A0 A1 A2 A3     4 attenuation bits

   Register Addresses:
R0      R1      R2

 0       0       1          Holds voice 1 attenuation.
 0       1       1          Holds voice 2 attenuation.
 1       0       1          Holds voice 3 attenuation.
 1       1       1          Holds noise voice attenuation.
</programlisting>
</para>

<sect2><title>The noise generator</title>
<para>
   There are two modes for the noise operation, besides the four
   frequency selections. One, called periodic noise, produces a steady
   sound; the other, called white noise, produces a hissing sound. These
   two modes are controlled by a bit known as the FB bit. When FB is 0,
   the periodic noise is generated; when FB is 1, the white noise is
   produced.

   Two bits, known as NF0 and NF1, control the frequency at which the
   noise generator works. Three of the four possible combinations of NF0
   and NF1 set an independent noise frequency based on the timer. The
   fourth combination borrows the frequency from the third of the three
   pure voices made by the tone generators.
<programlisting>
 NF0  NF1       Noise Frequency

  0    0         1,193,180 / 512 = 2330
  0    1         1,193,180 / 1024 = 1165
  1    0         1,193,180 / 2048 = 583
</programlisting>

   The noise frequency is set by sending a byte of the following format
   to the T1 sound chip:
<programlisting>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Identifies first byte (command byte)
.  1  1  0  .  .  .  .      Register number in T1 chip (6)
.  .  .  .  X  .  .  .      Unused, ignored; can be set to 0 or 1
.  .  .  .  .  FB .  .      1 for white noise, 0 for periodic
.  .  .  .  .  . NF0 NF1    2 noise frequency control bits
</programlisting>
</para>

<sect1><title>Sound in the Apple IIgs</title>
<para>
   The Apple IIgs uses the Ensoniq 5503 DOC (Digital Oscillator Chip)
   to produce its sound. The 5503 has 32 oscillators and is capable of
   playing wavetable based music using digital sound samples stored in
   its own dedicated RAM (much like the Gravis Ultrasound card for the
   IBM PC). Thanks to the 5503, AGI games for the IIgs have a much richer
   sound than the PC, Mac or Tandy versions.

   Follows an excerpt of the Apple II Sound and Music FAQ, version 1.7.
</para>

<sect2><title>Technical Specs for the GS Ensoniq chip</title>
<para>
<emphasis>
Written by <ulink name="mailto:irsman@iag.net"/Ian Schmidt/ (Last updated: 3 November 1997).
</emphasis>

   The 5503 Ensoniq Digital Oscillator Chip (DOC) contains 32 fundamental
   sound-generator units, known as ``oscillators''. Each oscillator is
   capable of either making an independent tone by itself, or of being
   paired up cooperatively with it's neighbor in a pairing known as a
   ``generator''. The generator arrangement is used by most programs, for
   it allows more flexibility and a thicker, lusher sound.

   The DOC plays 8-bit waveforms, with the centerline at 0x80 (128
   decimal). This format is known as ``8-bit unsigned''. 0x00 (0 decimal
   too) is reserved for `stop'. If a sample value of 0 is encountered by
   a DOC oscillator, the oscillator will immediately halt and not produce
   any more sound. The DOC additionally has an 8-bit volume register for
   each oscillator, with a linear slope. The dynamic range of the DOC
   (the `space' between the softest and loudest sounds it can produce) is
   approximately 42 dB, or about on par with an average cassette tape.

   Each oscillator has it's own 16 bit frequency register, ranging from 0
   to 65535. In a normal DOC configuration, each step of the frequency
   register increases the play rate by 51 Hz, and computing the maximum
   theoretical play rate is left as an exercise for the student.

   When oscillators are paired to create generators, there are 4 possible
   modes:
   <simplelist>
    <member>Free-run: the oscillator simply plays the waveform and stops. No
       interaction with it's 'twin' occurs.
    <member>Swap: Only one oscillator of the pair is active at a time. When
       one stops, the other immediately starts.
    <member>Loop: The oscillator simply plays the waveform and if it hits the
       end without encounter.cgiing a zero, it starts over at the
       beginning.
    <member>Sync/AM: This actually has 2 possible effects: either one
       oscillator of the pair modulates the volume of the other with the
       waveform it's playing, or both oscillators sync up perfectly,
       causing a louder and more 'solid' sound.
   </simplelist>

   Oscillators play waves stored in up to 128k of DRAM. This DRAM is not
   directly visible from the GS's 65816 CPU, but can be accessed (slowly)
   via services supplied by the Sound GLU chip. Note that no widely
   manufactured IIgs motherboard supported the full 128k of DRAM that the
   DOC can see. Conversely, no synthesizer Ensoniq made using the DOC had
   anything less than the full 128k.

   The output of an oscillator can be directed to any one of 16 possible
   channels. Apple only makes 8 channels avalible via the 3 bits on the
   sound expansion connector, and all current stereo cards limit this to
   1 bit, or two channels. However, the ``Bernie II The Rescue'' IIgs
   emulator for the Power Mac expands this support to 4 discrete output
   channels, two of which are encoded to the rear channel for Dolby
   Pro-Logic compatible output. No IIgs software that I'm aware of
   supports more than 2 channels however.
</para>

<sect1><title>Sound in other platforms</title>
<para>
   According to <ulink name="mailto:paul123@freenet.tlh.fl.us"/Paul Lunga/, sound in the Macintosh and Tandy versions of
   the AGI games are pretty much the same as the PCjr version (three
   sound channels plus noise). AIFF files of AGI music in these platforms
   are available at <ulink name="http://agi.helllabs.org/sound"
   name="http://agi.helllabs.org/sound">.
</para>

<sect1><title>SOUND resource format (PCjr version)</title>
<para>
   We now know enough about the PCjr's T1 sound chip to discuss the AGI
   sound format. The sound is stored as four separate units of data, one
   for each voice. Each sound file stored in the VOL files has an 8-bit
   header which contains offsets into file. The format is as follows:
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Offset of first voice data
 2-3  Offset of second voice data
 4-5  Offset of third voice data
 6-7  Offset of noise voice data
----- -----------------------------------------------------------
</programlisting>

   The data starting at each voice offset is stored as 5-byte notes which
   give the frequency and duration of a note played on that voice. The 5
   bytes have the following meanings:

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Duration (16-bit word)
 2-3  Frequency divisor of the format described in the PCjr
      section above except the two bytes are around the other way
  4   Attenuation of the note in the format described above in
      the PCjr section
----- -----------------------------------------------------------
</programlisting>

   Note that the last three bytes were around the other way in version 1
   of the AGI interpreter. The above order is opposite from the order
   that would be output to the T1 sound chip.

   Each voice's data section in the SOUND resource file is usually
   terminated by two consecutive 0xFF codes. Another way of checking for
   the end is to see if it has reached the start of the next voice
   section, or in the case of the noise voise, the end of the SOUND data.
</para>

<sect2><title>Summary</title>
<para>
   The header consists of four two-byte offsets, one for each voice. The
   format is little-endian. Each offset points to the note data for the
   relevant voice. The note data for a voice consists entirely of five-byte
   note entries of the following format:

   <simplelist>
    <member>First and second byte: Note duration
    <member>Third byte
      <simplelist>
       <member>In the case of a tone voice,
<verb>
7  6  5  4  3  2  1  0

0  .  .  .  .  .  .  .      Always 0.
.  X  .  .  .  .  .  .      Unused, ignored.
.  .  F0 F1 F2 F3 F4 F5     6 of 10-bits in frequency count.
</verb>
       <member>In the case of the noise voice, this byte is equal to zero.
      </simplelist>
    <member>Fourth byte
      <simplelist>
       <member>In the case of a tone voice,
<verb>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Always 1.
.  R0 R1 R2 .  .  .  .      Register number in T1 chip (0, 2, 4).
.  .  .  .  F6 F7 F8 F9     4 of 10 bits in frequency count.

F = frequency = 111860 / (((Byte3 & 0x3f) << 4) + (Byte4 & 0x0f))
R = register address
</verb>
       <member>In the case of the noise voice,
<verb>
7  6  5  4  3  2  1  0

1  .  .  .  .  .  .  .      Always 1.
.  1  1  0  .  .  .  .      Register number in T1 chip (6)
.  .  .  .  X  .  .  .      Unused, ignored; can be set to 0 or 1
.  .  .  .  .  FB .  .      1 for white noise, 0 for periodic
.  .  .  .  .  . NF0 NF1    2 noise frequency control bits

NF0  NF1       Noise Frequency

 0    0         1,193,180 / 512 = 2330
 0    1         1,193,180 / 1024 = 1165
 1    0         1,193,180 / 2048 = 583
</verb>
      </simplelist>
    <member>Fifth byte
<verb>
   7  6  5  4  3  2  1  0

   1  .  .  .  .  .  .  .      Identifies first byte (command byte)
   .  R0 R1 R2 .  .  .  .      Register number in T1 chip (1, 3, 5, or 7).
   .  .  .  .  A0 A1 A2 A3     4 attenuation bits


   A0 A1 A2 A3        Value        Attenuation (decibels)

    .  .  .  1          1                    2
    .  .  1  .          2                    4
    .  1  .  .          4                    8
    1  .  .  .          8                   16
    1  1  1  1                           Volume off


 Register Addresses:

   R0 R1 R2        Parameter

    0  0  0        Voice 1 frequency control number (10 bits)
    0  0  1        Voice 1 attenuation (4 bits)
    0  1  0        Voice 2 frequency control number (10 bits)
    0  1  1        Voice 2 attenuation (4 bits)
    1  0  0        Voice 3 frequency control number (10 bits)
    1  0  1        Voice 3 attenuation (4 bits)
    1  1  0        Noise voice control (4 bits; 3 used)
    1  1  1        Noise voice attenuation (4 bits)
</verb>
   </simplelist>
   The note data for one voice is terminated by two consecutive 0xFF
   values.
</para>

<sect2><title>AGI v1.12 sound format</title>
<para>
   The sound format used in version 1.12 of the AGI interpreter was quite
   different from the format described above for AGIv2 and AGIv3. It
   still uses the PCjr format for the note data but it does not store the
   duration as a separate field. The best way to describe it is by an
   example:
<programlisting>
90 80 16 B0 A0 15 D0 C0 0E FF E4 00 80 17 A0 16 C0 11 00
80 16 B1 A0 14 C0 12 00 80 16 B2 A0 16 C0 13 00 ...
</programlisting>

   The first thing to point out is that the PCjr note data is in the
   opposite order to AGIv2. Secondly, all four parts are included
   together rather than in separate sections. Taking the above example,
   lets look at the first note and show the equivalent AGIv2 notation.
<programlisting>
90 80 16 --> 03 00 16 80 90
</programlisting>

   Now, the duration isn't immediately obvious, but we will come to that
   in a short while. The followint three bytes give the first note for
   the second part, the third part, and the noise part (at least as far
   as this example is concerned).
<programlisting>
B0 A0 15 --> 03 00 15 A0 B0
D0 C0 0E --> 03 00 0E C0 D0
FF E4 00 --> 33 00 00 E4 FF
</programlisting>

   The data that follows after these initial four starting notes is
   basically any changes in the note value which each 3 duration step.
   For example,
<programlisting>
80 17 --> 03 00 17 80 90
</programlisting>

   Note that 0x90 doesn't need to be stored because that byte has
   retained its value. Every 0x00 byte that is encountered is the end of
   one set of note changes. Each set of note changes is the equivalent of
   a duration of 3 in the AGIv2 format. Continuing with our example,
<programlisting>
A0 16 --> 03 00 16 A0 B0
C0 11 --> 03 00 11 C0 D0
</programlisting>

   The example now encounters a 0x00 byte which means that the noise
   voice isn't changed at this point. In fact, from the AGIv2 equivalent
   note above, you will see that the noise note will not change until 49
   (or 0x33) sets of note changes have been processed.
<programlisting>
80 16    --> 03 00 16 80 90
B1 A0 14 --> 03 00 14 A0 B1
C0 12    --> 03 00 12 C0 D0
</programlisting>

   How exactly the AGIv1.12 interpreter knows which voice is having its
   notes changed, and which bytes of the note are being changed, is not
   yet certain. On some occassion a sets of changes will contain only one
   byte which corresponds to one of the bytes which makes up one of the
   voices note value, but how it knows which one is a mystery to me.

   On other occassions, there could be a whole chain of 0x00 bytes which
   means that during that whole time, none of the voices are changing
   their notes value.
</para>

<sect1><title>SOUND resource format (IIgs version)</title>
<para>
   There are two types of SOUND resources in the IIgs AGI games: PCM
   samples (used for sound effects) and MIDI sequences. The first
   two bytes can tell what type of resource we have:

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Resource type (01 00 = sample, 02 00 = MIDI)
----- -----------------------------------------------------------
</programlisting>
</para>

<sect2><title>Sampled sounds</title>
<para>
   Sampled sounds (resource type 01) are stored in 8 bit, unsigned format
   after a 54 byte header described below.

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Resource type (01 00)
 2-7  ???
 8-9  Sample size
10-53 ???
----- -----------------------------------------------------------
</programlisting>
</para>

<sect2><title>MIDI sequences</title>
<para>
<emphasis>
Written by <ulink name="mailto:irsman@iag.net"/Ian Schmidt/ (Last updated: 3 April 1999).
</emphasis>

   MIDI songs have a stram of MIDI data following the resource type.
   The following dump shows the MIDI data in the King's Quest I opening
   theme resource:

<programlisting>
02 00		Type: MIDI sequence

00 c0 28	Set patch 0x28 in channel 0
00 c1 28	Set patch 0x28 in channel 1
00 c2 29	Set patch 0x29 in channel 2
00 c3 16	Set patch 0x16 in channel 3
00 c4 01	Set patch 0x01 in channel 4

00 b0 07 7f	Set channel volumes (MIDI controller 07)
00 b2 07 7f	...
00 b4 07 6a
01 b3 07 6e
18 b1 07 7b

4d 90 43 38	Play note 0x43 in channel 0 with velocity 0x38
0a 80 43 40	Resease note 0x43 in channel 0 with velocity 0x40
0c 90 43 45	...
0b 80 43 40
01 91 3c 35
00 92 30 40
00 91 43 39
00 40 37
02 90 48 40
</programlisting>

   The patch number is mapped to a sound sample stored in the
   <filename/sierrastandard/ file in a more complicated way. The IIgs
   interpreter uses the patch number as a lookup into a list of
   instrument definitions, which are stored in a format used by an
   API called the ``Note Synthesizer''.

   For example, here's instrument 0 from Police Quest, as dumped out of the
   <literal/pq.sys16/ file:

<programlisting>
INST #000:
Envelope:
[seg 0]: BP 7f  Inc f00
[seg 1]: BP 78  Inc a
[seg 2]: BP 78  Inc 0
[seg 3]: BP 0  Inc 514
[seg 4]: BP 0  Inc 0
[seg 5]: BP 0  Inc 0
[seg 6]: BP 0  Inc 0
[seg 7]: BP 0  Inc 0
rel seg: 3, pri inc: 32, bend range: 2, vib dep: 75, vib spd: 50
A wave count: 1, B wave count: 1
[A 1 of 1] top: 7f, wave address: 50, size: 12 mode: 00, relPitch: 00fe
[B 1 of 1] top: 7f, wave address: 50, size: 12 mode: 00, relPitch: 00fe
</programlisting>

   Now, that's a bit scary looking, but all the important information is
   there :-)

   Basically the Note Synth API groups 2 5503 voices together to make 1 voice,
   and this has all the data you need to control it. Let me rephrase some
   info from my dusty old ``IIgs Toolbox Reference, Volume 3''.

   The envelope is first: for each segment there's a breakpoint (target
   volume, which is on a logarithmic scale in 6 decibel units) and an
   Increment (a 8.8 fixed point number telling how much to adjust the volume
   on each tick).  For instance, if the first segment had BP = 1 and Inc =
   0x0001, it would take 256 ticks for the volume to reach 1.  The <emphasis/rel seg/
   tells which segment of the envelope is the final one. Ticks in the Note
   Synth default to 100 Hz, although the AGI interpreter may well have used a
   different value -- I'll have to check.

   <emphasis/Bend range/ is the number of semitones the instrument will be bent by if
   a pitch wheel message at maximum deflection in either direction is
   encountered.  For this instrument, that's 3 semitones in each direction.

   <emphasis/Vib Dep/ and <emphasis/Vib Spd/ aren't being dumped properly yet (minor
   bug in my utility), but they specify the depth and speed of an optional
   vibrato effect.

   <emphasis/A wave count/ and <emphasis/B wave count/ tell how many wavelists there are
   for each 5503 voice. If there's more than 1 wavelist you compare the note
   being started with the <emphasis/top/ value in each wavelist and if <emphasis/top/ is
   greater than or equal to the note you're starting you use that wavelist.
   In this case there's only 1 possible wavelist so <emphasis/top/ is naturally 0x7f,
   the highest possible numbered MIDI note.

   Once you've picked a wavelist using the note, the other information is all
   there.  Wave address is the offset in 256-byte pages into the 64k
   <literal/sierrastandard/ image (ie, (Wave Address)&lt;&lt;8 gives a true offset).
   In this case the wave starts 0x5000 bytes into the image. For size you
   mask off all but the lowest 3 bits and it gives you the basic wave size as
   follows:

   Case the wave starts 0x5000 bytes into the image: For size you mask off
   all but the lowest 3 bits and it gives you the basic wave size as follows:

   <simplelist>
    <member>%000 = 1 page (256 bytes)
    <member>%001 = 2 pages (512 bytes)
    <member>%010 = 4 pages (1k bytes)
    <member>%011 = 8 pages (2k bytes)
    <member>%100 = 16 pages (4k bytes)
    <member>%101 = 32 pages (8k bytes)
    <member>%110 = 64 pages (16k bytes)
    <member>%111 = 128 pages (32k bytes)
   </simplelist>

   Note that if a zero is encountered in the wave before that size you still
   stop at the zero.

   <emphasis/Mode/ is the 5503 oscillator mode for the voice in the bits 1 and 2.
   The lowest bit (bit 0) is a ``halt'' flag.
   0 is looping, 1 is oneshot (play once), 2 is sync/AM (which nobody uses, but
   I'll try to explain it if they actually are), and 3 is swap (oscillator 0
   plays once, generates an IRQ, and oscillator 1 starts automatically.  If
   oscillator 1 is also in swap mode, it will play once, generate and IRQ, and
   auto-start oscillator 0 again.  If oscillator 1 is loop mode it will just
   loop continuously - this setup is often used to have a sampled ``attack'' on
   an instrument followed by a loop.

   The top 4 bits of the mode is the stereo channel where even numbers are
   right and odd numbers are left, I believe (no real harm in reversing them).

   The full bitmap for the control register is:
<programlisting>
% cccc 0mmh
</programlisting>

   Where:
   <simplelist>
    <member><literal/c/ - stereo output channel. Odd values mean left, even mean right.
    <member><literal/m/ - mode, as described previously.
    <member><literal/h/ - halt bit. 0 to start the oscillator, 1 to halt it.
      This is handled specially in swap mode.
   </simplelist>

   <emphasis/relPitch/ is the fine-tune value in 8.8 fixed point, given in semitones.

   So you'd then start 2 voices using the appropriate A and B wavelist entries
   and handle them accordingly.

   The full structures look like this:
   (there is no structure padding on the IIgs - all bytes are jammed right
   together!)

   In Police Quest these structures start at offset 0x8469 in PQ.SYS16.
   <emphasis>(The same offset is used for KQ1 --CM)</emphasis> I can't find any of my
   other old disks with AGI games to locate their offsets. PQ only defines
   28 instruments.

<programlisting>
ENVELOPE:

Byte  Meaning
----- -----------------------------------------------------------
  0   Breakpoint for this segment
 1-2  Increment for this segment
----- -----------------------------------------------------------

WAVELIST:

Byte  Meaning
----- -----------------------------------------------------------
  0   Top key
  1   Wave address
  2   Wave size
  3   Mode / stereo position
 4-5  relPitch
----- -----------------------------------------------------------

INSTRUMENT:

Byte  Meaning
----- -----------------------------------------------------------
0-23  8 envelope segments
 24   Release segment
 25   Priority increment (you can ignore this)
 26   Bend range
 27   Priority increment (you can ignore this)
 28   Bend range
 29   Vibrato depth
 30   Vibrato speed
 31   "spare" (unused)
 32   A wave count (number of A oscillator wavelists)
 33   B wave count (number of B oscillator wavelists)
34-?  (A wave count number of wavelists)
  ?   (B wave count number of wavelists)
----- -----------------------------------------------------------
</programlisting>

</para>

<sect1><title>Playing the sounds on a sound card</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/ (Last updated: 18 August 1997)
</emphasis>

   Writing a program to play the tunes will require four pointers which
   keep track of where in each voice segment the program currently is
   since all four voices are played simultaneously. The first voice is
   the melody and is the voice that is played on the PC speaker in
   today's modern PC compatibles, the other two voices being ignored. I'd
   imagine that other platforms such as the Amiga and Macintosh would
   probably play all three voices.

   A program would start by reading each of the four offsets in the
   header. It would then go through a loop which begins by reading the
   first note of each voice section. The duration's are then monitored
   and when each note finishes, another note is read. Note that the notes
   for each voice will usually finish at different times. The program
   finishes when all of the voice sections have been entirely played.
   This will usually occur for each voice at the same time but not
   necessarily I don't think.

   Then of course you could always convert the AGI SOUND to a MIDI file
   and play that which will sound a hundred times better :)
</para>

<sect2><title>Calculating frequencies when playing notes on a sound card</title>
<para>
   My program reads in the duration as a 16 bit word. It then loads the
   two following bytes and calculates the frequency as follows:
<programlisting>
f = 111860 / (((Byte2 & 0x3F) << 4) + (Byte3 & 0x0F))
</programlisting>

   The 111860 comes from the PCjr discussion above. Note that the bytes
   are in the opposite order from that mentioned in the PCjr information.

   Remember also that the SOUND format includes volume information for
   each voice. The exact conversion from the decible values to the volume
   control on todays sound cards is uncertain at this stage.
</para>

<sect1 id="soundcode"><title>Sample code</title>
<para>
   The following examples are available in the <ulink name="http://agi.helllabs.org/agispecs/"/distribution package/:

   <simplelist>
    <member><literal><ulink name="examples/sound/adlib.c"/adlib.c/</literal>
      by Kevin A. Lee: low level adlib routines
    <member><literal><ulink name="examples/sound/adlib.h"/adlib.h/</literal>
      by Kevin A. Lee: header for <literal/adlib.c/
    <member><literal><ulink name="examples/sound/oldplay.c"/oldplay.c/</literal>
      by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/: old program to play AGI sounds
    <member><literal><ulink name="examples/sound/play.c"/play.c/</literal>
      by <ulink name="mailto:jchrr@hrz.uni-bielefeld.de"/Jens Christian Restemeier/: new program for playing AGI sounds (plays as a MIDI
      file)
    <member><literal><ulink name="examples/sound/agiplay.c"/agiplay.c/</literal>
      by <ulink name="mailto:claudio@helllabs.org"/Claudio Matsuoka/: program to play PCjr AGI sound resources in Linux using
      software mixing and <literal>/dev/dsp</literal>
   </simplelist>

</para>
</chapter>


<chapter id="otherdata"><title>Other game data</title>
<para>
<emphasis>
Written by <ulink name="mailto:lance.e@ihug.co.nz"/Lance Ewing/
(Last updated: 31 August 1997).
</emphasis>
</para>

<sect1><title>Format of the <literal/object/ file</title>
<para>
   The <literal/object/ file stores two bits of information about the inventory
   members used in an AGI game. The starting room location and the name of
   the inventory member. It also has a byte that determines the maximum
   number of animated objects.
</para>

<sect2><title>The file encryption</title>
<para>
   The first obstacle to overcome is the fact that most <literal/object/ files are
   encrypted. I say most because some of the earlier AGI games were not,
   in which case you can skip to the next section. Those that are
   encrypted are done so with the string ``Avis Durgan'' (or, in case of
   AGDS games, ``Alex Simkin''). The process of unencrypting the file is
   to simply taken every eleven bytes from the file and XOR each element
   of those eleven bytes with the corresponding element in the string
   ``Avis Durgan''. This sort of encryption is very easy to crack if you
   know what you are doing and is simply meant to act as a shield so as
   not to encourage cheating. In some games, however, the object names are
   clearly visible in the saved game files even when the <literal/object/ file
   is encrypted, so it's not a very effective shield.

<sect2><title>File format</title>
   <para>
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Offset of the start of inventory member names
  2   Maximum number of animated objects
----- -----------------------------------------------------------
</programlisting>

   Following the first three bytes as a section containing a three byte
   entry for each inventory member all of which conform to the following
   format:
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Offset of inventory member name i
  2   Starting room number for inventory member i or 255 carried
----- -----------------------------------------------------------
</programlisting>
   where <emphasis/i/ is the entry number starting at 0. All offsets are taken from
   the start of entry for inventory member 0 (not the start of the file).

   Then comes the textual names themselves. This is simply a list of NULL
   terminated strings. The offsets mentioned in the above section point
   to the first character in the string and the last character is the one
   before the 0x00.
</para>
</sect1>

<sect1><title>Format of <literal/words.tok/</title>
<para>
   The <literal/words.tok/ file is used to store the games vocabulary, i.e. the
   dictionary of words that the interpreter understands. These words are
   stored along with a word number which is used by the <literal/said/ test
   commands as argument values for that command. Many words can have the
   same word number which basically means that these words are synonyms
   for each other as far as the game is concerned.

   The file itself is both packed and encrypted. Words are stored in
   alphabetic order which is required for the compression method to work.
</para>

<sect2><title>The first section</title>
<para>
   At the start of the file is a section that is always 26x2 bytes long.
   This section contains a two byte entry for every letter of the
   alphabet. It is essentially an index which gives the starting location
   of the words beginning with the corresponding letter.
<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
 0-1  Hi and then Lo byte for 'A' offset
 ...
50-51 Hi and then Lo byte for 'Z' offset
 52   Words section
----- -----------------------------------------------------------
</programlisting>

   The important thing to note from the above is that the 16 bit words are
   big-endian (HI-LO). The little endian (LO-HI) byte order convention used
   everywhere else in the AGI system is not used here. For example, 0x00
   and 0x24 means 0x0024, not 0x2400. Big endian words are used later on
   for word numbers as well.

   All offsets are taken from the beginning of the file. If no words
   start with a particular letter, then the offset in that field will be
   0x0000.
<para>

<sect2><title>The words section</title>
<para>
   Words are stored in a compressed way in which each word will use part
   of the previous word as a starting point for itself. For example,
   ``forearm'' and ``forest'' both have the prefix ``fore''. If ``forest''
   comes immediately after ``forearm'', then the data for ``forest'' will
   specify that it will start with the first four characters of the previous
   word. Whether this method is used for further confusion for would be
   cheaters or whether it is to help in the searching process, I don't
   yet know, but it most certainly isn't purely for compression since the
   <literal/words.tok/ file is usally quite small and no attempt is made to
   compress any of the larger files (before AGI version 3 that is).

<programlisting>
Byte  Meaning
----- -----------------------------------------------------------
  0   Number of characters to include from start of prevous word
  1   Char 1 (xor 0x7F gives the ASCII code for the character)
  2   Char 2
 ...
  n   Last char
 n+1  Wordnum (LO-HI) -- see below
----- -----------------------------------------------------------
</programlisting>

   If a word does not use any part of the previous word, then the prefix
   field is equal to zero. This will always be the case for the first
   word starting with a new letter. There is nothing to indicate where
   the words starting with one letter finish and the next set starts,
   infact the words section is just one continuous chain of words
   conforming to the above format. The index section mentioned earlier is
   not needed to read the words in which suggests that the whole
   <literal/words.tok/ format is organised to find words quickly.
</para>

<sect2><title>A note about word numbers</title>
<para>
   Some word numbers have special meaning. They are listed below:

<programlisting>
Word# Meaning
----- -----------------------------------------------------------
  0   Words are ignored (e.g. the, at)
  1   Anyword
9999  ROL (Rest Of Line) -- it does matter what the rest of the
      input list is
----- -----------------------------------------------------------
</programlisting>

   Example:
<programlisting>
if (said(take, anyword)) {
    print("You can't - Blackbeard has chopped both your arms off.");
}
</programlisting>
</para>
</sect1>

<sect1 id="othercode"><title>Sample code</title>
<para>
   The following examples are available in the <ulink name="http://agi.helllabs.org/agispecs/"/distribution package/:

   <simplelist>
    <member><literal><ulink name="examples/otherdata/object.pas"/object.pas/</literal>
      by <ulink name="mailto:ptrkelly@ozemail.com.au"/Peter Kelly/: displays contents of the <literal/object/ file
    <member><literal><ulink name="examples/otherdata/words.pas"/words.pas/</literal>
      by <ulink name="mailto:ptrkelly@ozemail.com.au"/Peter Kelly/: displays contents of the <literal/words.tok/ file
   </simplelist>
</chapter>


<chapter id="other"><title>Other information</title>

<sect1 id="agds"><title>The AGDS package</title>
<para>
<emphasis>
Written by <ulink name="mailto:ptrkelly@ozemail.com.au"/Peter Kelly/
(Last updated: 27 January 1998).
</emphasis>
</para></para>
   Around 1990--91 there was a project in Russia similar to ours. Pretty
   much all of the file formats were figured out and documented, and a
   suite of programs which would allow you create and edit AGI games was
   created. This was called AGDS (Adventure Game Design System).
</para></para>
   Of course this was in the days before the internet took off, so no one
   put up a website about it, which is why we assumed we were the first
   ones to do this. But thanks to Igor Nesterov who supplied the package
   and performed the original translation of the documentation, we can
   now benefit from this project. Vassili Bykov has since provided an
   improved translation.
</para></para>
   I have recently found out that the author of the package was
   <ulink name="mailto:simkin@argussoft.ru"/Alex Simkin/
   (with help from Serge Lapin). Alex tells me that some of the tools were
   originally written to solve a puzzle in Leisure Suit Larry 1. A friend
   from Elias (a publising group) asked him to make a compiler so he could
   edit the logics and translate the games into Russian. The AGDS package
   was the result. I would like to thank Alex and Serge for all their work
   on AGDS, which has helped us a lot, particularly in the area of logic
   programming. I would also like to thank
   <ulink name="mailto:const@aha.ru/Konstantin Mironovich/ for putting me in
   touch with Alex after seeing one of the AGI websites.
</para>
</sect1>

<sect1 id="thunderstorm"><title>The making of the <emphasis/Thunderstorm/ educational Program</title>
<para>
<emphasis>
Written by A. V. Horev, Chuvashia State University and translated by Vassili Bykov.
</emphasis>
</para><para>
   <emphasis>
   Translator's note: The original uses terms such as AGDS interpreter,
   AGDS programming, AGDS language. In the translation I am replacing AGDS
   in these with AGI, leaving AGDS only to refer to the set of resource
   creation and manipulation utilities this document originally accompanied.
   I believe this is only fair.
   </emphasis>
</para><para>
   <emphasis>
   In the ``classic'' AGI, words of command names are separated with
   dots, while in this text they are separated with underscores
   (<literal/new.room.v/ vs. <literal/new_room_v/) - the consequence of using MASM as
   the assembler for logic code in AGDS. I leave the names with underscores,
   but keep this in mind.
   </emphasis>
</para>

<sect2><title>The making of <emphasis/Thunderstorm/ educational program</title>
<para>
   <quote>
<emphasis>``... how did it come to pass?''</emphasis>
(from a song)
   </quote>
</para><para>
   I want to tell you how we made this program using the AGDS package we
   bought because, in my option, just reading the package's manual is not
   enough to create your own programs. In this story I will try to point
   out to you the causes of difficulties we had, tell how we made that
   program, how we used the utilities from the package, and how, in my
   opinion, you have to approach writing such programs. But in order to
   understand this story you have to have to at least skim through the
   manual.
</para><para>
   So, you bought the package and read the manual. Probably, you don't
   have a feeling you can start coding right away. I didn't -- however the
   manual you receive with the package now has been updated based on my
   experience of using the product. Anyway, now is the time for you to
   read on.
</para><para>
   It is possible that, having read the manual, you ask yourself a
   question, ``Can I master the package in a short enough time to create
   my own program?'' This is why a bit about myself. I have eleven years
   of programming experience, however my experience has never had
   anything to do with game or education programs development -- most
   probably, just like yours. I have always been wondering how programs
   like these are created, and I suspected that they require specialized
   tools and experience in that kind of programming. Probably, the
   developers are not quite regular programmers. This is all true. But I
   should say that in order to create a fairly simple educational
   program, like <emphasis/Thunderstorm/, it is enough to have experience with at
   least one high-level language, a personal computer, AGDS package, and
   enough time and desire to do that. But you will learn the package
   fairly quickly only of you have good programming skills and some
   experience of using IBM PC.
</para>
</sect2>

<sect2><title>How we started</title>
<para>
   I should say this project popped as if out of nowhere and we had a
   fairly short time to finish it: about 2 months, a month of that to
   make the program itself. At that time we had no idea how we shall
   approach that task, nor did we have the tools to do that. All we had
   was IBM PC XT and the rumours of a unique AGDS package. That is, we
   had to start from scratch and, honestly, it was pretty hard.
</para><para>
   In a hurry I went to Moscow, checked out the product, found it
   suitable though the real test would be at home. Bought. Came back.
   Printed out the manual. Read. Complete mess in the head. No idea what
   to do. More news: the demo does not link on an XT. How can I start
   working with this knowledge, how can I explain the artist how to draw
   everything so it is then easier to program? And how to program is not
   clear either. What to do? Tried to play a few Sierra games to get used
   to them. But all the games are controlled using key phrases that,
   naturally, I don't know. <emphasis>(He probably means the input in English and
   he doesn't speak English. --VB)</emphasis> No time to guess. Tried to print out
   words.tok using WL utility. Didn't help much because the dictionary
   stores separate words while the game requires complete sentences which
   are in some way analyzed by the interpreter and, depending on the
   result, the game develops. Now this is interesting! This means I can
   write an educational program and communicate with it using sentences.
   (As it appeared later, only English).
</para><para>
   Then I found that in <emphasis/In Search of a Lost Planet/ (by the way, it begins
   with a key phrase `start game') you can load and turn on the debugger
   using <literal/Alt+D/ and <literal/Scroll Lock/. This opens a text window with the
   commands. Later came understanding that to the left of a command is
   the number of logic it is from, while to the right and below, the
   result. Noticed that if nothing happens in the game (no input using
   error keys or key phrases), the logic numbers and commands are the
   same, and are mostly tests. So it is like something runs in a cycle.
   Besides, if the debugger was turned on while the character on the
   screen was moving, every cycle a new phase of the character's movement
   was drawn on the screen (for example, the leg was going up). Picked up
   the manual, read <emphasis/Interpreter Work Cycle/. All became a bit more clear.
   As it appears, each cycle the interpreter redraws the character if a
   movement command was issued (this is easier to see than to understand
   from explanations, try to do that yourself). So the character is a
   controlled object (Ego, as it is called in AGI language), and has a
   VIEW resource associated with it, which is its picture on the screen.
   And, as the movement direction changes, the interpreter automatically
   chooses the proper animation (loop of cels in the VIEW resource) to
   draw the character.
</para><para>
   I disassembled the source code of the logics seen in the debugger using
   SM. Printed them out. As it appears, the programs are much larger than
   I thought because what I saw in the debugger were only the commands
   required at that moment according to the tests in the program. And
   then I started to figure out how to write programs, specifically
   educational programs, for the interpreter, because there were no
   examples at all.
</para>
</sect2>

<sect2><title>What do you have to know about the interpreter
       to write a simple educational program?</title>
<para>
   The title intentionally talks about an educational program because I
   think we shall use AGDS to create educational programs on various
   topics. Learning while playing is the best kind of learning. I think
   you will agree that a good educational program should be like a game.
</para><para>
   When you bought AGDS you have also received a <emphasis/Thunderstorm/ educational
   program as an example. Not only the program itself, but also the
   commented source code of logics of that program. I think the program
   is far from being perfect but it may be a good example to you in
   learning AGI language. Though the program is fairly simple and does
   not use all commands of the language, I hope it can give you enough
   information to later easily read the source of Sierra games' logics,
   which are the true examples of AGI programming.
</para><para>
   So let us begin with the fundamental issues of AGI programming, since
   programming is the most complex part of game creation.
</para><para>
   Programming for AGI is fairly unusual because of the specifics of how
   the interpreter works:
   <itemizedlist>
    <listitem><para>The cyclic nature of the interpreter operation completely defines
       the style of AGI programming. The style is rather unusual and
       requires understanding and getting used to it. We shall discuss,
       using the source of of <emphasis/Thunderstorm/ as an example, how to write
       programs executing in that cyclic manner.
    </para></listitem>

    <listitem><para>A common set of variables, flags, and strings for all the
       subroutines loaded in the interpreter memory, which means any
       variable or flag is accessible from any part of the program (this
       includes the reserved variables and flags).
    </para></listitem>

    <listitem><para>Data elements of any type (variable, flag, resource) are
       identified with a unique ID number (0..255, string variable -
       0..11). At first this seems inconvenient, but later you get used
       to it.
    </para></listitem>

    <listitem><para>Command name determines the data type it operates on, the nature
       of its operation, and the result. For example, consider assignment
       commands: <literal/assignn 10, 2/ means store the value 2 into the variable
       number 10; <literal/assignv 10, 2/ means store the value of variable 2 into
       the variable 10; <literal/set 10/ mean set flag 10 to 1. Most often you will
       have to memorize what each command does and the type of its
       operands.
    </para></listitem>

    <listitem><para>Small internal interpreter memory occasionally overflows. This is
       annoying because there may be lots of free RAM at the same time.
    <listitem><para>There are powerful commands new_room and <literal/new_room_v/ used to
       completely change the program behaviour.
    <listitem><para>There are many test commands which allow not only to check the
       state of variables and flags, but also the position of objects one
       relative to another, or relative to some special lines and areas
       drawn on the background (for example, control barriers or water
       surface). The result of tests determines the progress of the game
       according to the design.
    </para></listitem>

    <listitem><para>The ability to fairly easily animate objects on the screen. Note
       that all the images programmatically associated with objects the
       interpreter or the user can control, have to be first created
       using the VIM utility, as well as the background created using PM
       utility. That is, creating an animation is a two-stage process:
       drawing a frame-by-frame animated sequence of the object (a human
       figure walking but not moving) and programmatic movement of the
       object for which the animation is played (this creates a walking
       figure). We shall later discuss the interaction between the
       designer, the artist and the programmer.
    </para></listitem>

    <listitem><para>The ability to use a built-in debugger, invoked using Scroll Lock
       if the debugger table log.dbg is loaded into the interpreter
       memory.
    </para></listitem>

   </itemizedlist>
</para><para>
   I want to warn you that most probably you will not be able to use the
   debugger on IBM PC XTs because DUU and VM utilities (of the versions
   we have) have problems including log.dbg into data volumes on IBM PC
   XTs. Because <emphasis/Thunderstorm/ was created on an XT, I wrote it ``blindly''
   because I could not (and still cannot) use the debugger. For that
   reason there is no debugger in the program - this may complicate your
   study of <emphasis/Thunderstorm/.
</para>
</sect2>

<sect2><title>How I coded <emphasis/Thunderstorm/</title>
<para>
   By the time I had to start coding I had an approximate design of what
   we wanted to make but no idea of how to approach it.
</para>

<sect3><title>I had the design</title>
<para>
   Was that the right design? Could it actually be used to create a
   program? The design, and how detailed it is, determines a lot, in
   particular the efficiency of the programmer's work. The design I got
   was written in general, not considering the interpreter's
   capabilities. I'll be straight and tell you that I used it only to
   keep to the required topic and to not "lie" in the accompanying text,
   so there is no point in including the design here. You will get an
   idea of the plot when we start looking at the source code.
</para><para>
   But here I want to tell you what criteria the design should satisfy.
</para><para>
   First of all about the designer's personality and his role in the
   project. The designer should be able to create designs, be a good
   psychologist, and have an idea of the interpreter's capabilities to
   not come up with an unrealistic design. (Which must be impossible at
   the first try.)
</para><para>
   The designer has the key role in the project -- assuming the team
   includes at least three members: the designer, the artist, and the
   programmer. The designer, keeping to the design he created, should
   facilitate the collaboration between the artist and the programmer.
</para><para>
   The artist's and the programmer's work can be separated in time: the
   artist should follow the design first, creating VIEW and PICTURE
   resources for the programmer to bring together according to the same
   design. In the course of work it is possible that some corrections to
   the already existing art will be needed. This is why, once the design
   is created, communication between the artist and the programmer is
   very important, especially because there should be some equilibrium
   between the artist's and the programmer's effort, especially dealing
   with VIEW resources. The increase in the required artist's effort
   almost always decreases the programmer's, and the other way around.
</para><para>
   Here is an example. There is a place in <emphasis/Thunderstorm/ where the
   ionisation process is explained. It shows how a moving electron
   collides with an atom and kicks out another electron from it. It is
   possible for the artist to create three separate VIEW resources: atom,
   electron, and the electron that gets kicked out. Then the programmer
   has to describe these three objects separately, associate them with
   the VIEW resources that will be their on-screen images, and code the
   whole ionisation process: set the electron's motion, determine the
   moment when it touches the atom, describe how the kicked out electron
   moves. This is extremely tedious and may dramatically increase the
   size of the program, or require subprograms. The alternative is to
   make it simpler by giving more work to the artist: draw the whole
   process in a single loop of a VIEW resource, the way it is done in
   <emphasis/Thunderstorm/. In this case all the programmer has to do is describe
   one object, associate it with the view resource and play back the
   animation. Remember that with this approach you cannot arbitrarily
   increase the animation length: VIM editor and the interpreter itself
   have their limitations, besides, a large VIEW resource takes a
   significant part of the interpreter's internal memory. Even if does
   not overflow, redrawing large images may significantly slow down the
   program. Don't make animations longer than 25 average (50x50) cels.
</para><para>
   We have distracted from the design a bit. The design should completely
   and in details describe the plot. Using the interpreter's terminology,
   the following should be included:
   <itemizedlist>
    <listitem><para>All rooms and conditions when the rooms are changed, i.e. when the
       background art and the controlling programs change.
    </para></listitem>
    <listitem><para>All actions taking place in each room and conditions determining
       when each particular action takes place.
    </para></listitem>
    <listitem><para>All objects in the room, and whether an object is a part of the
       scenery (PICTURE resource) or a separate thing (VIEW resource)
       controllable from the program; this is important to the artist.
    </para></listitem>
    <listitem><para>Position, at least approximate, of all objects created as VIEW
       resources; this is important to the programmer.
    </para></listitem>
    <listitem><para>All members the player can get as the result of certain actions, and
       those actions themselves.
    </para></listitem>
    <listitem><para>Approximate priorities of the objects, both parts of scenery and
       VIEW resources, which creates an illusion of depth; this is
       important to the artist and the programmer.
    </para></listitem>
    <listitem><para>Interactions between the objects: for example, whether the object
       treats other objects as obstacles, whether it can cross the
       horizon or leave a certain area, etc.; this is important to the
       programmer.
    </para></listitem>
    <listitem><para>Conditions when the on-screen image of an object may change. For
       example, when a walking person crosses a brook, the images should
       change to the image knee-deep in water, etc.
    </para></listitem>
    <listitem><para>All messages and dialogue that occur in each room under certain
       conditions, and those conditions.
    </para></listitem>
    <listitem><para>Game vocabulary including the words the game understand.
    </para></listitem>
    <listitem><para>Sentences used to control the objects and reactions to them, etc.
    </para></listitem>
   </itemizedlist>
</para><para>
   Probably you can extend this list yourself. How detailed the design
   should be is subjective, but you have to be specific.
</para><para>
   Therefore, an advice: The design should be created by someone
   familiar with the interpreter capabilities. Otherwise you will have to
   change the design as you go, or the programmer will have to improvise,
   which can lead to conflicts.
</para><para>
   So let's assume the design is ready, the art is drawn, and we can
</para>

<sect3><title>Start Coding</title>
<para>
   Each room in the game has its program (LOGIC resource, or simply
   "logic"), the backdrop, and the objects some of which can be
   controlled by the interpreter according to the directions in the
   program, and one of which may be controlled by the user using the
   arrow keys (object 0 called Ego).
</para><para>
   <emphasis/Interpreter Work Cycle/ explains that at any moment in the interpreter
   memory (approximately two hundred 256-byte pages) the LOGIC resource 0
   is loaded which is continuously executed and is, in fact, the
   algorithm of the program work. Also the memory contains other
   explicitly loaded LOGIC, VIEW, and SOUND resources. PICTURE resource
   should not be in memory because once the backdrop is displayed we can
   unload it from memory using <literal/discard_pic/ command.
</para><para>
   Starting to code, remember that the program controlled by the
   interpreter executes in cycles (this is unusual and takes some time to
   get used to). This means that when <literal/call/ or <literal/call_v/ command is
   executed in logic 0, control is passed to the logic which is the operand
   of the command. That logic may similarly pass control to yet another logic,
   etc. The called logic's commands will be executed once (unless it
   contains inner cycles not associated with controlling objects - for
   example, incrementing a variable in a cycle until it reaches a certain
   value, or looping waiting for a key to be pressed, etc.) and, when
   return command is encountered, or by default when the last operator of
   the logic is reached, control returns to the command that follows the
   <literal/call/ command of the caller logic. Its commands will also execute and
   <literal/return/ command will return control to its caller, etc. until control
   returns to logic 0. <literal/return/ in logic 0 returns control to the
   interpreter which executes the rest of the Interpreter Work Cycle (see
   block diagram), for example redraws or moves controlled objects
   according to their settings.
</para><para>
   Important consequence: You should never perform any cyclic activities
   related to drawing objects on the screen yourself. The interpreter
   will do this for you. But you have to provide it with the proper
   information.
</para><para>
   For example, suppose you want to play the animation associated with
   the object 1 once. To do that it is enough to issue <literal/end_of_loop 1, 121/
   command, where 121 is the identifier of the flag set to 1 once the
   animation reaches the last frame. Therefore, you have to return
   control to the interpreter on every subsequent iteration of the
   interpreter cycle until this flag is set. The code looks like this:
</para><para>
   <programlisting>
  if_
     not_
     isset 121
   else_ A
     end_of_loop 1, 121
     return
A:   ..............
   </programlisting>
</para><para>
   <emphasis>(This is correct assuming that issuing <literal/end_of_loop/ to a running
   animation has no effect whatsoever (in particular does not affect the
   value of the counter of interpreter cycles left until the next cel
   change) -- because this is exactly what happens here. --VB)</emphasis>
</para><para>
   The same applies to playing sounds, moving objects and, in general,
   all commands setting a flag once their action completes.
</para><para>
   Now it gets a bit more clear and we can start working on logic 0. (It
   is a good idea to read further keeping handy the source code of
   <emphasis/Thunderstorm/'s <literal/log0.asm/, <literal/log01.asm/ and <literal/log05.asm/.
</para><para>
   Logic 0 (unlike all other logics) always stays in the interpreter's
   memory and determines all the interpreter's actions relevant to the
   overall game control. This is why I decided it has to store the
   description of actions common to all logics of the future program (how
   many logics there will be I knew only approximately). These actions, I
   decided, would first of all include the tests if the keys I have
   reserved for certain actions (help, turning sound on or off,
   restarting the program, etc.) are pressed (see <literal/log0.asm/). Besides, it
   should include one-time actions that show the program title screen and
   perform initial initializations. (Initialization code is in logic 1,
   <literal/log01.asm/).
</para><para>
   Initialization code is executed only once and contains the commands
   that change the cursor shape, built-in debugger parameters, character
   colour, maximum score, and assign certain numeric codes to the keys I
   have chosen (set_key command), to be used later by the controller
   command to determine the state (pressed/released) of these keys.
</para><para>
   Because logic 0 is so important, here is its block diagram:
<programlisting>
 +-----------+    +--------------+    +---------+
 | v17 = 0?| |    |    handle    |    |         |
 |---------|Y+--->|interp. error +--->|  quit   |
 |    N    | |    |   call_ 97   |    |         |
 +-----------+    +--------------+    +---------+
       v
 +-----------+
 | v0 = 0 ?| |
 |---------|N+--->-----------------------+
 |    Y    | |                           |
 +-----------+                           |
       v                                 |
 +-----------+    +----------------+     |
 | f6 ->1 ?| |    |  set script    |     |
 |---------|Y+--->|    table       |     |
 |    N    | |    |     size       |     |
 +-----------+    +-------+--------+     |
       v                  |              |
 +-----------+            |              |
 | call_ 01  |            |              |
 |initialize |<-----------+              |
 | program   |                           |
 +-----------+                           |
       v                                 |
 +-----------+    +---------------+      |
 | f6 ->1 ?| |    |   new_room 5 -|      |
 |---------|Y+--->|    start      |      |
 |    N    | |    |    session    |      |
 +-----------+    +---------------+      |
       v                                 |
 +-----------+                           |
 | new_room 2|                           |
 |  title    |                           |
 |  screen   |                           |
 +-----------+                           |
       _---------------------------------+
       v
 +-----------+     +--------------+
 |F1 press | |     |   display    |
 |---------|Y+---->| message 6    |
 |    N    | |     |   (help)     |
 +-----------+     +--------------+
       v
 +-----------+     +--------------+
 |F2 press | |     |   toggle     |
 |---------|Y+---->|   flag 9     |
 |    N    | |     |(sound on/off)|
 +-----------+     +--------------+
       v
 +-----------+     +--------------+
 |F10 press| |     |   change     |
 |---------|Y+---->|   speed -    |
 |    N    | |     |    (v10)     |
 +-----------+     +--------------+
       v
 +-----------+     +--------------+
 |F9 press | |     |              |
 |---------|Y+---->|   restart    |
 |    N    | |     |(restart_game)|
 +-----------+     +--------------+
       v
 +-----------+     +--------------+
 |  Alt+z ?| |     |              |
 |---------|Y+---->|    quit      |
 |    N    | |     |              |
 +-----------+     +--------------+
       v
 +-----------+     +--------------+
 |  Alt+i ?| |     |   show       |
 |---------|Y+---->|   credits    |
 |    N    | |     |   info       |
 +-----------+     +--------------+
       v
 +-----------+     +--------------+        -
 | v0 = 2 ?| |     |              |        |call
 |---------|N+---->|   call_v 0   |- - - - |the current room's
 |    Y    | |     |              |        |logic !
 +-----------+     +--------------+        -
       v                  ^            +---------------------+
 +-----------+     +--------------+    |- display greeting,  |
 | f54->1 ?| |     |      N     | |    |  switch to the      |
 |---------|N+---->|------------|Y+--->|  text mode          |
 |    Y    | |     |hit any key?| |    |           ;         |
 +-----------+     +--------------+    |- f54 -> 1;          |
       |                               |- return             |
       +----------------<-+            +---------------------+
       v                  |
+--------------+   +----------------------+
|hit any key?| |   |wait for any keypress |
|------------|N+-->|(initial greeting is  |
|      Y     | |   |on the screen now)    |
+--------------+   +----------------------+
       v
+--------------+
|   return to  |
| graphics mode|
|and execute   |
|  new_room 5, |
|  i.e.begin   |
| game session |
+--------------+
</programlisting>
</para><para>
   Note that logic 0 always begins with a check if variable 17 is 0.
   Non-zero value means the interpreter has found an error. Error handler
   is in <literal/log97.asm/ (you can use this logic unchanged in all your
   programs).
</para><para>
   If there is no error, let's check the current room number in the
   variable 0 (further in the text we shall refer to variables as `<literal/v/'
   followed by the variable number, for example <literal/v0/ means variable 0). We
   start in the room 0 because all variables are 0 when the interpreter
   starts. Initialization logic executes in room 1 (see <literal/log01.asm/),
   called using <literal/call 01/. After that we check if we have just started the
   program or the program has been restarted with <literal/restart_game/. This is
   to avoid showing the title on restart. So on the first execution flag
   6 (<literal/f6/) is reset (equals 0) and <literal/new_room 2/ command executes
   meaning we move to the room number 2.
</para><para>
   Second room is the <emphasis/Thunderstorm/ title screen. The corresponding logic
   is logic 2 (same as the room number, have a look into <literal/log02.asm/ - when
   we are finished with logic 0 we shall come back to it).

   <literal/new_room/ is a complex and powerful command, it executes a lot of
   actions. For now, it is important to understand the following:
   <itemizedlist>
    <listitem><para><literal/new_room n/ stores the command operand in <literal/v0/, i.e. the
       value of <emphasis/n/, 2 in our case.
    </para></listitem>
    <listitem><para>All logics in the interpreter memory are discarded and logic n (2
       in this case) is loaded.
    </para></listitem>
    <listitem><para>flag 5 is set (<literal/f5/ -> 1)!
    </para></listitem>
    <listitem><para>Control is returned to the interpreter which starts logic 0 from
       the beginning (see the <emphasis/Interpreter Work Cycle/).
    </para></listitem>
   </itemizedlist>
</para><para>
   After <literal/new_room 2/ <literal/log0.asm/ checks if any reserved keys have been
   pressed, using controller command. Then we check if we are in the
   second room (title screen). If yes we check if any key is pressed
   using test_key. If not, the title screen logic is called. As soon as
   any key is pressed, the screen is switched to the text mode and the
   greeting text is displayed. This also sets flag 54. Next time logic 0
   executes the invitation is not displayed (because we check <literal/f54/) and we
   simply wait for any key to be pressed in a wait loop. During that
   cycle control is not returned to the interpreter. When a key is
   pressed the screen switches to the graphics mode and <literal/new_room 5/
   command is issued. In this room the game (education) session begins.
</para><para>
   Thus logic 0 should contain:
   <orderedlist>
    <listitem><para>A test for an error (using <literal/v17/) and a call to the error handler.
    </para></listitem>
    <listitem><para>A call to the initialization logic.
    </para></listitem>
    <listitem><para>Actions common to all logics.
    </para></listitem>
    <listitem><para><literal/call_v 0/ command that calls the logic corresponding to the last
       room set using <literal/new_room v/, which has to be executed each
       interpreter cycle.
    </para></listitem>
   </orderedlist>
</para><para>
   Let us return to logic 2 (see <literal/log02.asm/) which describes the actions
   in the second room. I shall not describe the details of how the
   rainbow is moved across the large letters of the program title, it is
   enough to say that the letters have priority 4 while the outer
   areas have priority 7. The rainbow, stored in a VIEW resource 21, is
   assigned priority 5 in the program. This creates an illusion of the
   rainbow moving only in the inner area of the letters. You will
   understand how to move the rainbow when you study the source code in
   <literal/log02.asm/.
</para><para>
   It is more important to study the overall structure of logic 2 because
   it is characteristic to the interpreter programs and is common to all
   logics we discuss below.
</para><para>
   Note that the logic begins with a check for the flag 5 (<literal/f5/) state.
   This flag is reserved by the interpreter. This does not mean you
   cannot change its value (you can change any flags and values, reserved
   or not; the question is what will happen). The flag is called reserved
   because under certain circumstances the interpreter may change the
   value of the flag or the variable, or read their (set by you) values
   and react in a certain way. You can see the list of all the reserved
   flags and variables in the AGDS manual.
</para><para>
   Flag 5 is set when the new room is run for the first time, i.e. this
   is the first entry into the room's logic. You probably remember that
   after a new_room command the interpreter sets <literal/f5/ and loads the room
   logic. After that control is passed to logic 0 which, in turn, calls
   the room logic using <literal/call_v 0/ (see <emphasis/Interpreter Work Cycle/).
</para><para>
   Any room logic usually includes a part which we can call the
   initialization code. This part describes actions that have to be
   executed only once on the first call. If you consider that the
   interpreter automatically resets <literal/f5/ on the next cycle, we have an
   ideal tool for selecting initialization code. This code usually loads
   resources used in the logic. It can load other logic resources used as
   subroutines of this logic. If these ``subroutine logics'' also include
   initialization code, these logics have to be called after loading from
   the initialization code of the room. The example is logic 20 (blinking
   stars) which is loaded and called from the initialization code of
   logic 2.
</para><para>
   Also note how this part loads and draws the scenery (letters of the
   title as holes in a screen with the rainbow band moving behind them).
   The command sequence <literal/load_pic n/, <literal/draw_pic n/, <literal/discard_pic n/,
   ...  <literal/show_pic/ is important! Any other sequence can lead to crash
   because the loaded resource takes a lot of memory.
</para><para>
   Initialization code is finished using return which returns control to
   logic 0 and then to the interpreter. The interpreter will reset <literal/f5/
   before the next cycle, and that cycle will execute the bodies of all
   the called logics.
</para><para>
   I shall not consider the rainbow band motion algorithm (the body of
   logic 2) because it is described in the comments in the source code.
   Just note that each new action (the band moving up, the band moving
   down, company title appearing, and the message ``educational program'')
   increments the variable 201 (<literal/v201/). At the end of each action a flag
   associated with that action is set. After all actions have completed,
   <literal/new_room 2/ command is issued and the title is repeated, unless
   interrupted by any key press (which is checked in logic 0).
</para>

<sect3><title><emphasis/Thunderstorm/ Program Structure</title>
<para>
   Before we continue our discussion of logics, a few words about the
   program structure.
</para><para>
   Perhaps I won't say anything new, but the following conditions are
   important when you design an educational program.
   <itemizedlist>
    <listitem><para>Sequential access to the material.
    </para></listitem>
    <listitem><para>Periodic control of the progress and the possibility to repeat a
       lesson without restarting the program.
    </para></listitem>
    <listitem><para>Reasonable sound effects with a possibility to turn the sound off.
    </para></listitem>
    <listitem><para>A brief description of what is going on in the output line rather
       than only in the text windows.
    </para></listitem>
    <listitem><para>etc.
    </para></listitem>
   </itemizedlist>
</para><para>
   First condition is satisfied naturally if you make the program linear
   so one can go into a new room only after all the actions in the
   previous one are complete. In each room the following actions are
   performed:
   <itemizedlist>
    <listitem><para>Displaying the explanatory text.
    </para></listitem>
    <listitem><para>Illustrating the topic using animations, possibly with the
       student's participation.
    </para></listitem>
    <listitem><para>Checking the student's understanding by asking questions.
    </para></listitem>
    <listitem><para>Moving to the next room if the answers are correct.
    </para></listitem>
   </itemizedlist>
</para><para>
   There are two possibilities to display the explanation: displaying the
   text in a text mode; an example is the <emphasis/Thunderstorm/ greeting, see
   <literal/log0.asm/, or displaying the text in a graphics mode using print
   command. This opens a text window in the centre of the screen, resized
   to fit the text to display. The interpreter provides two modes of
   opening the window: it may close automatically after some period of
   time, or close when the user presses the Enter key. If the text does
   not fit on the screen, it is accompanied by a warning message.
   <emphasis/Thunderstorm/ usually uses the second option (text windows).
</para><para>
   To check the student's understanding, a question is asked and three
   numbered choices are displayed in the text window, which closes after
   the student types the choice number he chooses in the input line and
   presses Enter key. This approach I consider the most appropriate. If
   the answer is correct (indicated by a sound signal and increasing the
   score by two points), the room is changed to the next one where the
   teaching continues. If the answer is incorrect (also indicated by a
   sound signal and a corresponding message) the lesson is repeated and
   the score is decreased by one point.
</para>
</sect3>

<sect3><title>Writing <emphasis/Thunderstorm/'s logics</title>
<para>
   The logic that starts teaching is logic 5. Its commented source code
   is in <filename/log05.asm/, this is why I will give here only a short
   description.
</para><para>
   This logic, according to the scenario, explains how a cloud is formed.
</para><para>
   Initialization code loads only the resources that are required for
   displaying the picture that starts the lesson. Because the commentary
   text has to be printed sequentially, one of the variables (<parameter/v130/)
   tracks this sequence. When <parameter/v130/ changes, the
   <function/print_v 130/ command prints a new message. <parameter/v130/
   is incremented when the <keycap/ENTER/ key is pressed, confirming that
   the text has been read and the animation illustrating the explanation
   has been viewed. This way the student is in control of the teaching
   speed.
</para><para>
   Because the program is intended to be executed cyclically, tests of
   <parameter/v130/ value are all over the place. They begin with
   <literal/EQn/ labels where <parameter/n/ is the value of
   <parameter/v130/ at which the corresponding command block is to be
   executed. These blocks load the resources required to illustrate the
   recently printed text and run the required animations.
</para><para>
   Note that in order to repeatedly play an animation associated with an
   object (for example, a shining sun -- object 1), it is not necessary to
   play its animation using <function/end_of_loop/ command and then, when the
   animation end flag is set, issue the command again. It is enough to
   turn on cyclic animation using <function/start_cycling/ and display
   the object on the screen using draw command. The interpreter will
   take care of the rest if you have not forgotten to include the object
   into the list of objects the interpreter controls using the command
   <function/animate_obj/.
</para><para>
   The lesson is finished by printing a question and three possible
   answers (<literal/MENU/ label) using print command with the number of the
   message containing the question as the operand. If the correct answer
   is selected, teaching continues in the room number 7. Before entering
   it all used variables and flags are reset to zero unless they are used
   by other logics.
</para><para>
   The actions in room 7, where the processes inside a cloud are
   illustrated, are described in the logic resource 7 (see source code in
   <filename/log07.asm/. Logic 7 is loaded in memory automatically when
   this room is set as the current using <function/new_room 7/ command
   issued from logic 5. Logic 7 also has a message selection variable
   (<parameter/v130/), the value of which is incremented each time a
   message is issued. When the logic is invoked in a cycle, only the
   block for which the variable value and the block number are the same
   executes. Tests are performed by the commands labelled <lieteral/EQn/
   where <parameter/n/ is the block number.
</para><para>
   This logic manages text windows differently. A window goes away
   automatically after a time period set in variable 21. For example, the
   following shows message 5 in a window visible for 20 seconds
</para><para>
<programlisting>
    reset   15
    ...........
    assignn 21, 40
    print    5
</programlisting>
</para><para>
   Resetting flag 15 means the window should close after a time delay
   specified by the second operand of the assign command, in half second
   intervals. However, the window can be closed before the time interval
   expires using <literal/ENTER/ key.
</para><para>
   Room 7 shows the structure of the cloud and how three raindrops are
   formed. Let is consider how this is done in greater detail. The cloud
   itself is drawn as a backdrop (picture resource 7). How a drop is
   formed is in view resource 14. The drops are described as objects
   controlled by the interpreter with IDs 1, 2, and 3. These objects are
   moved from the top side of the cloud downwards to the specified point
   using <function/move_obj/ command. When the destination point is
   reached the flag specified in <function/move_obj/ is set. The moment
   the motion begins, playback of the view resource associated with the
   object using the <function/set_view/ command is started with the
   <function/end_of_loop/ command. The time delay between the frames
   (set with <literal/cycle_time/), step size -- number of pixels the
   object moves each interpreter cycle (set with <function/step_size/)
   <footnote>I suspect they may actually mean ``each step'' (VB)</footnote>
   and the time delay between the steps (set with <function/step_time/)
   were determined by trial and error so that animation finishes by the
   time the object reaches the destination.
</para><para>
   The drops moving down create air flow (objects 4 and 5 with cycles 1
   and 2 of the view resource 22 associated with them playing
   repeatedly). After all three drops have formed we show how they move
   out of the cloud (it starts raining). This is accompanied by cold air
   flows (object 6, 7 and 8 -- left, centre. and right arrows) directed
   towards the ground. After all drops fall down we move to the room 9
   using <function/new_room 9/.
</para><para>
   This command destroys all loaded logics and resources in the
   interpreter memory used in room 7 (except logic 0) and loads logic 9
   (see its source in <filename/log09.asm/) controlling the animation of
   thunderstorm and the situation after it finishes.
</para><para>
   While you study that logic's source note the following:
   <itemizedlist>
    <listitem><para>How the rain is displayed.
    </para></listitem>
    <listitem><para>How the sound of rain drops is imitated.
    </para></listitem>
    <listitem><para>How lightnings are displayed between the clouds and between a
       cloud and the ground.
    </para></listitem>
    <listitem><para>How the sound of thunder is imitated.
    </para></listitem>
    <listitem><para>How the time delay between a lightning and a thunder is
       implemented and how the thunder is played as if it consists of two
       distinct sounds.
    </para></listitem>
    <listitem><para>How the scenery is changed to that after the thunderstorm.
    </para></listitem>
   </itemizedlist>
</para><para>
   The rain is displayed as eight drops (objects 8 to 15), the algorithm
   of their motion is in logic 10 (source file <filename/log10.asm/).
   The drops are moved across the screen randomly, and in every starting
   point for every drop the playback of the associated animation is
   started. Study the source of this logic referring to its commends.
</para><para>
   There is no ready-made sound resource with the sound of rain drops.
   The sound is generated programmatically from the sound which
   accompanies the rain drops falling down in logic 7 (sound resource 12
   -- two high-pitched beeps with a pause in between). The trick is to not
   let the sound play until completion and restart it on every cycle,
   ignoring the flag associated with that sound.
</para><para>
   The type of a lightning (between the clouds or between the cloud and
   the ground) is chosen randomly. Y coordinate of the lightning between
   the clouds, and both coordinates and the priority (relative to the
   lake shore in picture resource 9) of the lightning striking the
   ground, are also random within a certain range. This creates an effect
   of the lightning striking close to us or far away, as well as moving
   vertically and horizontally.
</para><para>
   There is no prefabricated sound resource for thunder as well. I chose
   the sound with the lowest pitch and stop the playback from the program
   before it terminates normally. Bellowing thunder effect is created by
   allowing the sound to play for a random period of time. The sound is
   also accompanied by the screen shaking using the <function/shake_screen/
   command.
</para><para>
   To create a delay between the events (lightning, then thunder) we
   analyse variable 153 which is incremented on each iteration cycle.
   When the thunder sound finishes playing it is reset to zero and
   everything starts over.
</para><para>
   <emphasis/Thunderstorm/ can be stopped at any time (after at least three
   lightning strikes counted in variable 154) by pressing <keycap/ENTER/ key.
   After that picture resource 10 is loaded in memory using variable 30
   -- the same scenery but after the storm, with the sun, rainbow, and
   seagulls. Speaking of bird watching, logic 112 controlling the gulls
   is not loaded from the initialisation code of logic 9. But logic 112
   has its own initialisation code which can be executed only if flag 5
   is set. We do just that and immediately reset it after the first call
   to logic 112.
</para><para>
   After you have seen enough rainbow and seagulls press <keycap/ENTER/
   and try answering the question. After a correct answer the room is
   changed to 11 using <function/new_room 11/ command, where we tell a
   bit about electricity, lightning and repeat Franklin's experiment.
</para><para>
   The source code is in <filename/log11.asm/ and is, as usual, extensively
   commented. There are no new tricks in that logic. Pay your attention
   to the new test commands that check whether the user-controlled object
   0 (Ego, a cloud) is in a certain area of the screen. Ego is controlled
   using arrow keys. You don't have to program them. To start moving the
   object in a certain direction press the corresponding arrow key once.
   Holding the key down will only slow down the object 0. Object 0 is
   always controlled with these keys, however the program can still
   control it using the interpreter commands.
</para><para>
   Reading the logic source note that after all six messages are
   displayed, flag 230 is set. This prevents showing these messages again
   and the tests starting with label <literal/EQ7/ will execute.
</para><para>
   While Franklin's experiment is performed, and electric charges collect
   on various objects (the tree, the ground, and the water), the cloud is
   allowed to move only within a rectangular area set using block
   command, and the area is positioned in such a way that the cloud
   cannot move vertically. The cloud location is checked using
   <function/center_position/ command (the result is true if the object base's
   center is within the block area). When the test conditions are true
   input line 23 shows a message, for example, ``The kite is in the cloud''
   indicating to the user that the condition set by <function/center_position/
   command is true.
</para><para>
   When we illustrate how electric charges collect on an object under a
   passing cloud, rectangular area set in center_position test is shrunk
   to a vertical line segment. This is why, as the cloud moves, the
   condition tested by this command is true only when the object base
   centre is on the line. If the area were wider all actions selected by
   the condition would execute on each interpreter cycle while the base
   centre of Ego (the cloud) is in the area. This would cause flickering
   of, for example, the message in the line 23 ``The cloud is over the
   ground''. It would flicker as it is displayed on each iteration of the
   cycle. sound resource 15 would also be restarted on each cycle.
</para><para>
   This is why when you display messages using display command, keep in
   mind that the command will display the message on each cycle. This
   will cause the message to flicker unless you guard against multiple
   execution with extra tests. If you use print command, the text in the
   message window would not flicker, of course, but any animation stops
   until the window is closed by pressing <keycap/ENTER/ key.
</para><para>
   Execution of logic 11 finishes by asking the student a question. A
   correct answer moves us to a new room with <function/new_room 13/ command.
</para><para>
   Room 13 illustrates ionisation process in the cloud according to the
   program in logic 13 (see the source code in <filename/log13.asm/).
   This logic is mostly built just like those we have already discussed,
   but the following may be interesting to you:
</para><para>
   We have already discussed the necessity of balancing the artist's and
   programmer's work: the more effort the artist puts in PICTURE and VIEW
   resources, the easier it may be to the programmer to write the program
   animating these resources. If the programmer can draw, or the artist
   can program, this is the best case: they have no turf to divide. If
   everybody can do only his own part of work, probably it is the
   designer's responsibility to choose the best method of implementing
   the design and make the artist's and the programmer's work more
   efficient.
</para><para>
   This is enough to conclude the topic of dividing responsibilities in
   the team. Above, when we discussed the design, I gave an example of
   animating ionisation process and mentioned that we chose to implement
   it as a single animation rather than programmatically moving pictures
   of separate objects. This is more economical. But if you simply played
   this animation after some introductory text, without accompanying it
   with sound, it would be too dull. But how can you create a sound track
   for a fairly large animation when you cannot find a SOUND resource to
   accompany it? I did the following. Picked short sounds best, in my
   opinion, representing various stages of the animation (an electron
   hitting an atom, photon emission, electron emission, and capture of
   the electron by another atom). After that I had to programmatically
   synchronise each stage with its sound. Among the interpreter's
   commands there is a current_cel command which comes in handy. This
   command stores the number of the cel currently displayed on the screen
   in a variable of your choice. Comparing the number with the number of
   animation cel at which the sound should begin playing, I solved the
   problem. Just remember that the sounds should be sufficiently short
   for each of them to play to completion before another sound is due
   playing -- because the flag indicating the end of playback is not
   checked in this logic. This is why computers displaying animations
   faster than the one this program was created on may occasionally
   ``swallow'' sounds.
</para><para>
   This logic uses three animations illustrating a collision of an
   electron with an atom at a certain speed, then another collision at
   double that speed leading to electron emission from the atom (and
   turns the latter into a positive ion), and capturing of the electron
   by another atom which turns into a negative ion. The observer can view
   each process in a slow motion which is accomplished by increasing the
   time delay between frames (in interpreter cycles) using <function/cycle_time/
   command. To illustrate all three stages of ionisation the three parts
   of the animation play repeatedly, changing each other without any
   accompanying text. After each playback of all three animations, a
   short delay is implemented as cycles, during which two variables, 240
   and 241, are incremented. This is because the interpreter allows no
   other means of delaying for a specified period of time. How the delay
   is implemented you can understand yourself, just keep in mind that
   control does not return to the interpreter so any animation stops (for
   example, the stars on the background stop blinking).
</para><para>
   The display of the three ionisation stages can be interrupted at any
   moment by pressing the <keycap/ENTER/ key, which moves us into a new
   room with a <function/new_room 15/ command. The new room illustrates
   how a lightning leader is formed and the measures of lightning protection.
</para><para>
   Events taking place in room 15 are coded in logic 15 (see the source
   in <filename/log15.asm/. This logic follows the programming approach
   we have already discussed, so I shall explain just a few details.
</para><para>
   This is how the destruction of an unprotected house by a lightning
   strike was implemented. Two view resources of the same size were
   created, showing a house being destroyed and a fire. The picture of an
   undamaged house initially displayed is cel 0 or view 16. Then, when
   the centre of the base of the cloud controlled from the keyboard is
   right over the house, animation of the lightning hitting from the
   cloud is started. The cloud motion is stopped by the program at this
   moment. When the lightning touches the roof of the house (cel 8 of the
   lightning animation), cel 0 is changed to cel 1 showing a damaged
   roof. This illustrates how the instantaneous the damage is. After
   that, starting with the first cel, the animation associated with the
   house is played with the given delay between the cels. Event before
   that, the animation of flames was started, programmatically positioned
   ``behind'' the house and playing in a loop. While the house was still
   intact the flames were hidden behind it. This explains how the flame
   takes over the house as the house animation makes larger and larger
   area of its view transparent.
</para><para>
   Note another issue related to illustrating lightning protection, when
   the cloud passes over a lightning pole and discharges through it. This
   moment is chosen by the result of <function/center_position/ test
   command for the cloud (object 0), using a rectangular line small
   enough to be a vertical line fragment. This is why the actions
   associated with the lightning strike are executed only once. That
   vertical line passes through the tip of the lightning pole. Because
   the moment for the lightning strike is chosen when the cloud base
   centre crosses this line, we have to calculate the coordinates of
   the point where the lightning should be positioned for its end to
   hit the tip of the lightning pole. This is accomplished by setting
   an offset between the base points of the cloud and the lightning
   (<parameter/v66/). Besides, the direction of the cloud motion
   (left or right) relative to the lightning pole is important. This
   direction is retrieved using the <function/get_dir/ command and is
   later used to programmatically move the cloud one pixel
   each step after the strike (during the strike the cloud is stopped).
   If we didn't do that after the strike, the condition would be true
   again on the next interpreter cycle and the lightning would strike
   again and again.
</para><para>
   Note that in this logic two different VIEW resources are used as
   animations of the lightning: first view 7, the lightning striking the
   house, then view 34, the lightning striking the lightning pole. Of the
   five animation loops of the latter view only loop 2 is is used which
   shows the vertical lightning.
</para><para>
   In this logic the program is completed by a summary and
   congratulations.
</para><para>
   Now a few words about the principle of distributing resources across
   the volumes I used. File <filename/vol.0/ holds the logic resources,
   <filename/vol.1/ the picture resources, <filename/view.2/ the view
   resources and <filename/vol.3/ the sound resources.
</para><para>
   Finally, note that as you study the sources you will probably notice
   many pieces that could be coded more efficiently. In particular, many
   logics could be made smaller by introducing subroutines (especially
   logic 13 with lots of repeated chunks), etc. I intentionally leave the
   source as it is because I think this form is better suited to studying
   the AGI language.
</para>
</sect3>
</sect2>

<sect2><title>Final Advice</title>

<sect3><title>To the Programmer</title>
<para>
   Remember that:
   <itemizedlist>
    <listitem><para>
      The interpreter works in a cycle described in The Interpreter Work
      Cycle.
    </para><listitem>

    <listitem><para>
      There are reserved variables and flags.
    </para><listitem>

    <listitem><para>
      Logic 0 is loaded in memory at all times and controls your program
      in general, while all other logics control specific rooms you get
      into as the game unfolds.
    </para><listitem>

    <listitem><para>
      Your program is executed by the interpreter in a loop, so do not
      introduce any cycles that would move objects, change their views,
      or play sounds yourself. The interpreter itself will any such
      action and will notify you of completion by setting a flag
      associated with it. The interpreter checks the conditions you
      specify using test commands and executes only the actions with
      true conditions; without the tests, all the commands would execute
      on each cycle. This might slow down the program or break it at
      all. In general, once you have started an action, let it run to
      completion by returning control to the interpreter until the flag
      signalling completion is set -- unless you after after some special
      effects.
    </para><listitem>

    <listitem><para>
      Remember the effect of <literal/new_room/ and <literal/new_room_v/.
    </para><listitem>

    <listitem><para>
      Interpreter's memory is limited! Do not load many resources
      simultaneously, especially if they are not used at the same time.
      Load them as they are needed and keep an eye (during the
      debugging) on the amount of free memory, displaying variable 8 in
      line 23 or 24 using display. If free memory is low, if possible,
      manipulate resources loading them and unloading, or change the
      program structure to introduce more rooms. Make (together with the
      artist) VIEW resources smaller and use shorter sounds. Remember
      that the interpreter loads a SOUND resource only once even if
      there are many commands to load it within the current room. Be
      careful when you discard resources. For example, discard_view
      command discards all resources loaded after the one being
      discarded.
    </para><listitem>

    <listitem><para>
      Include the error handler in your program (logic 97 in the
      example) and do not forget to check if variable 17 is 0.
    </para><listitem>

    <listitem><para>
      You can accidentally associate an inexistent VIEW resource with an
      object as its picture. The interpreter will fail without
      signalling an error. You can avoid this situation if you check the
      number of loops in the resource with <function/number_of_loops/
      command. Use this command when you set the object cycle number using
      <function/set_loop_v/.
    </para><listitem>

    <listitem><para>
      Large VIEW resources not only take more memory but are also slower
      to display. This may even lead to their distortion (gaps in the
      picture). Keep cels as small as possible, best of all -- only large
      enough to fit the object.
    </para><listitem>

    <listitem><para>
      Don't overload the program with controlled objects, especially if
      they are large. The more objects there are, the slower they draw.
      The interpreter can control at most 15 objects at any time.
    </para><listitem>

    <listitem><para>
      About the built-in debugger. If its table <filename/log.dbg/ is
      loaded in memory, the debugger can be turned on using the
      <keycap/Scroll Lock/ key. It can help you trace the program logic.
    </para><listitem>

    <listitem><para>
      The logic called with <function/call/ command is loaded temporarily
      and removed after the call. If it is called often, this wastes time.
      Load often called logics explicitly using <function/load_logic/
      command.
    </para><listitem>

    <listitem><para>
      All variables and flags are accessible from any logic.
    </para><listitem>

    <listitem><para>
      Before you change rooms clear all variables and flags you work
      with. This will save you some nasty surprises. You may select a
      fixed group of variables and flags and use it as work variables
      everywhere. Cleanup procedure can then be a subroutine called
      before entering any new room.
    </para><listitem>

    <listitem><para>
      There is no tool in the package (maybe you can create such
      yourself using the interpreter as the foundation) to combine
      PICTURE and VIEW resources on the screen to see them against each
      other and arrange objects in the best way. This should be done by
      trial and error, adjusting the program and interacting with the
      artist.
    </para><listitem>

    <listitem><para>
      The interpreter cannot process images (VIEW resources): it is
      impossible to resize them, rotate, etc. All that should be painted
      by the artist.
    </para><listitem>

    <listitem><para>
      The parser works only with Roman letters and is biased towards
      English, i.e. the input can include only English words unless you
      do something special, like replace regular ASCII table with
      Cyrillic but even that will unlikely give the desired result as
      the interpreter ignores certain codes, so you will not be able to
      use them.<footnote>I should say this is overly pessimistic as I saw
      myself KQ3 hacked by someone to be in Russian: it printed all
      messages in Russian and understood Russian commands! (VB)</footnote>
    </para><listitem>

    <listitem><para>
      Messages in Russian are printed fine, except you should use a
      capital Roman A instead of a capital Cyrillic A.<footnote>(The
      shape of the letter ``A'' is the same in Cyrillic but it is
      represented with a different byte value. (VB)</footnote>
    </para><listitem>

    <listitem><para>
      Distribute resources over volumes so that their size is about the
      same. This will speed up the access.
    </para><listitem>

    <listitem><para>
      No explanations are worth as much as you own experience and
      studying the source of Sierra games. You can extract their logics
      using VM utility and disassemble the source using SM utility. You
      may have to search for text in many files, I recommend
      <filename/ts.exe/ from Norton Utilities for that.<footnote>This is
      what is actually called ``grepping the source'' and <literal/grep(1)/
      is tool to use. (VB)</footnote>
    </para><listitem>
   </itemizedlist>
</para>

<sect3><title>To the Artist</title>
<para>
   Remember that:
   <itemizedlist>
    <listitem><para>
      You should be able to use an IBM PC.
    </para><listitem>

    <listitem><para>
      Your tools are PV and VIM utilities. Their manuals are detailed
      enough.
    </para><listitem>

    <listitem><para>
      PM is used to create backdrops, VIM to create animations.
    </para><listitem>
   </itemizedlist>
</para>
<para>
   When you use PM

   <itemizedlist>
   
    <listitem><para>
      If the mouse cursor is ``jumpy'', try to use a Microsoft mouse
      driver.
    </para></listitem>

    <listitem><para>
      Don't use long lines, the interpreter may have problems drawing
      them. Break such lines into segments.
    </para></listitem>

    <listitem><para>
      If you have to draw round objects, don't use round dots. Most
      often than not, they are drawn incorrectly.
    </para></listitem>

    <listitem><para>
      It doesn't matter how you draw the backdrop, what goes first and
      what next. Only the result is important because PICTURE resources
      are first drawn in an internal buffer and only then displayed on
      the screen. The process of drawing is not visible and you don't
      have to prettify an otherwise good picture.<footnote>Interpreters on
      Apple II did not have an internal buffer because of the lack of
      RAM and did draw PICTURE resources directly on the screen, so
      the process was visible. (VB))</footnote> But you might be
      interested on how Sierra artists drew their pictures, so extract
      some of the PICTURE resources from the games and trace them using PM.
    </para></listitem>

    <listitem><para>
      Fine details are better created as bitmaps (VIEWs) using VIM
      because they would take too many PM commands. The programmer will
      overlay these images on the backdrop using the <function/add_to_pic/
      command. But be careful about that. <emphasis>(Why? --VB)</emphasis>
    </para></listitem>

    <listitem><para>
      Every once in a while, save using the <keycap/W/ key.
    </para></listitem>

    <listitem><para>
      To correct already existing commands you have to be familiar with
      their format. Be careful.
    </para></listitem>

   </itemizedlist>
</para>

<para>
   Using VIM:</title>
</para>
<para>
   <itemizedlist>
    <listitem><para>
      Use 0 (black) as the cel background! Due to an editor bug
      only 0 can actually be transparent. Of course, that means you cannot
      use black for drawing. This advice will probably be obsolete when
      an updated editor is released.
    </para></listitem>

    <listitem><para>
      Don't ``bloat'' the cels, make them just large enough to fit the
      image. If possible, create loops of cels of variable size to make
      them as small as possible. Note that <emphasis/Thunderstorm/ view
      resources are not an example in this respect.
    </para></listitem>

    <listitem><para>
      When you create a VIEW resource, the first command line argument
      is the number of loops in the resource. It may happen that you
      have to change the number of loops in the resource as you work on
      a program. To do that you will have to save all cels using the S
      command (issued for each individual cel because it saves the cels
      in separate files under automatically generated names), then
      create a new VIEW with the required number of loops and load all
      cels back using L command. See VIM manual how the cel file names
      are generated.
    </para></listitem>

    <listitem><para>
      Drawing an animation, use colour reference points in each cel. Use
      the fact that as cels are changed the cursor stays where it was in
      the previous cel.<footnote>He means changing cels in the editor, not
      during playback by the interpreter. (VM)</footnote>
    </para></listitem>

    <listitem><para>
      Do not create animations with more than 23--24 cels. The editor may
      crash, at least the version we have.
    </para></listitem>

    <listitem><para>
      The best advisor is your experience.
    </para></listitem>
   </itemizedlist>
</para>
</sect3>

<sect3><title>To the Designer</title>
<para>
   You have to know everything! Your design is the key to success! Read
   carefully the manual and this text. Play Sierra games to understand
   what the interpreter can do. You are the key person!
</para>
</sect3>
</sect2>

<sect2><title>About other utilities</title>
<para>
   This is mostly about quirks I ran into working with them on IBM XT.
   This applies only to the utility versions I have.
</para><para>
   <variablelist>
    <varlistentry><term/DUU/
     <listitem>
      <para>
          Incorrectly includes the debugger table in the volumes. In the
          result the debugger does not work.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry><term/VM/
     <listitem>
      <para>
          Does not link volumes. I linked everything using DUU.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry><term/OM/
     <listitem>
      <para>
          Extracting lists of objects from Sierra games, you have to pick
          the translation key for each particular game for the list to
          restore correctly. Experiment.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry><term/WL and WM/
     <listitem>
      <para>
          No problems found.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry><term/SM/
     <listitem>
      <para>
          How to insert backward references using the decimal offset I
          explained in the package's manual. There is nothing else to
          say.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
</para>
<para>
   This is about all I wanted to say. Now, if you haven't done so yet,
   try running <emphasis/Thunderstorm/ after building it using bld.bat batch file.
   The program asks five simple questions, the correct sequence of
   answers is 2, 3, 2, 1, 3.
</para><para>
   Of course, the <emphasis/Thunderstorm/ does not use all of the interpreter's
   capabilities. My goal was to explain the most important aspects of its
   operation. I hope my story will help you start creating your own
   programs as quickly as possible. I wish you to not repeat my mistakes
   (unlikely though it is) and I apologise for being subjective on
   occasions and, possibly, repeating myself.
</para><para>
   On behalf of our group (L.E. Kalihman, D.V. Spasibenko and myself) I
   wish you success in creating your own programs. Everything depends on
   your will and skills!
</para>
</sect>

<sect2><title>License Agreement</title>
<para>
<quote>
     By receiving the <emphasis/Thunderstorm/ educational program you
     acknowledge my exclusive rights to all source code of its logics
     (except logics 10 and 112). Any modification of the source code
     with the purpose other than study, as well as distribution of such
     source, or the text of accompanying documents without purchasing
     the AGDS package is considered a copyright infringement.
     <emphasis/Thunderstorm/ Copyright (C) Intep Corp, Cheboksary City.
     All rights reserved. <emphasis/Thunderstorm/ can be purchased with
     the source code from Intep Corp, Cheboksary City, or from Elias Corp,
     Moscow, as a demo code of AGDS package.
</quote>
</para>

<quote>
                                                              August 1991
                                                          Cheboksary City
</quote>
</para>
</sect1>

<sect1 id="otheragi"><title>Other AGI interpreters</title>
<para>
   Besides <ulink name="agds"/AGDS/ (which was the first non-Sierra
   AGI interpreter), a number of
   alternative interpreters have been brought to light in the last few years.
   None of them is fully functional at the time of this writing, although
   good progress is being made to have full compatibility with the original
   Sierra interpreter. Some of the new interpreters are portable and
   open the possibility of playing the Sierra AGI classics natively in
   platforms where the original AGI interpreter has never been ported,
   such as UNIX and BeOS. The new possibilities include four voice PCjr
   or sixteen-voice, digitally sampled IIgs sound replaying in the IBM-PC.

   <variablelist>
   <varlistentry><term/MEKA/ <listitem>
   <para>
   MEKA stands for ``Möller, Ewing and Kelly Adventure'' and has
   been developed by AGI hackers Joakim Möller, Lance Ewing and Peter Kelly
   using DJGPP and the Allegro library to run under MS-DOS. It has
   support for both v2 and v3 games, and some routines from MEKA have been
   reused in Sarien, specifcally the LZW decompression routines and modified
   picture decoding routines.
   </para>
   </listitem></varlistentry>

   <varlistentry><term/JAGI/ <listitem>
   <para>
   JAGI (1998) is a free AGI interpreter for Linux written in C by
   Jens Christian Restemeier. JAGI uses GGI for graphics output and OSS
   for sound. The latest available version is 0.1, distributed under
   the GNU GPL. JAGI supports only v2 games.
   </para>
   </listitem></varlistentry>

   <varlistentry><term/Sarien/ <listitem>
   <para>
   Formerly known as Yggdrasil, <ulink name="http://homepages.ihug.com.au/~entropy/agi/"/Sarien/ (1999) is a portable AGI interpreter
   developed by Stuart George and distributed under the GNU GPL. It runs in the
   MS-DOS and Linux platforms and is capable of playing v2 and v3 AGI and AGDS
   games. (If you like acronyms, Sarien can be interpreted as a ``Sierra AGI
   Resource Interpreter ENgine''.)
   </para>
   </listitem></varlistentry>

   <varlistentry><term/LAGII/ <listitem>
   <para>
   Developed by XoXus, the Linux AGI Interpreter, or
   <ulink name="http://www.zip.com.au/~gsymonds/LAGII/"/LAGII/ (1999), runs
   in the Linux console using SVGAlib. Currently it supports v2 games.
   Fully expanded, LAGII stands for ``Linux Adventure Game Interpreter
   Interpreter''. It is distributed under the GNU GPL.
   </para>
   </listitem></varlistentry>
   </variablelist>
</para>
</sect1>
</chapter>

</Book>

